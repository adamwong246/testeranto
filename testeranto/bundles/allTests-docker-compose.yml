version: '3.8'
services:
  node-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/node/node.Dockerfile
      tags:
        - bundles-node-build:latest
      args:
        NODE_MJS_HASH: cab84cac12fc3913ce45e7e53425b8bb
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    image: bundles-node-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/node
      METAFILES_DIR: /workspace/testeranto/metafiles/node
      DOCKERMAN_PORT: '53290'
    command:
      - sh
      - '-c'
      - |-
        echo 'Starting node build in watch mode...'; 
                        echo 'Installing dependencies in /workspace/node_modules...'; 
                        cd /workspace &&                 # Remove any .npmrc files
                        rm -f .npmrc .npmrc.* || true &&                 # Clear npm cache and authentication
                        npm cache clean --force &&                 # Clear any npm authentication
                        npm config delete _auth 2>/dev/null || true &&                 npm config delete _authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_auth 2>/dev/null || true &&                 npm config delete always-auth 2>/dev/null || true &&                 npm config delete registry 2>/dev/null || true &&                 npm config set registry https://registry.npmjs.org/ &&                 npm config set always-auth false &&                 npm install --legacy-peer-deps --no-audit --no-fund --ignore-scripts --no-optional || echo "npm install may have warnings";
                        echo 'Ensuring esbuild and esbuild-sass-plugin are installed for Linux platform...';
                        npm list esbuild 2>/dev/null || npm install --no-save esbuild@0.20.1 --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild installation may have issues";
                        npm list esbuild-sass-plugin 2>/dev/null || npm install --no-save esbuild-sass-plugin --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild-sass-plugin installation may have issues";
                        echo 'Creating output directory...'; 
                        mkdir -p /workspace/testeranto/bundles/allTests/node;
                        mkdir -p /workspace/testeranto/metafiles/node;
                        echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                        # Create a dummy allTests.json to pass health check initially
                        echo '{"status":"building"}' > /workspace/testeranto/metafiles/node/allTests.json;
                        # Run in watch mode and keep the process alive
                        npx tsx dist/prebuild/builders/node.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                        # Keep the container running even if the build command exits
                        while true; do
                          sleep 3600
                        done
    healthcheck:
      test:
        - CMD-SHELL
        - '[ -f /workspace/testeranto/metafiles/node/allTests.json ] && echo "healthy" || exit 1'
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  web-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/web/web.Dockerfile
      tags:
        - bundles-web-build:latest
      args: {}
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    image: bundles-web-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/web
      METAFILES_DIR: /workspace/testeranto/metafiles/web
      DOCKERMAN_PORT: '53290'
    command:
      - sh
      - '-c'
      - |-
        echo 'Starting web build in watch mode...'; 
                        echo 'Installing dependencies in /workspace/node_modules...'; 
                        cd /workspace &&                 # Remove any .npmrc files
                        rm -f .npmrc .npmrc.* || true &&                 # Clear npm cache and authentication
                        npm cache clean --force &&                 # Clear any npm authentication
                        npm config delete _auth 2>/dev/null || true &&                 npm config delete _authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_auth 2>/dev/null || true &&                 npm config delete always-auth 2>/dev/null || true &&                 npm config delete registry 2>/dev/null || true &&                 npm config set registry https://registry.npmjs.org/ &&                 npm config set always-auth false &&                 npm install --legacy-peer-deps --no-audit --no-fund --ignore-scripts --no-optional || echo "npm install may have warnings";
                        echo 'Ensuring esbuild and esbuild-sass-plugin are installed for Linux platform...';
                        npm list esbuild 2>/dev/null || npm install --no-save esbuild@0.20.1 --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild installation may have issues";
                        npm list esbuild-sass-plugin 2>/dev/null || npm install --no-save esbuild-sass-plugin --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild-sass-plugin installation may have issues";
                        echo 'Creating output directory...'; 
                        mkdir -p /workspace/testeranto/bundles/allTests/web;
                        mkdir -p /workspace/testeranto/metafiles/web;
                        echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                        # Create a dummy allTests.json to pass health check initially
                        echo '{"status":"building"}' > /workspace/testeranto/metafiles/web/allTests.json;
                        # Run in watch mode and keep the process alive
                        npx tsx dist/prebuild/builders/web.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                        # Keep the container running even if the build command exits
                        while true; do
                          sleep 3600
                        done
    healthcheck:
      test:
        - CMD-SHELL
        - '[ -f /workspace/testeranto/metafiles/web/allTests.json ] && echo "healthy" || exit 1'
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  golang-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/golang/golang.Dockerfile
      tags:
        - bundles-golang-build:latest
      args: {}
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    image: bundles-golang-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/golang
      METAFILES_DIR: /workspace/testeranto/metafiles/golang
      DOCKERMAN_PORT: '53290'
    command:
      - sh
      - '-c'
      - |-
        echo 'Starting golang build in watch mode...'; 
                        echo 'Installing dependencies in /workspace/node_modules...'; 
                        cd /workspace &&                 # Remove any .npmrc files
                        rm -f .npmrc .npmrc.* || true &&                 # Clear npm cache and authentication
                        npm cache clean --force &&                 # Clear any npm authentication
                        npm config delete _auth 2>/dev/null || true &&                 npm config delete _authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_auth 2>/dev/null || true &&                 npm config delete always-auth 2>/dev/null || true &&                 npm config delete registry 2>/dev/null || true &&                 npm config set registry https://registry.npmjs.org/ &&                 npm config set always-auth false &&                 npm install --legacy-peer-deps --no-audit --no-fund --ignore-scripts --no-optional || echo "npm install may have warnings";
                        echo 'Ensuring esbuild and esbuild-sass-plugin are installed for Linux platform...';
                        npm list esbuild 2>/dev/null || npm install --no-save esbuild@0.20.1 --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild installation may have issues";
                        npm list esbuild-sass-plugin 2>/dev/null || npm install --no-save esbuild-sass-plugin --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild-sass-plugin installation may have issues";
                        echo 'Creating output directory...'; 
                        mkdir -p /workspace/testeranto/bundles/allTests/golang;
                        mkdir -p /workspace/testeranto/metafiles/golang;
                        echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                        # Create a dummy allTests.json to pass health check initially
                        echo '{"status":"building"}' > /workspace/testeranto/metafiles/golang/allTests.json;
                        # Run in watch mode and keep the process alive
                        npx tsx dist/prebuild/builders/golang.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                        # Keep the container running even if the build command exits
                        while true; do
                          sleep 3600
                        done
    healthcheck:
      test:
        - CMD-SHELL
        - '[ -f /workspace/testeranto/metafiles/golang/allTests.json ] && echo "healthy" || exit 1'
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  python-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/python/python.Dockerfile
      tags:
        - bundles-python-build:latest
      args: {}
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    image: bundles-python-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/python
      METAFILES_DIR: /workspace/testeranto/metafiles/python
      DOCKERMAN_PORT: '53290'
    command:
      - sh
      - '-c'
      - |-
        echo 'Starting python build in watch mode...'; 
                        echo 'Installing dependencies in /workspace/node_modules...'; 
                        cd /workspace &&                 # Remove any .npmrc files
                        rm -f .npmrc .npmrc.* || true &&                 # Clear npm cache and authentication
                        npm cache clean --force &&                 # Clear any npm authentication
                        npm config delete _auth 2>/dev/null || true &&                 npm config delete _authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_authToken 2>/dev/null || true &&                 npm config delete //registry.npmjs.org/:_auth 2>/dev/null || true &&                 npm config delete always-auth 2>/dev/null || true &&                 npm config delete registry 2>/dev/null || true &&                 npm config set registry https://registry.npmjs.org/ &&                 npm config set always-auth false &&                 npm install --legacy-peer-deps --no-audit --no-fund --ignore-scripts --no-optional || echo "npm install may have warnings";
                        echo 'Ensuring esbuild and esbuild-sass-plugin are installed for Linux platform...';
                        npm list esbuild 2>/dev/null || npm install --no-save esbuild@0.20.1 --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild installation may have issues";
                        npm list esbuild-sass-plugin 2>/dev/null || npm install --no-save esbuild-sass-plugin --no-audit --no-fund --ignore-scripts --no-optional || echo "esbuild-sass-plugin installation may have issues";
                        echo 'Creating output directory...'; 
                        mkdir -p /workspace/testeranto/bundles/allTests/python;
                        mkdir -p /workspace/testeranto/metafiles/python;
                        echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                        # Create a dummy allTests.json to pass health check initially
                        echo '{"status":"building"}' > /workspace/testeranto/metafiles/python/allTests.json;
                        # Run in watch mode and keep the process alive
                        npx tsx dist/prebuild/builders/python.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                        # Keep the container running even if the build command exits
                        while true; do
                          sleep 3600
                        done
    healthcheck:
      test:
        - CMD-SHELL
        - '[ -f /workspace/testeranto/metafiles/python/allTests.json ] && echo "healthy" || exit 1'
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  node-src-example-calculator-test-ts:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/node/src/example/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/node
      METAFILES_DIR: /testeranto/metafiles/node
      TEST_RESOURCES: '{"name":"node-src-example-calculator-test-ts","fs":"./reports/allTests/node","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}'
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '53290'
      TESTERANTO_RUNTIME: node
    command:
      - sh
      - '-c'
      - |-
        echo "=== Starting test service for src/example/Calculator.test.ts ==="
                        echo "Bundle path: testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                        echo "Runtime: node"
                        echo "Test name: src/example/Calculator.test.ts"
                        echo "=== Environment variables ==="
                        env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                        echo "=== End environment variables ==="
                        # Debug: Show DOCKERMAN_HOST and DOCKERMAN_PORT
                        echo "DOCKERMAN_HOST='$DOCKERMAN_HOST'"
                        echo "DOCKERMAN_PORT='$DOCKERMAN_PORT'"
                        
                        # Build service health is managed by Docker Compose depends_on
                        echo "Build service node-build health is managed by Docker Compose"
                        
                        # Get DockerMan port from environment variable
                        if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                          echo "ERROR: DOCKERMAN_PORT environment variable is not set or is 0"
                          echo "The DockerMan TCP server port must be passed via the DOCKERMAN_PORT environment variable."
                          echo "Make sure the TCP server is running and the port is passed to docker-compose."
                          exit 1
                        fi
                        echo "Using DockerMan port from environment variable: $DOCKERMAN_PORT"
                        
                        # Wait for the bundle file to exist (skip for golang since it uses source files directly)
                        if [ "node" = "golang" ]; then
                          echo "Golang runtime detected: using source file directly, not waiting for bundle"
                          # Check if source file exists
                          if [ ! -f "src/example/Calculator.test.ts" ]; then
                            echo "ERROR: Source file not found at src/example/Calculator.test.ts"
                            exit 1
                          fi
                          echo "Source file found: src/example/Calculator.test.ts"
                        else
                          echo "Waiting for bundle file: testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                          MAX_BUNDLE_RETRIES=60
                          BUNDLE_RETRY_COUNT=0
                          while [ ! -f "testeranto/bundles/allTests/node/src/example/Calculator.test.mjs" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                            echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                            BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                            sleep 2
                          done
                          
                          if [ ! -f "testeranto/bundles/allTests/node/src/example/Calculator.test.mjs" ]; then
                            echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                            echo "The build service may have failed to create the bundle."
                            exit 1
                          fi
                          echo "Build is ready. Proceeding with test...";
                        fi
                        
                        # Wait for DockerMan TCP server to be reachable
                        # Ensure DOCKERMAN_HOST has a value
                        if [ -z "$DOCKERMAN_HOST" ]; then
                          DOCKERMAN_HOST="host.docker.internal"
                          echo "DOCKERMAN_HOST was empty, using default: $DOCKERMAN_HOST"
                        fi
                        
                        # Try multiple host options if the default doesn't work
                        HOSTS_TO_TRY="$DOCKERMAN_HOST"
                        # Add gateway IP for Linux containers
                        GATEWAY_IP=$(ip route | grep default | awk '{print $3}' 2>/dev/null || echo "")
                        if [ -n "$GATEWAY_IP" ]; then
                          HOSTS_TO_TRY="$HOSTS_TO_TRY $GATEWAY_IP"
                        fi
                        # Add docker host IP
                        HOSTS_TO_TRY="$HOSTS_TO_TRY 172.17.0.1"
                        
                        echo "Waiting for DockerMan TCP server to be reachable on port $DOCKERMAN_PORT..."
                        echo "Will try hosts: $HOSTS_TO_TRY"
                        
                        MAX_RETRIES=30
                        RETRY_COUNT=0
                        SUCCESS=0
                        
                        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ $SUCCESS -eq 0 ]; do
                          for HOST in $HOSTS_TO_TRY; do
                            echo "Trying to connect to $HOST:$DOCKERMAN_PORT (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
                            # Try using netcat if available
                            if command -v nc >/dev/null 2>&1; then
                              if nc -z -w 1 "$HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                                echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via nc)"
                                DOCKERMAN_HOST="$HOST"
                                SUCCESS=1
                                break
                              fi
                            # Fallback to /dev/tcp
                            elif (echo > "/dev/tcp/$HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                              echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                              DOCKERMAN_HOST="$HOST"
                              SUCCESS=1
                              break
                            fi
                          done
                          
                          if [ $SUCCESS -eq 0 ]; then
                            echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                            RETRY_COUNT=$((RETRY_COUNT+1))
                            sleep 2
                          fi
                        done
                        
                        if [ $SUCCESS -eq 0 ]; then
                          echo "ERROR: DockerMan TCP server never became reachable on port $DOCKERMAN_PORT"
                          echo "Tried hosts: $HOSTS_TO_TRY"
                          echo "Make sure the TCP server is running on the host and accessible from containers."
                          echo "On Linux, you may need to expose the port differently or use host networking."
                          exit 1
                        fi
                        
                        echo "Using DockerMan host: $DOCKERMAN_HOST"
                        
                        # Run the test based on runtime
                        echo "=== Running test ==="
                        if [ "node" = "node" ] || [ "node" = "web" ]; then
                          echo "Executing: node testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                          node testeranto/bundles/allTests/node/src/example/Calculator.test.mjs
                        elif [ "node" = "golang" ]; then
                          # For golang, we need to compile and run the test program
                          # testPath is something like "src/example/Calculator.golingvu.test.go"
                          echo "Running golang (golingvu) test: src/example/Calculator.test.ts"
                          
                          # First, check if we're in the right directory
                          echo "Current directory: $(pwd)"
                          echo "Checking if test file exists: src/example/Calculator.test.ts"
                          
                          if [ ! -f "src/example/Calculator.test.ts" ]; then
                            echo "ERROR: Test file not found at src/example/Calculator.test.ts"
                            exit 1
                          fi
                          
                          # Try to determine the best way to run this test
                          # Since it's a golingvu test, it might need special handling
                          # For now, try to run it with go run
                          echo "Attempting to run with: go run src/example/Calculator.test.ts"
                          go run "src/example/Calculator.test.ts"
                          RUN_EXIT_CODE=$?
                          
                          if [ $RUN_EXIT_CODE -eq 0 ]; then
                            echo "Go run succeeded"
                            exit 0
                          else
                            echo "Go run failed with exit code: $RUN_EXIT_CODE"
                            echo "Trying alternative approach..."
                            
                            # Try building and running as executable
                            TEST_DIR=$(dirname "src/example/Calculator.test.ts")
                            TEST_FILE=$(basename "src/example/Calculator.test.ts")
                            EXECUTABLE_NAME="/tmp/golang_test_$(echo src/example/Calculator.test.ts | tr '/' '_' | tr '.' '_')"
                            
                            echo "Building in directory: $TEST_DIR"
                            cd "$TEST_DIR" || { echo "ERROR: Failed to change to directory $TEST_DIR"; exit 1; }
                            
                            echo "Building: go build -o $EXECUTABLE_NAME $TEST_FILE"
                            go build -o $EXECUTABLE_NAME $TEST_FILE
                            
                            if [ $? -eq 0 ]; then
                              echo "Build successful, running: $EXECUTABLE_NAME"
                              $EXECUTABLE_NAME
                              BUILD_EXIT_CODE=$?
                              echo "Executable exited with code: $BUILD_EXIT_CODE"
                              exit $BUILD_EXIT_CODE
                            else
                              echo "ERROR: All attempts to run golang test failed"
                              echo "This might be a golingvu test that requires special handling"
                              exit 1
                            fi
                          fi
                        elif [ "node" = "python" ]; then
                          echo "Executing: python src/example/Calculator.test.ts"
                          python src/example/Calculator.test.ts
                        else
                          echo "ERROR: Unknown runtime: node"
                          exit 1
                        fi
                        
                        TEST_EXIT_CODE=$?
                        echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                        exit $TEST_EXIT_CODE
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    depends_on:
      node-build:
        condition: service_healthy
    working_dir: /workspace
  web-src-example-calculator-test-ts:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/web/src/example/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/web
      METAFILES_DIR: /testeranto/metafiles/web
      TEST_RESOURCES: '{"name":"web-src-example-calculator-test-ts","fs":"./reports/allTests/web","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}'
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '53290'
      TESTERANTO_RUNTIME: web
    command:
      - sh
      - '-c'
      - |-
        echo "=== Starting test service for src/example/Calculator.test.ts ==="
                        echo "Bundle path: testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                        echo "Runtime: web"
                        echo "Test name: src/example/Calculator.test.ts"
                        echo "=== Environment variables ==="
                        env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                        echo "=== End environment variables ==="
                        # Debug: Show DOCKERMAN_HOST and DOCKERMAN_PORT
                        echo "DOCKERMAN_HOST='$DOCKERMAN_HOST'"
                        echo "DOCKERMAN_PORT='$DOCKERMAN_PORT'"
                        
                        # Build service health is managed by Docker Compose depends_on
                        echo "Build service web-build health is managed by Docker Compose"
                        
                        # Get DockerMan port from environment variable
                        if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                          echo "ERROR: DOCKERMAN_PORT environment variable is not set or is 0"
                          echo "The DockerMan TCP server port must be passed via the DOCKERMAN_PORT environment variable."
                          echo "Make sure the TCP server is running and the port is passed to docker-compose."
                          exit 1
                        fi
                        echo "Using DockerMan port from environment variable: $DOCKERMAN_PORT"
                        
                        # Wait for the bundle file to exist (skip for golang since it uses source files directly)
                        if [ "web" = "golang" ]; then
                          echo "Golang runtime detected: using source file directly, not waiting for bundle"
                          # Check if source file exists
                          if [ ! -f "src/example/Calculator.test.ts" ]; then
                            echo "ERROR: Source file not found at src/example/Calculator.test.ts"
                            exit 1
                          fi
                          echo "Source file found: src/example/Calculator.test.ts"
                        else
                          echo "Waiting for bundle file: testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                          MAX_BUNDLE_RETRIES=60
                          BUNDLE_RETRY_COUNT=0
                          while [ ! -f "testeranto/bundles/allTests/web/src/example/Calculator.test.mjs" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                            echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                            BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                            sleep 2
                          done
                          
                          if [ ! -f "testeranto/bundles/allTests/web/src/example/Calculator.test.mjs" ]; then
                            echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                            echo "The build service may have failed to create the bundle."
                            exit 1
                          fi
                          echo "Build is ready. Proceeding with test...";
                        fi
                        
                        # Wait for DockerMan TCP server to be reachable
                        # Ensure DOCKERMAN_HOST has a value
                        if [ -z "$DOCKERMAN_HOST" ]; then
                          DOCKERMAN_HOST="host.docker.internal"
                          echo "DOCKERMAN_HOST was empty, using default: $DOCKERMAN_HOST"
                        fi
                        
                        # Try multiple host options if the default doesn't work
                        HOSTS_TO_TRY="$DOCKERMAN_HOST"
                        # Add gateway IP for Linux containers
                        GATEWAY_IP=$(ip route | grep default | awk '{print $3}' 2>/dev/null || echo "")
                        if [ -n "$GATEWAY_IP" ]; then
                          HOSTS_TO_TRY="$HOSTS_TO_TRY $GATEWAY_IP"
                        fi
                        # Add docker host IP
                        HOSTS_TO_TRY="$HOSTS_TO_TRY 172.17.0.1"
                        
                        echo "Waiting for DockerMan TCP server to be reachable on port $DOCKERMAN_PORT..."
                        echo "Will try hosts: $HOSTS_TO_TRY"
                        
                        MAX_RETRIES=30
                        RETRY_COUNT=0
                        SUCCESS=0
                        
                        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ $SUCCESS -eq 0 ]; do
                          for HOST in $HOSTS_TO_TRY; do
                            echo "Trying to connect to $HOST:$DOCKERMAN_PORT (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
                            # Try using netcat if available
                            if command -v nc >/dev/null 2>&1; then
                              if nc -z -w 1 "$HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                                echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via nc)"
                                DOCKERMAN_HOST="$HOST"
                                SUCCESS=1
                                break
                              fi
                            # Fallback to /dev/tcp
                            elif (echo > "/dev/tcp/$HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                              echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                              DOCKERMAN_HOST="$HOST"
                              SUCCESS=1
                              break
                            fi
                          done
                          
                          if [ $SUCCESS -eq 0 ]; then
                            echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                            RETRY_COUNT=$((RETRY_COUNT+1))
                            sleep 2
                          fi
                        done
                        
                        if [ $SUCCESS -eq 0 ]; then
                          echo "ERROR: DockerMan TCP server never became reachable on port $DOCKERMAN_PORT"
                          echo "Tried hosts: $HOSTS_TO_TRY"
                          echo "Make sure the TCP server is running on the host and accessible from containers."
                          echo "On Linux, you may need to expose the port differently or use host networking."
                          exit 1
                        fi
                        
                        echo "Using DockerMan host: $DOCKERMAN_HOST"
                        
                        # Run the test based on runtime
                        echo "=== Running test ==="
                        if [ "web" = "node" ] || [ "web" = "web" ]; then
                          echo "Executing: node testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                          node testeranto/bundles/allTests/web/src/example/Calculator.test.mjs
                        elif [ "web" = "golang" ]; then
                          # For golang, we need to compile and run the test program
                          # testPath is something like "src/example/Calculator.golingvu.test.go"
                          echo "Running golang (golingvu) test: src/example/Calculator.test.ts"
                          
                          # First, check if we're in the right directory
                          echo "Current directory: $(pwd)"
                          echo "Checking if test file exists: src/example/Calculator.test.ts"
                          
                          if [ ! -f "src/example/Calculator.test.ts" ]; then
                            echo "ERROR: Test file not found at src/example/Calculator.test.ts"
                            exit 1
                          fi
                          
                          # Try to determine the best way to run this test
                          # Since it's a golingvu test, it might need special handling
                          # For now, try to run it with go run
                          echo "Attempting to run with: go run src/example/Calculator.test.ts"
                          go run "src/example/Calculator.test.ts"
                          RUN_EXIT_CODE=$?
                          
                          if [ $RUN_EXIT_CODE -eq 0 ]; then
                            echo "Go run succeeded"
                            exit 0
                          else
                            echo "Go run failed with exit code: $RUN_EXIT_CODE"
                            echo "Trying alternative approach..."
                            
                            # Try building and running as executable
                            TEST_DIR=$(dirname "src/example/Calculator.test.ts")
                            TEST_FILE=$(basename "src/example/Calculator.test.ts")
                            EXECUTABLE_NAME="/tmp/golang_test_$(echo src/example/Calculator.test.ts | tr '/' '_' | tr '.' '_')"
                            
                            echo "Building in directory: $TEST_DIR"
                            cd "$TEST_DIR" || { echo "ERROR: Failed to change to directory $TEST_DIR"; exit 1; }
                            
                            echo "Building: go build -o $EXECUTABLE_NAME $TEST_FILE"
                            go build -o $EXECUTABLE_NAME $TEST_FILE
                            
                            if [ $? -eq 0 ]; then
                              echo "Build successful, running: $EXECUTABLE_NAME"
                              $EXECUTABLE_NAME
                              BUILD_EXIT_CODE=$?
                              echo "Executable exited with code: $BUILD_EXIT_CODE"
                              exit $BUILD_EXIT_CODE
                            else
                              echo "ERROR: All attempts to run golang test failed"
                              echo "This might be a golingvu test that requires special handling"
                              exit 1
                            fi
                          fi
                        elif [ "web" = "python" ]; then
                          echo "Executing: python src/example/Calculator.test.ts"
                          python src/example/Calculator.test.ts
                        else
                          echo "ERROR: Unknown runtime: web"
                          exit 1
                        fi
                        
                        TEST_EXIT_CODE=$?
                        echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                        exit $TEST_EXIT_CODE
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    depends_on:
      web-build:
        condition: service_healthy
    working_dir: /workspace
  golang-src-example-calculator-golingvu-test-go:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/golang/src/example/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/golang
      METAFILES_DIR: /testeranto/metafiles/golang
      TEST_RESOURCES: '{"name":"golang-src-example-calculator-golingvu-test-go","fs":"./reports/allTests/golang","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}'
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '53290'
      TESTERANTO_RUNTIME: golang
    command:
      - sh
      - '-c'
      - |-
        echo "=== Starting test service for src/example/Calculator.golingvu.test.go ==="
                        echo "Bundle path: testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                        echo "Runtime: golang"
                        echo "Test name: src/example/Calculator.golingvu.test.go"
                        echo "=== Environment variables ==="
                        env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                        echo "=== End environment variables ==="
                        # Debug: Show DOCKERMAN_HOST and DOCKERMAN_PORT
                        echo "DOCKERMAN_HOST='$DOCKERMAN_HOST'"
                        echo "DOCKERMAN_PORT='$DOCKERMAN_PORT'"
                        
                        # Build service health is managed by Docker Compose depends_on
                        echo "Build service golang-build health is managed by Docker Compose"
                        
                        # Get DockerMan port from environment variable
                        if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                          echo "ERROR: DOCKERMAN_PORT environment variable is not set or is 0"
                          echo "The DockerMan TCP server port must be passed via the DOCKERMAN_PORT environment variable."
                          echo "Make sure the TCP server is running and the port is passed to docker-compose."
                          exit 1
                        fi
                        echo "Using DockerMan port from environment variable: $DOCKERMAN_PORT"
                        
                        # Wait for the bundle file to exist (skip for golang since it uses source files directly)
                        if [ "golang" = "golang" ]; then
                          echo "Golang runtime detected: using source file directly, not waiting for bundle"
                          # Check if source file exists
                          if [ ! -f "src/example/Calculator.golingvu.test.go" ]; then
                            echo "ERROR: Source file not found at src/example/Calculator.golingvu.test.go"
                            exit 1
                          fi
                          echo "Source file found: src/example/Calculator.golingvu.test.go"
                        else
                          echo "Waiting for bundle file: testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                          MAX_BUNDLE_RETRIES=60
                          BUNDLE_RETRY_COUNT=0
                          while [ ! -f "testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                            echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                            BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                            sleep 2
                          done
                          
                          if [ ! -f "testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go" ]; then
                            echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                            echo "The build service may have failed to create the bundle."
                            exit 1
                          fi
                          echo "Build is ready. Proceeding with test...";
                        fi
                        
                        # Wait for DockerMan TCP server to be reachable
                        # Ensure DOCKERMAN_HOST has a value
                        if [ -z "$DOCKERMAN_HOST" ]; then
                          DOCKERMAN_HOST="host.docker.internal"
                          echo "DOCKERMAN_HOST was empty, using default: $DOCKERMAN_HOST"
                        fi
                        
                        # Try multiple host options if the default doesn't work
                        HOSTS_TO_TRY="$DOCKERMAN_HOST"
                        # Add gateway IP for Linux containers
                        GATEWAY_IP=$(ip route | grep default | awk '{print $3}' 2>/dev/null || echo "")
                        if [ -n "$GATEWAY_IP" ]; then
                          HOSTS_TO_TRY="$HOSTS_TO_TRY $GATEWAY_IP"
                        fi
                        # Add docker host IP
                        HOSTS_TO_TRY="$HOSTS_TO_TRY 172.17.0.1"
                        
                        echo "Waiting for DockerMan TCP server to be reachable on port $DOCKERMAN_PORT..."
                        echo "Will try hosts: $HOSTS_TO_TRY"
                        
                        MAX_RETRIES=30
                        RETRY_COUNT=0
                        SUCCESS=0
                        
                        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ $SUCCESS -eq 0 ]; do
                          for HOST in $HOSTS_TO_TRY; do
                            echo "Trying to connect to $HOST:$DOCKERMAN_PORT (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
                            # Try using netcat if available
                            if command -v nc >/dev/null 2>&1; then
                              if nc -z -w 1 "$HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                                echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via nc)"
                                DOCKERMAN_HOST="$HOST"
                                SUCCESS=1
                                break
                              fi
                            # Fallback to /dev/tcp
                            elif (echo > "/dev/tcp/$HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                              echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                              DOCKERMAN_HOST="$HOST"
                              SUCCESS=1
                              break
                            fi
                          done
                          
                          if [ $SUCCESS -eq 0 ]; then
                            echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                            RETRY_COUNT=$((RETRY_COUNT+1))
                            sleep 2
                          fi
                        done
                        
                        if [ $SUCCESS -eq 0 ]; then
                          echo "ERROR: DockerMan TCP server never became reachable on port $DOCKERMAN_PORT"
                          echo "Tried hosts: $HOSTS_TO_TRY"
                          echo "Make sure the TCP server is running on the host and accessible from containers."
                          echo "On Linux, you may need to expose the port differently or use host networking."
                          exit 1
                        fi
                        
                        echo "Using DockerMan host: $DOCKERMAN_HOST"
                        
                        # Run the test based on runtime
                        echo "=== Running test ==="
                        if [ "golang" = "node" ] || [ "golang" = "web" ]; then
                          echo "Executing: node testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                          node testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go
                        elif [ "golang" = "golang" ]; then
                          # For golang, we need to compile and run the test program
                          # testPath is something like "src/example/Calculator.golingvu.test.go"
                          echo "Running golang (golingvu) test: src/example/Calculator.golingvu.test.go"
                          
                          # First, check if we're in the right directory
                          echo "Current directory: $(pwd)"
                          echo "Checking if test file exists: src/example/Calculator.golingvu.test.go"
                          
                          if [ ! -f "src/example/Calculator.golingvu.test.go" ]; then
                            echo "ERROR: Test file not found at src/example/Calculator.golingvu.test.go"
                            exit 1
                          fi
                          
                          # Try to determine the best way to run this test
                          # Since it's a golingvu test, it might need special handling
                          # For now, try to run it with go run
                          echo "Attempting to run with: go run src/example/Calculator.golingvu.test.go"
                          go run "src/example/Calculator.golingvu.test.go"
                          RUN_EXIT_CODE=$?
                          
                          if [ $RUN_EXIT_CODE -eq 0 ]; then
                            echo "Go run succeeded"
                            exit 0
                          else
                            echo "Go run failed with exit code: $RUN_EXIT_CODE"
                            echo "Trying alternative approach..."
                            
                            # Try building and running as executable
                            TEST_DIR=$(dirname "src/example/Calculator.golingvu.test.go")
                            TEST_FILE=$(basename "src/example/Calculator.golingvu.test.go")
                            EXECUTABLE_NAME="/tmp/golang_test_$(echo src/example/Calculator.golingvu.test.go | tr '/' '_' | tr '.' '_')"
                            
                            echo "Building in directory: $TEST_DIR"
                            cd "$TEST_DIR" || { echo "ERROR: Failed to change to directory $TEST_DIR"; exit 1; }
                            
                            echo "Building: go build -o $EXECUTABLE_NAME $TEST_FILE"
                            go build -o $EXECUTABLE_NAME $TEST_FILE
                            
                            if [ $? -eq 0 ]; then
                              echo "Build successful, running: $EXECUTABLE_NAME"
                              $EXECUTABLE_NAME
                              BUILD_EXIT_CODE=$?
                              echo "Executable exited with code: $BUILD_EXIT_CODE"
                              exit $BUILD_EXIT_CODE
                            else
                              echo "ERROR: All attempts to run golang test failed"
                              echo "This might be a golingvu test that requires special handling"
                              exit 1
                            fi
                          fi
                        elif [ "golang" = "python" ]; then
                          echo "Executing: python src/example/Calculator.golingvu.test.go"
                          python src/example/Calculator.golingvu.test.go
                        else
                          echo "ERROR: Unknown runtime: golang"
                          exit 1
                        fi
                        
                        TEST_EXIT_CODE=$?
                        echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                        exit $TEST_EXIT_CODE
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    depends_on:
      golang-build:
        condition: service_healthy
    working_dir: /workspace
  python-src-example-calculator-pitono-test-py:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/python/src/example/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/python
      METAFILES_DIR: /testeranto/metafiles/python
      TEST_RESOURCES: '{"name":"python-src-example-calculator-pitono-test-py","fs":"./reports/allTests/python","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}'
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '53290'
      TESTERANTO_RUNTIME: python
    command:
      - sh
      - '-c'
      - |-
        echo "=== Starting test service for src/example/Calculator.pitono.test.py ==="
                        echo "Bundle path: testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                        echo "Runtime: python"
                        echo "Test name: src/example/Calculator.pitono.test.py"
                        echo "=== Environment variables ==="
                        env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                        echo "=== End environment variables ==="
                        # Debug: Show DOCKERMAN_HOST and DOCKERMAN_PORT
                        echo "DOCKERMAN_HOST='$DOCKERMAN_HOST'"
                        echo "DOCKERMAN_PORT='$DOCKERMAN_PORT'"
                        
                        # Build service health is managed by Docker Compose depends_on
                        echo "Build service python-build health is managed by Docker Compose"
                        
                        # Get DockerMan port from environment variable
                        if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                          echo "ERROR: DOCKERMAN_PORT environment variable is not set or is 0"
                          echo "The DockerMan TCP server port must be passed via the DOCKERMAN_PORT environment variable."
                          echo "Make sure the TCP server is running and the port is passed to docker-compose."
                          exit 1
                        fi
                        echo "Using DockerMan port from environment variable: $DOCKERMAN_PORT"
                        
                        # Wait for the bundle file to exist (skip for golang since it uses source files directly)
                        if [ "python" = "golang" ]; then
                          echo "Golang runtime detected: using source file directly, not waiting for bundle"
                          # Check if source file exists
                          if [ ! -f "src/example/Calculator.pitono.test.py" ]; then
                            echo "ERROR: Source file not found at src/example/Calculator.pitono.test.py"
                            exit 1
                          fi
                          echo "Source file found: src/example/Calculator.pitono.test.py"
                        else
                          echo "Waiting for bundle file: testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                          MAX_BUNDLE_RETRIES=60
                          BUNDLE_RETRY_COUNT=0
                          while [ ! -f "testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                            echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                            BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                            sleep 2
                          done
                          
                          if [ ! -f "testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py" ]; then
                            echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                            echo "The build service may have failed to create the bundle."
                            exit 1
                          fi
                          echo "Build is ready. Proceeding with test...";
                        fi
                        
                        # Wait for DockerMan TCP server to be reachable
                        # Ensure DOCKERMAN_HOST has a value
                        if [ -z "$DOCKERMAN_HOST" ]; then
                          DOCKERMAN_HOST="host.docker.internal"
                          echo "DOCKERMAN_HOST was empty, using default: $DOCKERMAN_HOST"
                        fi
                        
                        # Try multiple host options if the default doesn't work
                        HOSTS_TO_TRY="$DOCKERMAN_HOST"
                        # Add gateway IP for Linux containers
                        GATEWAY_IP=$(ip route | grep default | awk '{print $3}' 2>/dev/null || echo "")
                        if [ -n "$GATEWAY_IP" ]; then
                          HOSTS_TO_TRY="$HOSTS_TO_TRY $GATEWAY_IP"
                        fi
                        # Add docker host IP
                        HOSTS_TO_TRY="$HOSTS_TO_TRY 172.17.0.1"
                        
                        echo "Waiting for DockerMan TCP server to be reachable on port $DOCKERMAN_PORT..."
                        echo "Will try hosts: $HOSTS_TO_TRY"
                        
                        MAX_RETRIES=30
                        RETRY_COUNT=0
                        SUCCESS=0
                        
                        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ $SUCCESS -eq 0 ]; do
                          for HOST in $HOSTS_TO_TRY; do
                            echo "Trying to connect to $HOST:$DOCKERMAN_PORT (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
                            # Try using netcat if available
                            if command -v nc >/dev/null 2>&1; then
                              if nc -z -w 1 "$HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                                echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via nc)"
                                DOCKERMAN_HOST="$HOST"
                                SUCCESS=1
                                break
                              fi
                            # Fallback to /dev/tcp
                            elif (echo > "/dev/tcp/$HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                              echo "✅ DockerMan TCP server is reachable at $HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                              DOCKERMAN_HOST="$HOST"
                              SUCCESS=1
                              break
                            fi
                          done
                          
                          if [ $SUCCESS -eq 0 ]; then
                            echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                            RETRY_COUNT=$((RETRY_COUNT+1))
                            sleep 2
                          fi
                        done
                        
                        if [ $SUCCESS -eq 0 ]; then
                          echo "ERROR: DockerMan TCP server never became reachable on port $DOCKERMAN_PORT"
                          echo "Tried hosts: $HOSTS_TO_TRY"
                          echo "Make sure the TCP server is running on the host and accessible from containers."
                          echo "On Linux, you may need to expose the port differently or use host networking."
                          exit 1
                        fi
                        
                        echo "Using DockerMan host: $DOCKERMAN_HOST"
                        
                        # Run the test based on runtime
                        echo "=== Running test ==="
                        if [ "python" = "node" ] || [ "python" = "web" ]; then
                          echo "Executing: node testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                          node testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py
                        elif [ "python" = "golang" ]; then
                          # For golang, we need to compile and run the test program
                          # testPath is something like "src/example/Calculator.golingvu.test.go"
                          echo "Running golang (golingvu) test: src/example/Calculator.pitono.test.py"
                          
                          # First, check if we're in the right directory
                          echo "Current directory: $(pwd)"
                          echo "Checking if test file exists: src/example/Calculator.pitono.test.py"
                          
                          if [ ! -f "src/example/Calculator.pitono.test.py" ]; then
                            echo "ERROR: Test file not found at src/example/Calculator.pitono.test.py"
                            exit 1
                          fi
                          
                          # Try to determine the best way to run this test
                          # Since it's a golingvu test, it might need special handling
                          # For now, try to run it with go run
                          echo "Attempting to run with: go run src/example/Calculator.pitono.test.py"
                          go run "src/example/Calculator.pitono.test.py"
                          RUN_EXIT_CODE=$?
                          
                          if [ $RUN_EXIT_CODE -eq 0 ]; then
                            echo "Go run succeeded"
                            exit 0
                          else
                            echo "Go run failed with exit code: $RUN_EXIT_CODE"
                            echo "Trying alternative approach..."
                            
                            # Try building and running as executable
                            TEST_DIR=$(dirname "src/example/Calculator.pitono.test.py")
                            TEST_FILE=$(basename "src/example/Calculator.pitono.test.py")
                            EXECUTABLE_NAME="/tmp/golang_test_$(echo src/example/Calculator.pitono.test.py | tr '/' '_' | tr '.' '_')"
                            
                            echo "Building in directory: $TEST_DIR"
                            cd "$TEST_DIR" || { echo "ERROR: Failed to change to directory $TEST_DIR"; exit 1; }
                            
                            echo "Building: go build -o $EXECUTABLE_NAME $TEST_FILE"
                            go build -o $EXECUTABLE_NAME $TEST_FILE
                            
                            if [ $? -eq 0 ]; then
                              echo "Build successful, running: $EXECUTABLE_NAME"
                              $EXECUTABLE_NAME
                              BUILD_EXIT_CODE=$?
                              echo "Executable exited with code: $BUILD_EXIT_CODE"
                              exit $BUILD_EXIT_CODE
                            else
                              echo "ERROR: All attempts to run golang test failed"
                              echo "This might be a golingvu test that requires special handling"
                              exit 1
                            fi
                          fi
                        elif [ "python" = "python" ]; then
                          echo "Executing: python src/example/Calculator.pitono.test.py"
                          python src/example/Calculator.pitono.test.py
                        else
                          echo "ERROR: Unknown runtime: python"
                          exit 1
                        fi
                        
                        TEST_EXIT_CODE=$?
                        echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                        exit $TEST_EXIT_CODE
    volumes:
      - ../../src:/workspace/src:ro
      - ../../dist:/workspace/dist:ro
      - ../../testeranto:/workspace/testeranto
      - ../../package.json:/workspace/package.json:ro
      - ../../tsconfig.json:/workspace/tsconfig.json:ro
      - ../../allTests.ts:/workspace/allTests.ts:ro
      - node_modules:/workspace/node_modules
    depends_on:
      python-build:
        condition: service_healthy
    working_dir: /workspace
volumes:
  node_modules:
    driver: local
networks:
  default:
    name: allTests_network
