version: '3.8'
services:
  node-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/node/node.Dockerfile
      tags:
        - bundles-node-build:latest
      args:
        NODE_MJS_HASH: cab84cac12fc3913ce45e7e53425b8bb
    volumes:
      - ../../testeranto:/workspace/testeranto
    image: bundles-node-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/node
      METAFILES_DIR: /workspace/testeranto/metafiles/node
    command:
      - sh
      - '-c'
      - |
        echo 'Starting node build in watch mode...'; 
                echo 'Creating output directory...'; 
                mkdir -p /workspace/testeranto/bundles/allTests/node;
                mkdir -p /workspace/testeranto/metafiles/node;
                echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                # Create a dummy allTests.json to pass health check initially
                echo '{"status":"building"}' > /workspace/testeranto/metafiles/node/allTests.json;
                # Run in watch mode and keep the process alive
                npx tsx ./node.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                # Keep the container running even if the build command exits
                while true; do
                  sleep 3600
                done
    healthcheck:
      test:
        - CMD-SHELL
        - >-
          [ -f /workspace/testeranto/metafiles/node/allTests.json ] && echo
          "healthy" || exit 1
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  web-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/web/web.Dockerfile
      tags:
        - bundles-web-build:latest
      args: {}
    volumes:
      - ../../testeranto:/workspace/testeranto
    image: bundles-web-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/web
      METAFILES_DIR: /workspace/testeranto/metafiles/web
    command:
      - sh
      - '-c'
      - |
        echo 'Starting web build in watch mode...'; 
                echo 'Creating output directory...'; 
                mkdir -p /workspace/testeranto/bundles/allTests/web;
                mkdir -p /workspace/testeranto/metafiles/web;
                echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                # Create a dummy allTests.json to pass health check initially
                echo '{"status":"building"}' > /workspace/testeranto/metafiles/web/allTests.json;
                # Run in watch mode and keep the process alive
                npx tsx ./web.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                # Keep the container running even if the build command exits
                while true; do
                  sleep 3600
                done
    healthcheck:
      test:
        - CMD-SHELL
        - >-
          [ -f /workspace/testeranto/metafiles/web/allTests.json ] && echo
          "healthy" || exit 1
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  golang-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/golang/golang.Dockerfile
      tags:
        - bundles-golang-build:latest
      args: {}
    volumes:
      - ../../testeranto:/workspace/testeranto
    image: bundles-golang-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/golang
      METAFILES_DIR: /workspace/testeranto/metafiles/golang
    command:
      - sh
      - '-c'
      - |
        echo 'Starting golang build in watch mode...'; 
                echo 'Creating output directory...'; 
                mkdir -p /workspace/testeranto/bundles/allTests/golang;
                mkdir -p /workspace/testeranto/metafiles/golang;
                echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                # Create a dummy allTests.json to pass health check initially
                echo '{"status":"building"}' > /workspace/testeranto/metafiles/golang/allTests.json;
                # Run in watch mode and keep the process alive
                npx tsx ./golang.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                # Keep the container running even if the build command exits
                while true; do
                  sleep 3600
                done
    healthcheck:
      test:
        - CMD-SHELL
        - >-
          [ -f /workspace/testeranto/metafiles/golang/allTests.json ] && echo
          "healthy" || exit 1
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  python-build:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: testeranto/bundles/allTests/python/python.Dockerfile
      tags:
        - bundles-python-build:latest
      args: {}
    volumes:
      - ../../testeranto:/workspace/testeranto
    image: bundles-python-build:latest
    restart: unless-stopped
    environment:
      BUNDLES_DIR: /workspace/testeranto/bundles/allTests/python
      METAFILES_DIR: /workspace/testeranto/metafiles/python
    command:
      - sh
      - '-c'
      - |
        echo 'Starting python build in watch mode...'; 
                echo 'Creating output directory...'; 
                mkdir -p /workspace/testeranto/bundles/allTests/python;
                mkdir -p /workspace/testeranto/metafiles/python;
                echo 'BUNDLES_DIR env:' "$BUNDLES_DIR"; 
                # Create a dummy allTests.json to pass health check initially
                echo '{"status":"building"}' > /workspace/testeranto/metafiles/python/allTests.json;
                # Run in watch mode and keep the process alive
                npx tsx ./python.mjs allTests.ts dev || echo "Build process exited, but keeping container alive for health checks";
                # Keep the container running even if the build command exits
                while true; do
                  sleep 3600
                done
    healthcheck:
      test:
        - CMD-SHELL
        - >-
          [ -f /workspace/testeranto/metafiles/python/allTests.json ] && echo
          "healthy" || exit 1
      interval: 10s
      timeout: 30s
      retries: 10
      start_period: 60s
  node-src-example-calculator-test-ts:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: >-
        testeranto/bundles/allTests/node/src/example/Calculator.test.ts/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/node
      METAFILES_DIR: /testeranto/metafiles/node
      TEST_RESOURCES: >-
        {"name":"node-src-example-calculator-test-ts","fs":"/workspace/testeranto/reports/allTests/src/example/Calculator.test/node","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '0'
      TESTERANTO_RUNTIME: node
    command:
      - sh
      - '-c'
      - |-
        echo "=== Starting test service for src/example/Calculator.test.ts ==="
                echo "Bundle path: testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                echo "Runtime: node"
                echo "Test name: src/example/Calculator.test.ts"
                echo "=== Environment variables ==="
                env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                echo "=== End environment variables ==="
                
                # Build service health is managed by Docker Compose depends_on
                echo "Build service node-build health is managed by Docker Compose"
                
                # Wait for DockerMan port file to exist (written by main.ts)
                PORT_FILE="/workspace/testeranto/bundles/allTests-docker-man-port.txt"
                # Trim any whitespace from the path
                PORT_FILE=$(echo "$PORT_FILE" | tr -d '[:space:]')
                echo "Looking for DockerMan port file at: '$PORT_FILE'"
                echo "Current directory: $(pwd)"
                echo "Listing /workspace/testeranto/bundles/:"
                ls -la /workspace/testeranto/bundles/ 2>/dev/null || echo "Directory not found"
                
                # Check if PORT_FILE variable is empty
                if [ -z "$PORT_FILE" ]; then
                  echo "ERROR: PORT_FILE variable is empty"
                  echo "cleanTestsName value was: 'allTests'"
                  exit 1
                fi
                
                # Debug: show what's at that exact path
                echo "Checking file existence with ls -la:"
                ls -la "$PORT_FILE" 2>/dev/null || echo "ls could not find the file"
                
                # Check if file exists
                if [ ! -f "$PORT_FILE" ]; then
                  echo "ERROR: DockerMan port file not found at '$PORT_FILE'"
                  echo "The file should exist. Here's what's in /workspace/testeranto/bundles/:"
                  ls -la /workspace/testeranto/bundles/
                  echo "This file should be created by the main testeranto process."
                  echo "Make sure DockerMan's TCP server is running on the host."
                  exit 1
                fi
                
                DOCKERMAN_PORT=$(cat "$PORT_FILE")
                export DOCKERMAN_PORT
                echo "Using DockerMan port from file: $DOCKERMAN_PORT"
                
                if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                  echo "ERROR: Invalid DockerMan port: $DOCKERMAN_PORT"
                  exit 1
                fi
                
                # Wait for the bundle file to exist
                echo "Waiting for bundle file: testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                MAX_BUNDLE_RETRIES=60
                BUNDLE_RETRY_COUNT=0
                while [ ! -f "testeranto/bundles/allTests/node/src/example/Calculator.test.mjs" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                  echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                  BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ ! -f "testeranto/bundles/allTests/node/src/example/Calculator.test.mjs" ]; then
                  echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                  echo "The build service may have failed to create the bundle."
                  exit 1
                fi
                echo "Build is ready. Proceeding with test...";
                
                # Wait for DockerMan TCP server to be reachable
                echo "Waiting for DockerMan TCP server to be reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT..."
                MAX_RETRIES=30
                RETRY_COUNT=0
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  # Try using netcat if available
                  if command -v nc >/dev/null 2>&1; then
                    if nc -z -w 1 "$DOCKERMAN_HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                      echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via nc)"
                      break
                    fi
                  # Fallback to /dev/tcp
                  elif (echo > "/dev/tcp/$DOCKERMAN_HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                    echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                    break
                  fi
                  echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                  RETRY_COUNT=$((RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "ERROR: DockerMan TCP server never became reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT"
                  echo "Make sure the TCP server is running on the host and accessible from containers."
                  exit 1
                fi
                
                # Run the test based on runtime
                echo "=== Running test ==="
                if [ "node" = "node" ] || [ "node" = "web" ]; then
                  echo "Executing: node testeranto/bundles/allTests/node/src/example/Calculator.test.mjs"
                  node testeranto/bundles/allTests/node/src/example/Calculator.test.mjs
                elif [ "node" = "golang" ]; then
                  echo "Executing: go test src/example/Calculator.test.ts"
                  go test src/example/Calculator.test.ts
                elif [ "node" = "python" ]; then
                  echo "Executing: python src/example/Calculator.test.ts"
                  python src/example/Calculator.test.ts
                else
                  echo "ERROR: Unknown runtime: node"
                  exit 1
                fi
                
                TEST_EXIT_CODE=$?
                echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                exit $TEST_EXIT_CODE
                
    volumes:
      - ../../testeranto:/workspace/testeranto
      - ../../src:/workspace/src
    depends_on:
      node-build:
        condition: service_healthy
    working_dir: /workspace
  web-src-example-calculator-test-ts:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: >-
        testeranto/bundles/allTests/web/src/example/Calculator.test.ts/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/web
      METAFILES_DIR: /testeranto/metafiles/web
      TEST_RESOURCES: >-
        {"name":"web-src-example-calculator-test-ts","fs":"/workspace/testeranto/reports/allTests/src/example/Calculator.test/web","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '0'
      TESTERANTO_RUNTIME: web
    command:
      - sh
      - '-c'
      - |-
        echo "=== Starting test service for src/example/Calculator.test.ts ==="
                echo "Bundle path: testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                echo "Runtime: web"
                echo "Test name: src/example/Calculator.test.ts"
                echo "=== Environment variables ==="
                env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                echo "=== End environment variables ==="
                
                # Build service health is managed by Docker Compose depends_on
                echo "Build service web-build health is managed by Docker Compose"
                
                # Wait for DockerMan port file to exist (written by main.ts)
                PORT_FILE="/workspace/testeranto/bundles/allTests-docker-man-port.txt"
                # Trim any whitespace from the path
                PORT_FILE=$(echo "$PORT_FILE" | tr -d '[:space:]')
                echo "Looking for DockerMan port file at: '$PORT_FILE'"
                echo "Current directory: $(pwd)"
                echo "Listing /workspace/testeranto/bundles/:"
                ls -la /workspace/testeranto/bundles/ 2>/dev/null || echo "Directory not found"
                
                # Check if PORT_FILE variable is empty
                if [ -z "$PORT_FILE" ]; then
                  echo "ERROR: PORT_FILE variable is empty"
                  echo "cleanTestsName value was: 'allTests'"
                  exit 1
                fi
                
                # Debug: show what's at that exact path
                echo "Checking file existence with ls -la:"
                ls -la "$PORT_FILE" 2>/dev/null || echo "ls could not find the file"
                
                # Check if file exists
                if [ ! -f "$PORT_FILE" ]; then
                  echo "ERROR: DockerMan port file not found at '$PORT_FILE'"
                  echo "The file should exist. Here's what's in /workspace/testeranto/bundles/:"
                  ls -la /workspace/testeranto/bundles/
                  echo "This file should be created by the main testeranto process."
                  echo "Make sure DockerMan's TCP server is running on the host."
                  exit 1
                fi
                
                DOCKERMAN_PORT=$(cat "$PORT_FILE")
                export DOCKERMAN_PORT
                echo "Using DockerMan port from file: $DOCKERMAN_PORT"
                
                if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                  echo "ERROR: Invalid DockerMan port: $DOCKERMAN_PORT"
                  exit 1
                fi
                
                # Wait for the bundle file to exist
                echo "Waiting for bundle file: testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                MAX_BUNDLE_RETRIES=60
                BUNDLE_RETRY_COUNT=0
                while [ ! -f "testeranto/bundles/allTests/web/src/example/Calculator.test.mjs" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                  echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                  BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ ! -f "testeranto/bundles/allTests/web/src/example/Calculator.test.mjs" ]; then
                  echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                  echo "The build service may have failed to create the bundle."
                  exit 1
                fi
                echo "Build is ready. Proceeding with test...";
                
                # Wait for DockerMan TCP server to be reachable
                echo "Waiting for DockerMan TCP server to be reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT..."
                MAX_RETRIES=30
                RETRY_COUNT=0
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  # Try using netcat if available
                  if command -v nc >/dev/null 2>&1; then
                    if nc -z -w 1 "$DOCKERMAN_HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                      echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via nc)"
                      break
                    fi
                  # Fallback to /dev/tcp
                  elif (echo > "/dev/tcp/$DOCKERMAN_HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                    echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                    break
                  fi
                  echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                  RETRY_COUNT=$((RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "ERROR: DockerMan TCP server never became reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT"
                  echo "Make sure the TCP server is running on the host and accessible from containers."
                  exit 1
                fi
                
                # Run the test based on runtime
                echo "=== Running test ==="
                if [ "web" = "node" ] || [ "web" = "web" ]; then
                  echo "Executing: node testeranto/bundles/allTests/web/src/example/Calculator.test.mjs"
                  node testeranto/bundles/allTests/web/src/example/Calculator.test.mjs
                elif [ "web" = "golang" ]; then
                  echo "Executing: go test src/example/Calculator.test.ts"
                  go test src/example/Calculator.test.ts
                elif [ "web" = "python" ]; then
                  echo "Executing: python src/example/Calculator.test.ts"
                  python src/example/Calculator.test.ts
                else
                  echo "ERROR: Unknown runtime: web"
                  exit 1
                fi
                
                TEST_EXIT_CODE=$?
                echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                exit $TEST_EXIT_CODE
                
    volumes:
      - ../../testeranto:/workspace/testeranto
      - ../../src:/workspace/src
    depends_on:
      web-build:
        condition: service_healthy
    working_dir: /workspace
  golang-src-example-calculator-golingvu-test-go:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: >-
        testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/golang
      METAFILES_DIR: /testeranto/metafiles/golang
      TEST_RESOURCES: >-
        {"name":"golang-src-example-calculator-golingvu-test-go","fs":"/workspace/testeranto/reports/allTests/src/example/Calculator.golingvu.test/golang","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '0'
      TESTERANTO_RUNTIME: golang
    command:
      - sh
      - '-c'
      - >-
        echo "=== Starting test service for
        src/example/Calculator.golingvu.test.go ==="
                echo "Bundle path: testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                echo "Runtime: golang"
                echo "Test name: src/example/Calculator.golingvu.test.go"
                echo "=== Environment variables ==="
                env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                echo "=== End environment variables ==="
                
                # Build service health is managed by Docker Compose depends_on
                echo "Build service golang-build health is managed by Docker Compose"
                
                # Wait for DockerMan port file to exist (written by main.ts)
                PORT_FILE="/workspace/testeranto/bundles/allTests-docker-man-port.txt"
                # Trim any whitespace from the path
                PORT_FILE=$(echo "$PORT_FILE" | tr -d '[:space:]')
                echo "Looking for DockerMan port file at: '$PORT_FILE'"
                echo "Current directory: $(pwd)"
                echo "Listing /workspace/testeranto/bundles/:"
                ls -la /workspace/testeranto/bundles/ 2>/dev/null || echo "Directory not found"
                
                # Check if PORT_FILE variable is empty
                if [ -z "$PORT_FILE" ]; then
                  echo "ERROR: PORT_FILE variable is empty"
                  echo "cleanTestsName value was: 'allTests'"
                  exit 1
                fi
                
                # Debug: show what's at that exact path
                echo "Checking file existence with ls -la:"
                ls -la "$PORT_FILE" 2>/dev/null || echo "ls could not find the file"
                
                # Check if file exists
                if [ ! -f "$PORT_FILE" ]; then
                  echo "ERROR: DockerMan port file not found at '$PORT_FILE'"
                  echo "The file should exist. Here's what's in /workspace/testeranto/bundles/:"
                  ls -la /workspace/testeranto/bundles/
                  echo "This file should be created by the main testeranto process."
                  echo "Make sure DockerMan's TCP server is running on the host."
                  exit 1
                fi
                
                DOCKERMAN_PORT=$(cat "$PORT_FILE")
                export DOCKERMAN_PORT
                echo "Using DockerMan port from file: $DOCKERMAN_PORT"
                
                if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                  echo "ERROR: Invalid DockerMan port: $DOCKERMAN_PORT"
                  exit 1
                fi
                
                # Wait for the bundle file to exist
                echo "Waiting for bundle file: testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                MAX_BUNDLE_RETRIES=60
                BUNDLE_RETRY_COUNT=0
                while [ ! -f "testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                  echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                  BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ ! -f "testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go" ]; then
                  echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                  echo "The build service may have failed to create the bundle."
                  exit 1
                fi
                echo "Build is ready. Proceeding with test...";
                
                # Wait for DockerMan TCP server to be reachable
                echo "Waiting for DockerMan TCP server to be reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT..."
                MAX_RETRIES=30
                RETRY_COUNT=0
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  # Try using netcat if available
                  if command -v nc >/dev/null 2>&1; then
                    if nc -z -w 1 "$DOCKERMAN_HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                      echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via nc)"
                      break
                    fi
                  # Fallback to /dev/tcp
                  elif (echo > "/dev/tcp/$DOCKERMAN_HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                    echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                    break
                  fi
                  echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                  RETRY_COUNT=$((RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "ERROR: DockerMan TCP server never became reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT"
                  echo "Make sure the TCP server is running on the host and accessible from containers."
                  exit 1
                fi
                
                # Run the test based on runtime
                echo "=== Running test ==="
                if [ "golang" = "node" ] || [ "golang" = "web" ]; then
                  echo "Executing: node testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go"
                  node testeranto/bundles/allTests/golang/src/example/Calculator.golingvu.test.go
                elif [ "golang" = "golang" ]; then
                  echo "Executing: go test src/example/Calculator.golingvu.test.go"
                  go test src/example/Calculator.golingvu.test.go
                elif [ "golang" = "python" ]; then
                  echo "Executing: python src/example/Calculator.golingvu.test.go"
                  python src/example/Calculator.golingvu.test.go
                else
                  echo "ERROR: Unknown runtime: golang"
                  exit 1
                fi
                
                TEST_EXIT_CODE=$?
                echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                exit $TEST_EXIT_CODE
                
    volumes:
      - ../../testeranto:/workspace/testeranto
      - ../../src:/workspace/src
    depends_on:
      golang-build:
        condition: service_healthy
    working_dir: /workspace
  python-src-example-calculator-pitono-test-py:
    build:
      context: /Users/adam/Code/testeranto
      dockerfile: >-
        testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py/Dockerfile
    environment:
      BUNDLES_DIR: /testeranto/bundles/allTests/python
      METAFILES_DIR: /testeranto/metafiles/python
      TEST_RESOURCES: >-
        {"name":"python-src-example-calculator-pitono-test-py","fs":"/workspace/testeranto/reports/allTests/src/example/Calculator.pitono.test/python","ports":[],"browserWSEndpoint":"","timeout":30000,"retries":3,"environment":{}}
      DOCKERMAN_HOST: host.docker.internal
      DOCKERMAN_PORT: '0'
      TESTERANTO_RUNTIME: python
    command:
      - sh
      - '-c'
      - >-
        echo "=== Starting test service for
        src/example/Calculator.pitono.test.py ==="
                echo "Bundle path: testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                echo "Runtime: python"
                echo "Test name: src/example/Calculator.pitono.test.py"
                echo "=== Environment variables ==="
                env | grep -E "TEST|DOCKERMAN|BUNDLES|METAFILES" || true
                echo "=== End environment variables ==="
                
                # Build service health is managed by Docker Compose depends_on
                echo "Build service python-build health is managed by Docker Compose"
                
                # Wait for DockerMan port file to exist (written by main.ts)
                PORT_FILE="/workspace/testeranto/bundles/allTests-docker-man-port.txt"
                # Trim any whitespace from the path
                PORT_FILE=$(echo "$PORT_FILE" | tr -d '[:space:]')
                echo "Looking for DockerMan port file at: '$PORT_FILE'"
                echo "Current directory: $(pwd)"
                echo "Listing /workspace/testeranto/bundles/:"
                ls -la /workspace/testeranto/bundles/ 2>/dev/null || echo "Directory not found"
                
                # Check if PORT_FILE variable is empty
                if [ -z "$PORT_FILE" ]; then
                  echo "ERROR: PORT_FILE variable is empty"
                  echo "cleanTestsName value was: 'allTests'"
                  exit 1
                fi
                
                # Debug: show what's at that exact path
                echo "Checking file existence with ls -la:"
                ls -la "$PORT_FILE" 2>/dev/null || echo "ls could not find the file"
                
                # Check if file exists
                if [ ! -f "$PORT_FILE" ]; then
                  echo "ERROR: DockerMan port file not found at '$PORT_FILE'"
                  echo "The file should exist. Here's what's in /workspace/testeranto/bundles/:"
                  ls -la /workspace/testeranto/bundles/
                  echo "This file should be created by the main testeranto process."
                  echo "Make sure DockerMan's TCP server is running on the host."
                  exit 1
                fi
                
                DOCKERMAN_PORT=$(cat "$PORT_FILE")
                export DOCKERMAN_PORT
                echo "Using DockerMan port from file: $DOCKERMAN_PORT"
                
                if [ -z "$DOCKERMAN_PORT" ] || [ "$DOCKERMAN_PORT" = "0" ]; then
                  echo "ERROR: Invalid DockerMan port: $DOCKERMAN_PORT"
                  exit 1
                fi
                
                # Wait for the bundle file to exist
                echo "Waiting for bundle file: testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                MAX_BUNDLE_RETRIES=60
                BUNDLE_RETRY_COUNT=0
                while [ ! -f "testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py" ] && [ $BUNDLE_RETRY_COUNT -lt $MAX_BUNDLE_RETRIES ]; do
                  echo "Bundle not ready yet (attempt $((BUNDLE_RETRY_COUNT+1))/$MAX_BUNDLE_RETRIES)"
                  BUNDLE_RETRY_COUNT=$((BUNDLE_RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ ! -f "testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py" ]; then
                  echo "ERROR: Bundle file never appeared at testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                  echo "The build service may have failed to create the bundle."
                  exit 1
                fi
                echo "Build is ready. Proceeding with test...";
                
                # Wait for DockerMan TCP server to be reachable
                echo "Waiting for DockerMan TCP server to be reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT..."
                MAX_RETRIES=30
                RETRY_COUNT=0
                while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                  # Try using netcat if available
                  if command -v nc >/dev/null 2>&1; then
                    if nc -z -w 1 "$DOCKERMAN_HOST" "$DOCKERMAN_PORT" 2>/dev/null; then
                      echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via nc)"
                      break
                    fi
                  # Fallback to /dev/tcp
                  elif (echo > "/dev/tcp/$DOCKERMAN_HOST/$DOCKERMAN_PORT") &>/dev/null 2>&1; then
                    echo "DockerMan TCP server is reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT (via /dev/tcp)"
                    break
                  fi
                  echo "DockerMan TCP server not reachable yet (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
                  RETRY_COUNT=$((RETRY_COUNT+1))
                  sleep 2
                done
                
                if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                  echo "ERROR: DockerMan TCP server never became reachable at $DOCKERMAN_HOST:$DOCKERMAN_PORT"
                  echo "Make sure the TCP server is running on the host and accessible from containers."
                  exit 1
                fi
                
                # Run the test based on runtime
                echo "=== Running test ==="
                if [ "python" = "node" ] || [ "python" = "web" ]; then
                  echo "Executing: node testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py"
                  node testeranto/bundles/allTests/python/src/example/Calculator.pitono.test.py
                elif [ "python" = "golang" ]; then
                  echo "Executing: go test src/example/Calculator.pitono.test.py"
                  go test src/example/Calculator.pitono.test.py
                elif [ "python" = "python" ]; then
                  echo "Executing: python src/example/Calculator.pitono.test.py"
                  python src/example/Calculator.pitono.test.py
                else
                  echo "ERROR: Unknown runtime: python"
                  exit 1
                fi
                
                TEST_EXIT_CODE=$?
                echo "=== Test completed with exit code: $TEST_EXIT_CODE ==="
                exit $TEST_EXIT_CODE
                
    volumes:
      - ../../testeranto:/workspace/testeranto
      - ../../src:/workspace/src
    depends_on:
      python-build:
        condition: service_healthy
    working_dir: /workspace
networks:
  default:
    name: allTests_network
