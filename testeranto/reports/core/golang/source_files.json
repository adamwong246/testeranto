{
  "src": {
    "golingvu": {
      "base_given.go": {
        "__isFile": true,
        "content": "package golingvu\n\n// BaseGiven represents a base Given condition\ntype BaseGiven struct {\n\tName           string\n\tFeatures       []string\n\tWhens          []*BaseWhen\n\tThens          []*BaseThen\n\tError          error\n\tFail           interface{}\n\tStore          interface{}\n\tRecommendedFsPath string\n\tGivenCB        interface{}\n\tInitialValues  interface{}\n\tKey            string\n\tFailed         bool\n\tArtifacts      []string\n\tGivenThatFunc  func(subject, testResource, artifactory, initializer, initialValues, pm interface{}) (interface{}, error)\n\tAfterEachFunc  func(store interface{}, key string, artifactory, pm interface{}) (interface{}, error)\n\tUberCatcherFunc func(func())\n}\n\n// AddArtifact adds an artifact path\nfunc (bg *BaseGiven) AddArtifact(path string) {\n\t// Normalize path separators\n\t// For simplicity, we'll assume paths are already normalized\n\tbg.Artifacts = append(bg.Artifacts, path)\n}\n\n// NewBaseGiven creates a new BaseGiven instance\nfunc NewBaseGiven(name string, features []string, whens []*BaseWhen, thens []*BaseThen, givenCB, initialValues interface{}) *BaseGiven {\n\treturn &BaseGiven{\n\t\tName:          name,\n\t\tFeatures:      features,\n\t\tWhens:         whens,\n\t\tThens:         thens,\n\t\tGivenCB:       givenCB,\n\t\tInitialValues: initialValues,\n\t\tArtifacts:     make([]string, 0),\n\t}\n}\n\n// BeforeAll is called before all tests\nfunc (bg *BaseGiven) BeforeAll(store interface{}) interface{} {\n\treturn store\n}\n\n// ToObj converts the instance to a map for serialization\nfunc (bg *BaseGiven) ToObj() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"key\":      bg.Key,\n\t\t\"name\":     bg.Name,\n\t\t\"whens\":    bg.Whens,\n\t\t\"thens\":    bg.Thens,\n\t\t\"error\":    bg.Error,\n\t\t\"failed\":   bg.Failed,\n\t\t\"features\": bg.Features,\n\t\t\"artifacts\": bg.Artifacts,\n\t}\n}\n\n// GivenThat is an abstract method to be implemented\nfunc (bg *BaseGiven) GivenThat(subject, testResourceConfiguration, artifactory, givenCB, initialValues, pm interface{}) (interface{}, error) {\n\t// To be implemented by concrete types\n\treturn nil, nil\n}\n\n// AfterEach is called after each test\nfunc (bg *BaseGiven) AfterEach(store interface{}, key string, artifactory, pm interface{}) (interface{}, error) {\n\treturn store, nil\n}\n\n// UberCatcher handles errors\nfunc (bg *BaseGiven) UberCatcher(e error) {\n\tbg.Error = e\n}\n"
      },
      "base_suite.go": {
        "__isFile": true,
        "content": "package golingvu\n\n// BaseSuite represents a test suite\ntype BaseSuite struct {\n\tName           string\n\tGivens         map[string]*BaseGiven\n\tAfterAllFunc   func(store interface{}, artifactory func(string, interface{}), pm interface{}) interface{}\n\tAssertThatFunc func(t interface{}) bool\n\tSetupFunc      func(s interface{}, artifactory func(string, interface{}), tr ITTestResourceConfiguration, pm interface{}) interface{}\n}\n\n// Run executes the test suite\nfunc (bs *BaseSuite) Run(input interface{}, testResourceConfiguration ITTestResourceConfiguration, artifactory func(string, interface{}), tLog func(...string), pm interface{}) (*BaseSuite, error) {\n\t// Implementation would go here\n\treturn bs, nil\n}\n\n// ToObj converts the suite to a serializable object\nfunc (bs *BaseSuite) ToObj() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"name\": bs.Name,\n\t}\n}\n\n// Features returns the features covered by this suite\nfunc (bs *BaseSuite) Features() []string {\n\tfeatures := make([]string, 0)\n\tseen := make(map[string]bool)\n\t\n\tfor _, given := range bs.Givens {\n\t\tfor _, feature := range given.Features {\n\t\t\tif !seen[feature] {\n\t\t\t\tfeatures = append(features, feature)\n\t\t\t\tseen[feature] = true\n\t\t\t}\n\t\t}\n\t}\n\treturn features\n}\n"
      },
      "base_suite_test.go": {
        "__isFile": true,
        "content": "package golingvu\n\nimport (\n\t\"testing\"\n)\n\n// Test types to match the TypeScript implementation\ntype TestStore struct {\n\tName          string\n\tIndex         int\n\tTestStore     bool\n\tTestSelection bool\n\tError         error\n}\n\ntype TestSelection struct {\n\tTestSelection bool\n\tError         bool\n}\n\n// TestBaseSuiteInitialization tests that BaseSuite initializes correctly\nfunc TestBaseSuiteInitialization(t *testing.T) {\n\tsuite := &BaseSuite{\n\t\tName: \"testSuite\",\n\t\tGivens: map[string]*BaseGiven{\n\t\t\t\"testGiven\": {\n\t\t\t\tName:     \"testGiven\",\n\t\t\t\tFeatures: []string{\"testFeature\"},\n\t\t\t\tWhens:    []*BaseWhen{},\n\t\t\t\tThens:    []*BaseThen{},\n\t\t\t},\n\t\t},\n\t}\n\n\tif suite.Name != \"testSuite\" {\n\t\tt.Errorf(\"Expected suite name 'testSuite', got '%s'\", suite.Name)\n\t}\n\n\tif len(suite.Givens) != 1 {\n\t\tt.Errorf(\"Expected 1 given, got %d\", len(suite.Givens))\n\t}\n\n\tgiven := suite.Givens[\"testGiven\"]\n\tif given.Name != \"testGiven\" {\n\t\tt.Errorf(\"Expected given name 'testGiven', got '%s'\", given.Name)\n\t}\n\n\tif len(given.Features) != 1 || given.Features[0] != \"testFeature\" {\n\t\tt.Errorf(\"Expected feature 'testFeature', got %v\", given.Features)\n\t}\n}\n\n// TestBaseSuiteToObj tests the ToObj method\nfunc TestBaseSuiteToObj(t *testing.T) {\n\tsuite := &BaseSuite{\n\t\tName: \"testSuite\",\n\t\tGivens: map[string]*BaseGiven{\n\t\t\t\"testGiven\": {\n\t\t\t\tName:     \"testGiven\",\n\t\t\t\tFeatures: []string{\"testFeature\"},\n\t\t\t\tWhens:    []*BaseWhen{},\n\t\t\t\tThens:    []*BaseThen{},\n\t\t\t},\n\t\t},\n\t}\n\n\tobj := suite.ToObj()\n\tif obj[\"name\"] != \"testSuite\" {\n\t\tt.Errorf(\"Expected obj name 'testSuite', got '%v'\", obj[\"name\"])\n\t}\n}\n\n// TestBaseSuiteFeatures tests the Features method\nfunc TestBaseSuiteFeatures(t *testing.T) {\n\tsuite := &BaseSuite{\n\t\tName: \"testSuite\",\n\t\tGivens: map[string]*BaseGiven{\n\t\t\t\"testGiven\": {\n\t\t\t\tName:     \"testGiven\",\n\t\t\t\tFeatures: []string{\"testFeature\"},\n\t\t\t\tWhens:    []*BaseWhen{},\n\t\t\t\tThens:    []*BaseThen{},\n\t\t\t},\n\t\t},\n\t}\n\n\tfeatures := suite.Features()\n\tif len(features) != 1 || features[0] != \"testFeature\" {\n\t\tt.Errorf(\"Expected ['testFeature'], got %v\", features)\n\t}\n}\n\n// TestBaseSuiteRun tests the Run method\nfunc TestBaseSuiteRun(t *testing.T) {\n\tsuite := &BaseSuite{\n\t\tName: \"testSuite\",\n\t\tGivens: map[string]*BaseGiven{\n\t\t\t\"testGiven\": {\n\t\t\t\tName:     \"testGiven\",\n\t\t\t\tFeatures: []string{\"testFeature\"},\n\t\t\t\tWhens:    []*BaseWhen{},\n\t\t\t\tThens:    []*BaseThen{},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Mock test resource configuration\n\ttestConfig := ITTestResourceConfiguration{\n\t\tName:        \"test\",\n\t\tFs:          \"/tmp\",\n\t\tPorts:       []int{3000},\n\t\tEnvironment: map[string]string{},\n\t\tTimeout:     5000,\n\t\tRetries:     3,\n\t}\n\n\t// Mock artifactory function\n\tartifactory := func(path string, value interface{}) {}\n\n\t// Mock tLog function\n\ttLog := func(args ...string) {}\n\n\t// Mock PM\n\tpm := struct{}{}\n\n\tresult, err := suite.Run(nil, testConfig, artifactory, tLog, pm)\n\tif err != nil {\n\t\tt.Errorf(\"Run failed: %v\", err)\n\t}\n\n\tif result == nil {\n\t\tt.Error(\"Expected non-nil result from Run\")\n\t}\n}\n\n// TestBaseGivenAddArtifact tests adding artifacts\nfunc TestBaseGivenAddArtifact(t *testing.T) {\n\tgiven := &BaseGiven{\n\t\tName:     \"testGiven\",\n\t\tArtifacts: []string{},\n\t}\n\n\tgiven.AddArtifact(\"test/path\")\n\tgiven.AddArtifact(\"another/path\")\n\n\tif len(given.Artifacts) != 2 {\n\t\tt.Errorf(\"Expected 2 artifacts, got %d\", len(given.Artifacts))\n\t}\n\n\tif given.Artifacts[0] != \"test/path\" || given.Artifacts[1] != \"another/path\" {\n\t\tt.Errorf(\"Unexpected artifacts: %v\", given.Artifacts)\n\t}\n}\n\n// TestBaseGivenToObj tests the ToObj method\nfunc TestBaseGivenToObj(t *testing.T) {\n\tgiven := &BaseGiven{\n\t\tName:     \"testGiven\",\n\t\tFeatures: []string{\"testFeature\"},\n\t\tWhens:    []*BaseWhen{},\n\t\tThens:    []*BaseThen{},\n\t\tKey:      \"testKey\",\n\t\tArtifacts: []string{\"test/artifact\"},\n\t}\n\n\tobj := given.ToObj()\n\tif obj[\"name\"] != \"testGiven\" {\n\t\tt.Errorf(\"Expected name 'testGiven', got '%v'\", obj[\"name\"])\n\t}\n\tif obj[\"key\"] != \"testKey\" {\n\t\tt.Errorf(\"Expected key 'testKey', got '%v'\", obj[\"key\"])\n\t}\n}\n\n// TestBaseWhenToObj tests the ToObj method for BaseWhen\nfunc TestBaseWhenToObj(t *testing.T) {\n\twhen := &BaseWhen{\n\t\tName: \"testWhen\",\n\t}\n\n\tobj := when.ToObj()\n\tif obj[\"name\"] != \"testWhen\" {\n\t\tt.Errorf(\"Expected name 'testWhen', got '%v'\", obj[\"name\"])\n\t}\n}\n\n// TestBaseThenToObj tests the ToObj method for BaseThen\nfunc TestBaseThenToObj(t *testing.T) {\n\tthen := &BaseThen{\n\t\tName: \"testThen\",\n\t}\n\n\tobj := then.ToObj()\n\tif obj[\"name\"] != \"testThen\" {\n\t\tt.Errorf(\"Expected name 'testThen', got '%v'\", obj[\"name\"])\n\t}\n}\n"
      },
      "base_then.go": {
        "__isFile": true,
        "content": "package golingvu\n\n// BaseThen represents a Then condition\ntype BaseThen struct {\n\tName        string\n\tThenCB      interface{}\n\tButThenFunc func(store, thenCB, testResource, pm interface{}) (interface{}, error)\n}\n\n// Test executes the Then condition\nfunc (bt *BaseThen) Test(store interface{}, testResourceConfiguration ITTestResourceConfiguration, tLog func(...string), pm interface{}, path string) (interface{}, error) {\n\t// Implementation would go here\n\treturn nil, nil\n}\n\n// ToObj converts the Then condition to a serializable object\nfunc (bt *BaseThen) ToObj() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"name\": bt.Name,\n\t}\n}\n"
      },
      "base_when.go": {
        "__isFile": true,
        "content": "package golingvu\n\n// BaseWhen represents a When condition\ntype BaseWhen struct {\n\tName        string\n\tWhenCB      interface{}\n\tAndWhenFunc func(store, whenCB, testResource, pm interface{}) (interface{}, error)\n}\n\n// Test executes the When condition\nfunc (bw *BaseWhen) Test(store interface{}, testResourceConfiguration ITTestResourceConfiguration, tLog func(...string), pm interface{}, path string) (interface{}, error) {\n\t// Implementation would go here\n\treturn nil, nil\n}\n\n// ToObj converts the When condition to a serializable object\nfunc (bw *BaseWhen) ToObj() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"name\": bw.Name,\n\t}\n}\n"
      },
      "golingvu.go": {
        "__isFile": true,
        "content": "package golingvu\n\n\n// Golingvu is the main test runner class (Go implementation of Tiposkripto)\ntype Golingvu struct {\n\tTestResourceRequirement ITTestResourceRequest\n\tArtifacts               []interface{}\n\tTestJobs                []ITestJob\n\tTestSpecification       ITestSpecification\n\tSuitesOverrides         map[string]interface{}\n\tGivenOverrides          map[string]interface{}\n\tWhenOverrides           map[string]interface{}\n\tThenOverrides           map[string]interface{}\n\tPuppetMaster            interface{}\n\tSpecs                   interface{}\n\tassertThis              func(t interface{}) interface{}\n}\n\n// NewGolingvu creates a new Golingvu instance\nfunc NewGolingvu(\n\tinput interface{},\n\ttestSpecification ITestSpecification,\n\ttestImplementation ITestImplementation,\n\ttestResourceRequirement ITTestResourceRequest,\n\ttestAdapter ITestAdapter,\n\tuberCatcher func(func()),\n) *Golingvu {\n\tgv := &Golingvu{\n\t\tTestResourceRequirement: testResourceRequirement,\n\t\tArtifacts:               make([]interface{}, 0),\n\t\tSuitesOverrides:         make(map[string]interface{}),\n\t\tGivenOverrides:          make(map[string]interface{}),\n\t\tWhenOverrides:           make(map[string]interface{}),\n\t\tThenOverrides:           make(map[string]interface{}),\n\t\tassertThis: func(t interface{}) interface{} {\n\t\t\treturn testAdapter.AssertThis(t)\n\t\t},\n\t}\n\n\t// Create classy implementations\n\tclassySuites := make(map[string]interface{})\n\tfor key := range testImplementation.Suites {\n\t\tclassySuites[key] = func(somestring string, givens map[string]*BaseGiven) *BaseSuite {\n\t\t\treturn &BaseSuite{\n\t\t\t\tName: somestring,\n\t\t\t\tGivens: givens,\n\t\t\t\tAfterAllFunc: func(store interface{}, artifactory func(string, interface{}), pm interface{}) interface{} {\n\t\t\t\t\treturn testAdapter.AfterAll(store, pm)\n\t\t\t\t},\n\t\t\t\tAssertThatFunc: func(t interface{}) bool {\n\t\t\t\t\treturn testAdapter.AssertThis(t)\n\t\t\t\t},\n\t\t\t\tSetupFunc: func(s interface{}, artifactory func(string, interface{}), tr ITTestResourceConfiguration, pm interface{}) interface{} {\n\t\t\t\t\tresult := testAdapter.BeforeAll(s, tr, pm)\n\t\t\t\t\tif result == nil {\n\t\t\t\t\t\treturn s\n\t\t\t\t\t}\n\t\t\t\t\treturn result\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tclassyGivens := make(map[string]interface{})\n\tfor key, g := range testImplementation.Givens {\n\t\tclassyGivens[key] = func(name string, features []string, whens []*BaseWhen, thens []*BaseThen, gcb interface{}, initialValues interface{}) *BaseGiven {\n\t\t\treturn &BaseGiven{\n\t\t\t\tName:          name,\n\t\t\t\tFeatures:      features,\n\t\t\t\tWhens:         whens,\n\t\t\t\tThens:         thens,\n\t\t\t\tGivenCB:       g,\n\t\t\t\tInitialValues: initialValues,\n\t\t\t\tArtifacts:     make([]string, 0),\n\t\t\t\tGivenThatFunc: func(subject, testResource, artifactory, initializer, initialValues, pm interface{}) (interface{}, error) {\n\t\t\t\t\t// Type assertion for testResource\n\t\t\t\t\ttr, ok := testResource.(ITTestResourceConfiguration)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, nil\n\t\t\t\t\t}\n\t\t\t\t\treturn testAdapter.BeforeEach(subject, initializer, tr, initialValues, pm), nil\n\t\t\t\t},\n\t\t\t\tAfterEachFunc: func(store interface{}, key string, artifactory, pm interface{}) (interface{}, error) {\n\t\t\t\t\treturn testAdapter.AfterEach(store, key, pm), nil\n\t\t\t\t},\n\t\t\t\tUberCatcherFunc: uberCatcher,\n\t\t\t}\n\t\t}\n\t}\n\n\tclassyWhens := make(map[string]interface{})\n\tfor key, whEn := range testImplementation.Whens {\n\t\tclassyWhens[key] = func(payload ...interface{}) *BaseWhen {\n\t\t\treturn &BaseWhen{\n\t\t\t\tName:   key,\n\t\t\t\tWhenCB: whEn,\n\t\t\t\tAndWhenFunc: func(store, whenCB, testResource, pm interface{}) (interface{}, error) {\n\t\t\t\t\treturn testAdapter.AndWhen(store, whenCB, testResource, pm), nil\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tclassyThens := make(map[string]interface{})\n\tfor key, thEn := range testImplementation.Thens {\n\t\tclassyThens[key] = func(args ...interface{}) *BaseThen {\n\t\t\treturn &BaseThen{\n\t\t\t\tName:   key,\n\t\t\t\tThenCB: thEn,\n\t\t\t\tButThenFunc: func(store, thenCB, testResource, pm interface{}) (interface{}, error) {\n\t\t\t\t\treturn testAdapter.ButThen(store, thenCB, testResource, pm), nil\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set up the overrides\n\tgv.SuitesOverrides = classySuites\n\tgv.GivenOverrides = classyGivens\n\tgv.WhenOverrides = classyWhens\n\tgv.ThenOverrides = classyThens\n\tgv.TestResourceRequirement = testResourceRequirement\n\tgv.TestSpecification = testSpecification\n\n\t// Generate specs\n\tgv.Specs = testSpecification(\n\t\tgv.Suites(),\n\t\tgv.Given(),\n\t\tgv.When(),\n\t\tgv.Then(),\n\t)\n\n\t// Create test jobs (simplified)\n\t// Note: This part needs to be adapted from TypeScript more carefully\n\tgv.TestJobs = []ITestJob{}\n\n\treturn gv\n}\n\n// ReceiveTestResourceConfig receives test resource configuration\nfunc (gv *Golingvu) ReceiveTestResourceConfig(partialTestResource string) (IFinalResults, error) {\n\t// Implement this method based on the TypeScript version\n\treturn IFinalResults{}, nil\n}\n\n// Suites returns the suites overrides\nfunc (gv *Golingvu) Suites() map[string]interface{} {\n\treturn gv.SuitesOverrides\n}\n\n// Given returns the given overrides\nfunc (gv *Golingvu) Given() map[string]interface{} {\n\treturn gv.GivenOverrides\n}\n\n// When returns the when overrides\nfunc (gv *Golingvu) When() map[string]interface{} {\n\treturn gv.WhenOverrides\n}\n\n// Then returns the then overrides\nfunc (gv *Golingvu) Then() map[string]interface{} {\n\treturn gv.ThenOverrides\n}\n\n// GetTestJobs returns the test jobs\nfunc (gv *Golingvu) GetTestJobs() []ITestJob {\n\treturn gv.TestJobs\n}\n\n// GetSpecs returns the generated specs\nfunc (gv *Golingvu) GetSpecs() interface{} {\n\treturn gv.Specs\n}\n\n// AssertThis is a helper function for assertions\nfunc (gv *Golingvu) AssertThis(t interface{}) interface{} {\n\treturn gv.assertThis(t)\n}\n"
      },
      "test_adapter.go": {
        "__isFile": true,
        "content": "package golingvu\n\n// SimpleTestAdapter is a basic implementation of ITestAdapter\ntype SimpleTestAdapter struct{}\n\nfunc (a *SimpleTestAdapter) BeforeAll(input interface{}, tr ITTestResourceConfiguration, pm interface{}) interface{} {\n\treturn input\n}\n\nfunc (a *SimpleTestAdapter) AfterAll(store interface{}, pm interface{}) interface{} {\n\treturn store\n}\n\nfunc (a *SimpleTestAdapter) BeforeEach(subject, initializer interface{}, testResource ITTestResourceConfiguration, initialValues interface{}, pm interface{}) interface{} {\n\treturn subject\n}\n\nfunc (a *SimpleTestAdapter) AfterEach(store interface{}, key string, pm interface{}) interface{} {\n\treturn store\n}\n\nfunc (a *SimpleTestAdapter) AndWhen(store, whenCB interface{}, testResource interface{}, pm interface{}) interface{} {\n\treturn store\n}\n\nfunc (a *SimpleTestAdapter) ButThen(store, thenCB interface{}, testResource interface{}, pm interface{}) interface{} {\n\treturn store\n}\n\nfunc (a *SimpleTestAdapter) AssertThis(t interface{}) bool {\n\t// Simple implementation - always return true for now\n\treturn true\n}\n"
      },
      "types.go": {
        "__isFile": true,
        "content": "package golingvu\n\n// Ibdd_in_any represents the input types for BDD\ntype Ibdd_in_any interface {\n\tIinput() interface{}\n\tIsubject() interface{}\n\tIstore() interface{}\n\tIselection() interface{}\n\tThen() interface{}\n\tGiven() interface{}\n}\n\n// Ibdd_out_any represents the output types for BDD\ntype Ibdd_out_any interface{}\n\n// ITestSpecification defines the test specification function\ntype ITestSpecification func(suites, givens, whens, thens interface{}) interface{}\n\n// ITestImplementation defines the test implementation structure\ntype ITestImplementation struct {\n\tSuites map[string]interface{}\n\tGivens map[string]interface{}\n\tWhens  map[string]interface{}\n\tThens  map[string]interface{}\n}\n\n// ITestAdapter defines the adapter interface\ntype ITestAdapter interface {\n\tBeforeAll(input interface{}, tr ITTestResourceConfiguration, pm interface{}) interface{}\n\tAfterAll(store interface{}, pm interface{}) interface{}\n\tBeforeEach(subject, initializer interface{}, testResource ITTestResourceConfiguration, initialValues interface{}, pm interface{}) interface{}\n\tAfterEach(store interface{}, key string, pm interface{}) interface{}\n\tAndWhen(store, whenCB interface{}, testResource interface{}, pm interface{}) interface{}\n\tButThen(store, thenCB interface{}, testResource interface{}, pm interface{}) interface{}\n\tAssertThis(t interface{}) bool\n}\n\n// ITTestResourceConfiguration represents test resource configuration\ntype ITTestResourceConfiguration struct {\n\tName              string\n\tFs                string\n\tPorts             []int\n\tBrowserWSEndpoint string\n\tTimeout           int\n\tRetries           int\n\tEnvironment       map[string]string\n}\n\n// ITTestResourceRequirement represents test resource requirements\ntype ITTestResourceRequirement struct {\n\tName  string\n\tPorts int\n\tFs    string\n}\n\n// ITTestResourceRequest represents a test resource request\ntype ITTestResourceRequest struct {\n\tPorts int\n}\n\n// DefaultTestResourceRequest provides a default request\nvar DefaultTestResourceRequest = ITTestResourceRequest{\n\tPorts: 0,\n}\n\n// DefaultTestResourceRequirement provides a default requirement\nvar DefaultTestResourceRequirement = ITTestResourceRequirement{\n\tName:  \"default\",\n\tPorts: 0,\n\tFs:    \"./\",\n}\n\n// IFinalResults represents the final results of a test run\ntype IFinalResults struct {\n\tFailed    bool\n\tFails     int\n\tArtifacts []interface{}\n\tFeatures  []string\n}\n\n// ITestJob represents a test job\ntype ITestJob interface {\n\tToObj() map[string]interface{}\n\tRunner(pm interface{}, tLog func(...string)) (interface{}, error)\n\tReceiveTestResourceConfig(pm interface{}) (IFinalResults, error)\n}\n"
      }
    }
  }
}