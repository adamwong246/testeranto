/* eslint-disable @typescript-eslint/no-explicit-any */
import fs from "fs";
import path from "path";

export interface GolingvuMetafile {
  errors: any[];
  warnings: any[];
  metafile: {
    inputs: Record<
      string,
      {
        bytes: number;
        imports: any[];
      }
    >;
    outputs: Record<
      string,
      {
        imports: any[];
        exports: any[];
        entryPoint: string;
        inputs: Record<
          string,
          {
            bytesInOutput: number;
          }
        >;
        bytes: number;
      }
    >;
  };
}

export async function generateGolingvuMetafile(
  testName: string,
  entryPoints: string[]
): Promise<GolingvuMetafile> {
  const inputs: Record<string, any> = {};
  const outputs: Record<string, any> = {};

  // Generate a unique signature based on the current timestamp
  const signature = Date.now().toString(36);

  // Process each entry point
  for (const entryPoint of entryPoints) {
    // Check if the entry point exists
    if (!fs.existsSync(entryPoint)) {
      console.warn(`Entry point ${entryPoint} does not exist`);
      continue;
    }

    const bytes = fs.statSync(entryPoint).size;

    // Parse Go file to find imports
    const imports: string[] = [];
    try {
      const content = fs.readFileSync(entryPoint, "utf-8");
      // Simple regex to find import statements
      const importRegex = /import\s+(?:(?:\("([^"]*)"\))|(?:"([^"]*)"))/g;
      let match;

      while ((match = importRegex.exec(content)) !== null) {
        // match[1] is for multi-line imports in parentheses, match[2] is for single imports
        const importPath = match[1] || match[2];
        if (importPath) {
          imports.push(importPath.trim());
        }
      }

      // Also look for single-line imports without parentheses
      const singleImportRegex = /import\s+"([^"]+)"/g;
      while ((match = singleImportRegex.exec(content)) !== null) {
        imports.push(match[1].trim());
      }
    } catch (error) {
      console.warn(`Could not parse imports for ${entryPoint}:`, error);
    }

    // Add to inputs
    inputs[entryPoint] = {
      bytes,
      imports,
    };

    // Generate a consistent output path
    const entryPointName = path.basename(entryPoint, ".go");
    const outputKey = `testeranto/bundles/golang/${testName}/${entryPointName}.go`;
    outputs[outputKey] = {
      imports,
      exports: [], // Go doesn't have exports in the same way as JS
      entryPoint,
      inputs: {
        [entryPoint]: {
          bytesInOutput: bytes,
        },
      },
      bytes,
      signature, // Store the signature for later use - always include this
    };
  }

  // If no valid entry points were found, add a placeholder to prevent empty metafile
  if (Object.keys(inputs).length === 0) {
    inputs["placeholder.go"] = {
      bytes: 0,
      imports: [],
    };
    outputs["testeranto/bundles/golang/placeholder"] = {
      imports: [],
      exports: [],
      entryPoint: "placeholder.go",
      inputs: {
        "placeholder.go": {
          bytesInOutput: 0,
        },
      },
      bytes: 0,
    };
  }

  return {
    errors: [],
    warnings: [],
    metafile: {
      inputs,
      outputs,
    },
  };
}

export function writeGolingvuMetafile(
  testName: string,
  metafile: GolingvuMetafile
): void {
  const metafilePath = path.join(
    process.cwd(),
    "testeranto",
    "metafiles",
    "golang",
    "core.json"
  );
  const metafileDir = path.dirname(metafilePath);

  // Ensure directory exists
  if (!fs.existsSync(metafileDir)) {
    fs.mkdirSync(metafileDir, { recursive: true });
  }

  // Write the metafile
  fs.writeFileSync(metafilePath, JSON.stringify(metafile, null, 2));

  // Generate the output Go files
  const outputDir = path.join(
    process.cwd(),
    "testeranto",
    "bundles",
    "golang",
    testName
  );
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Create each output file
  for (const [outputPath, outputInfo] of Object.entries(
    metafile.metafile.outputs
  )) {
    const fullOutputPath = path.join(process.cwd(), outputPath);
    const outputDirPath = path.dirname(fullOutputPath);

    if (!fs.existsSync(outputDirPath)) {
      fs.mkdirSync(outputDirPath, { recursive: true });
    }

    // For Go, we can create a simple wrapper that imports and runs the test
    // Include the signature in a comment
    const entryPoint = (outputInfo as any).entryPoint;
    const signature = (outputInfo as any).signature;
    const content = `package main

import (
    "fmt"
    "os"
    "testing"
)

// This file is auto-generated by testeranto
// Signature: ${signature}
// It runs tests from: ${entryPoint}

func TestMain(m *testing.M) {
    fmt.Println("Running tests from ${entryPoint}")
    exitCode := m.Run()
    os.Exit(exitCode)
}
`;
    fs.writeFileSync(fullOutputPath, content);
  }

  // console.log(`Golang metafile and output files written for ${testName}`);
}
