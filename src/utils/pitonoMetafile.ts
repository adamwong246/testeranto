/* eslint-disable @typescript-eslint/no-explicit-any */
import fs from "fs";
import path from "path";

export interface PitonoMetafile {
  errors: any[];
  warnings: any[];
  metafile: {
    inputs: Record<
      string,
      {
        bytes: number;
        imports: any[];
      }
    >;
    outputs: Record<
      string,
      {
        imports: any[];
        exports: any[];
        entryPoint: string;
        inputs: Record<
          string,
          {
            bytesInOutput: number;
          }
        >;
        bytes: number;
        signature: string;
      }
    >;
  };
}

export async function generatePitonoMetafile(
  testName: string,
  entryPoints: string[]
): Promise<PitonoMetafile> {
  const inputs: Record<string, any> = {};
  const outputs: Record<string, any> = {};

  // Generate a unique signature based on the current timestamp
  const signature = Date.now().toString(36);

  // Process each entry point
  for (const entryPoint of entryPoints) {
    // Check if the entry point exists
    if (!fs.existsSync(entryPoint)) {
      console.warn(`Entry point ${entryPoint} does not exist`);
      continue;
    }

    const bytes = fs.statSync(entryPoint).size;

    // Parse Python file to find imports
    const imports: string[] = [];
    try {
      const content = fs.readFileSync(entryPoint, "utf-8");
      // Simple regex to find import statements
      const importRegex = /^(?:import|from)\s+(\w+)/gm;
      let match;

      while ((match = importRegex.exec(content)) !== null) {
        imports.push(match[1].trim());
      }
    } catch (error) {
      console.warn(`Could not parse imports for ${entryPoint}:`, error);
    }

    // Add to inputs
    inputs[entryPoint] = {
      bytes,
      imports,
    };

    // Generate a consistent output path
    const entryPointName = path.basename(entryPoint, ".py");
    const outputKey = `testeranto/bundles/python/${testName}/${entryPointName}.py`;
    outputs[outputKey] = {
      imports,
      exports: [],
      entryPoint,
      inputs: {
        [entryPoint]: {
          bytesInOutput: bytes,
        },
      },
      bytes,
      signature,
    };
  }

  // If no valid entry points were found, add a placeholder
  if (Object.keys(inputs).length === 0) {
    inputs["placeholder.py"] = {
      bytes: 0,
      imports: [],
    };
    outputs["testeranto/bundles/python/placeholder"] = {
      imports: [],
      exports: [],
      entryPoint: "placeholder.py",
      inputs: {
        "placeholder.py": {
          bytesInOutput: 0,
        },
      },
      bytes: 0,
      signature: "placeholder",
    };
  }

  return {
    errors: [],
    warnings: [],
    metafile: {
      inputs,
      outputs,
    },
  };
}

export function writePitonoMetafile(
  testName: string,
  metafile: PitonoMetafile
): void {
  const metafilePath = path.join(
    process.cwd(),
    "testeranto",
    "metafiles",
    "python",
    "core.json"
  );
  const metafileDir = path.dirname(metafilePath);

  // Ensure directory exists
  if (!fs.existsSync(metafileDir)) {
    fs.mkdirSync(metafileDir, { recursive: true });
  }

  // Write the metafile
  fs.writeFileSync(metafilePath, JSON.stringify(metafile, null, 2));

  // Generate the output Python files
  const outputDir = path.join(
    process.cwd(),
    "testeranto",
    "bundles",
    "python",
    testName
  );
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Create each output file
  for (const [outputPath, outputInfo] of Object.entries(
    metafile.metafile.outputs
  )) {
    const fullOutputPath = path.join(process.cwd(), outputPath);
    const outputDirPath = path.dirname(fullOutputPath);

    if (!fs.existsSync(outputDirPath)) {
      fs.mkdirSync(outputDirPath, { recursive: true });
    }

    const entryPoint = (outputInfo as any).entryPoint;
    const signature = (outputInfo as any).signature;
    const content = `# This file is auto-generated by testeranto
# Signature: ${signature}
# It runs tests from: ${entryPoint}

import os
import sys

# Add the original entry point to the path
sys.path.insert(0, os.path.dirname(os.path.abspath("${entryPoint}")))

# Import and run the tests
try:
    # Import the module
    module_name = os.path.basename("${entryPoint}").replace('.py', '')
    module = __import__(module_name)
    
    # Run the tests if there's a main block
    if hasattr(module, 'main'):
        module.main()
    else:
        print(f"No main function found in {module_name}")
except Exception as e:
    print(f"Error running tests from ${entryPoint}: {e}")
    sys.exit(1)
`;
    fs.writeFileSync(fullOutputPath, content);
  }
}
