import esbuild from "esbuild";
import fs from "fs";
import path from "path";
import puppeteer from "puppeteer-core";
import { IBuiltConfig } from "../../../Types";
import configer from "./esbuild";
import { 
  computeFilesHash, 
  sendSourceFilesUpdated, 
  extractInputFilesFromMetafile,
  processMetafileAndSendUpdates 
} from "../common";

const projectName = process.argv[2];
const mode = process.argv[3] || "dev";

let browser: puppeteer.Browser;

async function startChromeBrowser() {
  console.log("Starting Chrome browser via Puppeteer...");
  try {
    // Start Chrome with remote debugging enabled on port 9222
    // This matches the port exposed in the Docker Compose file
    browser = await puppeteer.launch({
      slowMo: 1,
      waitForInitialPage: false,
      executablePath: process.env.CHROMIUM_PATH || "/usr/bin/chromium-browser",
      defaultViewport: null,
      dumpio: true, // Enable to see browser logs in Docker
      args: [
        "--remote-debugging-port=9222",
        "--remote-debugging-address=0.0.0.0", // Allow connections from outside the container
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--disable-dev-shm-usage",
        "--disable-accelerated-2d-canvas",
        "--disable-gpu",
        "--window-size=1920,1080",
        "--headless=new",
      ],
      headless: true,
    });

    console.log("Chrome browser started with remote debugging on port 9222");
    console.log(`WebSocket endpoint: ${browser.wsEndpoint()}`);
    return browser;
  } catch (error) {
    throw new Error(`Chrome is not available: ${error.message}`);
  }
}

async function extractFilesFromPage(page: puppeteer.Page): Promise<Record<string, string>> {
  return await page.evaluate(() => {
    return (window as any).__testeranto_files__ || {};
  });
}

async function saveExtractedFiles(files: Record<string, string>, basePath: string) {
  const fs = require('fs');
  const path = require('path');

  for (const [filename, content] of Object.entries(files)) {
    const fullPath = path.join(basePath, filename);
    const dir = path.dirname(fullPath);

    // Ensure directory exists
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(fullPath, content);
    console.log(`Saved file: ${fullPath}`);
  }
}

async function startBundling(config: IBuiltConfig) {
  // Note: configer needs to be called with the project name, but it's not clear from the code
  // Let's assume it's similar to nodeConfiger
  const webConfig = configer(config, projectName);

  // Build the web bundle
  const buildResult = await esbuild.build(webConfig);

  if (buildResult.errors.length > 0) {
    console.error("WEB BUILDER build errors:", buildResult.errors);
  }
  if (buildResult.warnings.length > 0) {
    console.warn("WEB BUILDER build warnings:", buildResult.warnings);
  }

  console.log(`WEB BUILDER build completed for ${projectName}`);

  // Write metafile in the same format as other runtimes
  const metafilesDir =
    process.env.METAFILES_DIR || "/workspace/testeranto/metafiles/web";

  // Ensure directory exists
  if (!fs.existsSync(metafilesDir)) {
    fs.mkdirSync(metafilesDir, { recursive: true });
  }

  const generatedMetafilePath = path.join(metafilesDir, "allTests.json");

  if (buildResult.metafile) {
    const metafileWrapper = {
      errors: [],
      warnings: [],
      metafile: buildResult.metafile,
    };
    fs.writeFileSync(
      generatedMetafilePath,
      JSON.stringify(metafileWrapper, null, 2)
    );

    // Process metafile and send updates using shared function
    await processMetafileAndSendUpdates(config, buildResult.metafile, 'web');

  } else {
    console.warn("No metafile generated by esbuild");
  }

  await startChromeBrowser();

  console.log("WEB BUILDER: Chrome is now hosted and ready for test execution");
  console.log("WEB BUILDER: Metafiles have been generated");

  // Run tests and extract files
  await runTestsAndExtractFiles(config);

  // In dev mode, keep the process alive to host Chrome
  if (mode === "dev") {
    console.log(
      "WEB BUILDER: Running in dev mode, keeping Chrome instance alive..."
    );

    // Watch for changes to rebuild metafiles
    console.log("WEB BUILDER: Setting up file watcher for rebuilds...");
    const ctx = await esbuild.context(webConfig);
    await ctx.watch();

    // Keep the process alive
    process.on("SIGINT", async () => {
      console.log("WEB BUILDER: Shutting down...");
      if (browser) await browser.close();
      process.exit(0);
    });

    // Keep alive
    await new Promise(() => {
      // This promise never resolves, keeping the process alive
    });
  }
}

async function runTestsAndExtractFiles(config: IBuiltConfig) {
  try {
    // Create a new page
    // const page = await browser.newPage();

    // Navigate to the test page
    // The test bundle is at a known location
    // const testBundlePath = `file://${process.cwd()}/testeranto/bundles/allTests/web/example/Calculator.test.mjs`;
    // console.log(`Navigating to test bundle: ${testBundlePath}`);
    // await page.goto(testBundlePath);

    // Wait for tests to complete - give them some time
    // We'll wait for up to 30 seconds, checking periodically
    // const maxWaitTime = 30000; // 30 seconds
    // const startTime = Date.now();

    // while (Date.now() - startTime < maxWaitTime) {
    //   // Check if there are any files written (indicating tests have run)
    //   const hasFiles = await page.evaluate(() => {
    //     return !!(window as any).__testeranto_files__ && Object.keys((window as any).__testeranto_files__).length > 0;
    //   });

    //   if (hasFiles) {
    //     console.log("Tests have written files, proceeding to extract...");
    //     break;
    //   }

    //   // Wait a bit before checking again
    //   await new Promise(resolve => setTimeout(resolve, 1000));
    // }

    // console.log("Extracting files...");

    // // Extract files from the page
    // const files = await extractFilesFromPage(page);

    // // Save files to host filesystem
    // const basePath = process.cwd();
    // await saveExtractedFiles(files, basePath);

    // console.log(`Extracted ${Object.keys(files).length} files`);

    // // Close the page
    // await page.close();
  } catch (error) {
    console.error("Error running tests and extracting files:", error);
  }
}

async function main() {
  const configPathBase = `/workspace/${projectName}`;

  const config = (await import(`/workspace/${projectName}`)).default;

  try {
    await startBundling(config);

    // Keep the process alive in dev mode
    if (mode === "dev") {
      console.log("WEB BUILDER: Running in dev mode, keeping process alive...");
      // Keep process alive
      process.on("SIGINT", async () => {
        console.log("WEB BUILDER: Shutting down...");
        if (browser) await browser.close();
        process.exit(0);
      });
    }
  } catch (error) {
    console.error("WEB BUILDER: Error:", error);
    if (browser) await browser.close();
    process.exit(1);
  }
}

main();

/////////////////////////

// const fileStreams3: fs.WriteStream[] = [];
// type IFPaths = string[];
// const fPaths: IFPaths = [];
// const files: Record<string, Set<string>> = {};
// const recorders: Record<string, ScreenRecorder> = {};
// const screenshots: Record<string, Promise<Uint8Array>[]> = {};

// export abstract class Server_Base {
//   mode: IMode;
//   browser: Browser;
//   configs: IBuiltConfig;
//   projectName: string;

//   constructor(configs: IBuiltConfig, projectName: string, mode: IMode) {
//     this.configs = configs;
//     this.mode = mode;
//     this.projectName = projectName;
//   }

//   mapping(): [string, (...a) => any][] {
//     return [
//       ["$", this.$],
//       ["click", this.click],
//       ["closePage", this.closePage],
//       ["createWriteStream", this.createWriteStream],
//       ["customclose", this.customclose],
//       ["customScreenShot", this.customScreenShot.bind(this)],
//       ["end", this.end],
//       ["existsSync", this.existsSync],
//       ["focusOn", this.focusOn],
//       ["getAttribute", this.getAttribute],
//       ["getInnerHtml", this.getInnerHtml],
//       // ["setValue", this.setValue],
//       ["goto", this.goto.bind(this)],
//       ["isDisabled", this.isDisabled],
//       // ["launchSideCar", this.launchSideCar.bind(this)],
//       ["mkdirSync", this.mkdirSync],
//       ["newPage", this.newPage],
//       ["page", this.page],
//       ["pages", this.pages],
//       ["screencast", this.screencast],
//       ["screencastStop", this.screencastStop],
//       // ["stopSideCar", this.stopSideCar.bind(this)],
//       ["typeInto", this.typeInto],
//       ["waitForSelector", this.waitForSelector],
//       ["write", this.write],
//       ["writeFileSync", this.writeFileSync],
//     ];
//   }

//   customclose() {
//     throw new Error("customclose not implemented.");
//   }

//   waitForSelector(p: string, s: string): any {
//     return new Promise((res) => {
//       this.doInPage(p, async (page) => {
//         const x = page.$(s);
//         const y = await x;
//         res(y !== null);
//       });
//     });
//   }

//   closePage(p): any {
//     return new Promise((res) => {
//       this.doInPage(p, async (page) => {
//         page.close();
//         res({});
//       });
//     });
//   }

//   async newPage(): Promise<string> {
//     return (await this.browser.newPage()).mainFrame()._id;
//   }

//   goto(p, url: string): any {
//     return new Promise((res) => {
//       this.doInPage(p, async (page) => {
//         await page?.goto(url);

//         res({});
//       });
//     });
//   }

//   $(selector: string, p: string): Promise<any> {
//     return new Promise((res) => {
//       this.doInPage(p, async (page) => {
//         const x = await page.$(selector);
//         const y = await x?.jsonValue();
//         res(y);
//       });
//     });
//   }

//   async pages(): Promise<string[]> {
//     return (await this.browser.pages()).map((p) => {
//       return (p.mainFrame() as any)._id;
//     });
//   }

//   async screencast(ssOpts: ScreenshotOptions, testName: string, page: Page) {
//     const p = ssOpts.path as string;
//     const dir = path.dirname(p);
//     fs.mkdirSync(dir, {
//       recursive: true,
//     });
//     if (!files[testName]) {
//       files[testName] = new Set();
//     }
//     files[testName].add(ssOpts.path as string);

//     const sPromise = page.screenshot({
//       ...ssOpts,
//       path: p,
//     });

//     if (!screenshots[testName]) {
//       screenshots[testName] = [];
//     }
//     screenshots[testName].push(sPromise);
//     await sPromise;
//     return sPromise;
//   }

//   async customScreenShot(
//     ssOpts: ScreenshotOptions,
//     testName: string,
//     pageUid: any
//   ) {
//     const p = ssOpts.path as string;
//     const dir = path.dirname(p);
//     fs.mkdirSync(dir, {
//       recursive: true,
//     });
//     if (!files[testName]) {
//       files[testName] = new Set();
//     }
//     files[testName].add(ssOpts.path as string);

//     const page = (await this.browser.pages()).find(
//       (p) => p.mainFrame()._id === pageUid
//     ) as Page;
//     const sPromise = page.screenshot({
//       ...ssOpts,
//       path: p,
//     });

//     if (!screenshots[testName]) {
//       screenshots[testName] = [];
//     }
//     screenshots[testName].push(sPromise);
//     await sPromise;
//     return sPromise;
//   }

//   async end(uid: number): Promise<boolean> {
//     await fileStreams3[uid].end();
//     return true;
//   }

//   existsSync(destFolder: string): boolean {
//     return fs.existsSync(destFolder);
//   }

//   async mkdirSync(fp: string) {
//     if (!fs.existsSync(fp)) {
//       return fs.mkdirSync(fp, {
//         recursive: true,
//       });
//     }
//     return false;
//   }

//   async writeFileSync(...x): Promise<boolean> {
//     const filepath = x[0];
//     const contents = x[1];
//     const testName = x[2];
//     return new Promise<boolean>(async (res) => {
//       fs.mkdirSync(path.dirname(filepath), {
//         recursive: true,
//       });
//       if (!files[testName]) {
//         files[testName] = new Set();
//       }
//       files[testName].add(filepath);

//       await fs.writeFileSync(filepath, contents);
//       res(true);
//     });
//   }

//   async createWriteStream(filepath: string, testName: string): Promise<number> {
//     const folder = filepath.split("/").slice(0, -1).join("/");

//     return new Promise<number>((res) => {
//       if (!fs.existsSync(folder)) {
//         return fs.mkdirSync(folder, {
//           recursive: true,
//         });
//       }

//       const f = fs.createWriteStream(filepath);
//       fileStreams3.push(f);
//       if (!files[testName]) {
//         files[testName] = new Set();
//       }
//       files[testName].add(filepath);

//       res(fileStreams3.length - 1);
//     });
//   }

//   async write(uid: number, contents: string): Promise<boolean> {
//     return new Promise<boolean>((res) => {
//       const x = fileStreams3[uid].write(contents);
//       res(x);
//     });
//   }

//   page(p): string | undefined {
//     return p;
//   }

//   click(selector: string, page: Page) {
//     return page.click(selector);
//   }

//   async focusOn(selector: string, p: string) {
//     this.doInPage(p, (page) => {
//       return page.focus(selector);
//     });
//   }

//   async typeInto(value: string, p: string) {
//     this.doInPage(p, (page) => {
//       return page.keyboard.type(value);
//     });
//   }

//   getAttribute(selector: string, attribute: string, p: string) {
//     this.doInPage(p, (page) => {
//       return page.$eval(selector, (input) => input.getAttribute(attribute));
//     });
//   }

//   async getInnerHtml(selector: string, p: string) {
//     return new Promise((res, rej) => {
//       this.doInPage(p, async (page) => {
//         const e = await page.$(selector);
//         if (!e) {
//           rej();
//         } else {
//           const text = await (await e.getProperty("textContent")).jsonValue();
//           res(text);
//         }
//       });
//     });
//   }

//   isDisabled(selector: string, p: string) {
//     this.doInPage(p, async (page) => {
//       return await page.$eval(selector, (input: HTMLButtonElement) => {
//         return input.disabled;
//       });
//     });
//   }

//   screencastStop(s: string) {
//     return recorders[s].stop();
//   }

//   async doInPage(p: string, cb: (p: Page) => unknown) {
//     (await this.browser.pages()).forEach((page: Page) => {
//       const frame = page.mainFrame() as { _id?: string };
//       if (frame._id === p) {
//         return cb(page);
//       }
//     });
//   }

//   async stop() {
//     // await super.stop();
//   }
// }
