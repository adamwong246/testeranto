import fs from "fs";
import path from "path";
import esbuild from "esbuild";
import { WebSocket } from "ws";
import { IBuiltConfig } from "../../../Types";
import nodeConfiger from "./esbuild";

const testName = process.argv[2];

// Helper to compute a simple hash from file paths and contents
async function computeFilesHash(files: string[]): Promise<string> {
  // For simplicity, we'll use a basic approach
  // In a real implementation, we'd want to hash file contents
  const crypto = await import('crypto');
  const hash = crypto.createHash('md5');
  
  for (const file of files) {
    try {
      const stats = fs.statSync(file);
      hash.update(file);
      hash.update(stats.mtimeMs.toString());
      hash.update(stats.size.toString());
    } catch (error) {
      // File may not exist, include its name anyway
      hash.update(file);
      hash.update('missing');
    }
  }
  
  return hash.digest('hex');
}

// Connect to WebSocket server and send sourceFilesUpdated message
async function sendSourceFilesUpdated(
  config: IBuiltConfig, 
  testName: string, 
  hash: string, 
  files: string[]
): Promise<void> {
  return new Promise((resolve, reject) => {
    // WebSocket server is on the host machine
    // Use host.docker.internal to connect from Docker container to host
    const wsUrl = `ws://host.docker.internal:${config.httpPort}/ws`;
    console.log(`[Node Builder] Connecting to WebSocket at ${wsUrl}`);
    
    const ws = new WebSocket(wsUrl);
    
    ws.on('open', () => {
      console.log(`[Node Builder] WebSocket connected, sending sourceFilesUpdated for ${testName}`);
      ws.send(JSON.stringify({
        type: 'sourceFilesUpdated',
        data: {
          testName,
          hash,
          files
        }
      }));
      
      // Wait a moment for the message to be sent before closing
      setTimeout(() => {
        ws.close();
        resolve();
      }, 1000);
    });
    
    ws.on('error', (error) => {
      console.error(`[Node Builder] WebSocket error:`, error);
      reject(error);
    });
    
    ws.on('close', () => {
      console.log(`[Node Builder] WebSocket connection closed`);
    });
  });
}

// Extract input files from metafile
function extractInputFilesFromMetafile(metafile: any): string[] {
  const files: string[] = [];
  
  if (metafile && metafile.inputs) {
    for (const inputPath of Object.keys(metafile.inputs)) {
      // Convert to absolute path if needed
      files.push(path.resolve(process.cwd(), inputPath));
    }
  }
  
  return files;
}

// run esbuild in watch mode using esbuildConfigs. Write to fs the bundle and metafile
async function startBundling(
  config: IBuiltConfig
) {
  console.log(`NODE BUILDER is now bundling:  ${testName}`);
  const n = nodeConfiger(config, testName);

  const bv = await esbuild.build(n);

  const metafilesDir =
    process.env.METAFILES_DIR || "/workspace/testeranto/metafiles/node";

  const metafilePath = path.join(metafilesDir, "allTests.json");
  
  let inputFiles: string[] = [];
  let hash = '';
  
  if (bv.metafile) {
    const metafileWrapper = {
      errors: [],
      warnings: [],
      metafile: bv.metafile,
    };
    fs.writeFileSync(metafilePath, JSON.stringify(metafileWrapper, null, 2));
    console.log(`Node metafile written to ${metafilePath}`);
    
    // Extract input files from metafile
    inputFiles = extractInputFilesFromMetafile(bv.metafile);
    console.log(`[Node Builder] Found ${inputFiles.length} input files`);
    
    // Compute hash
    hash = await computeFilesHash(inputFiles);
    console.log(`[Node Builder] Computed hash: ${hash}`);
    
    // Send sourceFilesUpdated message via WebSocket
    try {
      await sendSourceFilesUpdated(config, testName, hash, inputFiles);
      console.log(`[Node Builder] Successfully sent sourceFilesUpdated message`);
    } catch (error) {
      console.error(`[Node Builder] Failed to send sourceFilesUpdated:`, error);
      // Don't fail the build if WebSocket connection fails
    }
  } else {
    console.warn("No metafile generated by esbuild");
  }

  // THIS IS WRONG
  // fork(`testeranto/bundles/allTests/node/example/Calculator.test.mjs`, [
  //   config.httpPort.toString(),
  // ]);
}

async function main() {
  const config = (await import(`/workspace/${testName}`)).default;

  try {
    await startBundling(config);
  } catch (error) {
    console.error("NODE BUILDER: Error:", error);
    process.exit(1);
  }
}

main();
