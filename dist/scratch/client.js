var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
function noop() {
}
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a3 = context, errorThrown = _a3.errorThrown, error = _a3.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
function identity(x) {
  return x;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
function getPromiseCtor(promiseCtor) {
  var _a3;
  return (_a3 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a3 !== void 0 ? _a3 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source2) {
  return isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
}
function operate(init) {
  return function(source2) {
    if (hasLift(source2)) {
      return source2.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a3, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a3 = _b.sent(), value = _a3.value, done = _a3.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a3;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a3 = iterable_1.return))
          _a3.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a3;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a3 = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a3.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source2, subscriber) {
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source2, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source2.subscribe(subscriber);
    }, delay2));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a3;
        var value;
        var done;
        try {
          _a3 = iterator2.next(), value = _a3.value, done = _a3.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}
function firstValueFrom(source2, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source2.subscribe(subscriber);
  });
}
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
function map(project, thisArg) {
  return operate(function(source2, subscriber) {
    var index = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a3 = argsArgArrayOrObject(args), observables = _a3.args, keys = _a3.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source2 = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
function mergeInternals(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source2.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source2, subscriber) {
    return mergeInternals(source2, subscriber, project, concurrent);
  });
}
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a3 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a3[0], remove = _a3[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}
function filter(predicate, thisArg) {
  return operate(function(source2, subscriber) {
    var index = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
function race() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}
function catchError(selector) {
  return operate(function(source2, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source2.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source2)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
function defaultIfEmpty(defaultValue) {
  return operate(function(source2, subscriber) {
    var hasValue = false;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source2, subscriber) {
    var seen = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
function ignoreElements() {
  return operate(function(source2, subscriber) {
    source2.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}
function mapTo(value) {
  return map(function() {
    return value;
  });
}
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source2) {
      return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source2.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value, index) {
    return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value));
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source2, subscriber) {
    var hasValue = false;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source2);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return operate(function(source2, subscriber) {
    var state = seed;
    return mergeInternals(source2, subscriber, function(value, index) {
      return accumulator(state, value, index);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source2, subscriber) {
    raceInit(__spreadArray([source2], __read(otherSources)))(subscriber);
  });
}
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a3 = config2.count, count = _a3 === void 0 ? Infinity : _a3, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count <= 0 ? identity : operate(function(source2, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source2, subscriber) {
    (scheduler ? concat(values, source2, scheduler) : concat(values, source2)).subscribe(subscriber);
  });
}
function switchMap(project, resultSelector) {
  return operate(function(source2, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
function takeUntil(notifier) {
  return operate(function(source2, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source2.subscribe(subscriber);
  });
}
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source2, subscriber) {
    var _a3;
    (_a3 = tapObserver.subscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
    var isUnsub = true;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a22;
      (_a22 = tapObserver.next) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a22;
      isUnsub = false;
      (_a22 = tapObserver.complete) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a22;
      isUnsub = false;
      (_a22 = tapObserver.error) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a22, _b;
      if (isUnsub) {
        (_a22 = tapObserver.unsubscribe) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
var extendStatics, UnsubscriptionError, Subscription, EMPTY_SUBSCRIPTION, config, timeoutProvider, COMPLETE_NOTIFICATION, context, Subscriber, _bind, ConsumerObserver, SafeSubscriber, EMPTY_OBSERVER, observable, Observable, OperatorSubscriber, ObjectUnsubscribedError, Subject, AnonymousSubject, dateTimestampProvider, ReplaySubject, Action, intervalProvider, AsyncAction, Scheduler, AsyncScheduler, asyncScheduler, async, EMPTY, isArrayLike, iterator, EmptyError, isArray, isArray2, getPrototypeOf, objectProto, getKeys, nodeEventEmitterMethods, eventTargetMethods, jqueryMethods, NEVER, isArray3;
var init_rxjs = __esm({
  "node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d2[p2] = b2[p2];
      };
      return extendStatics(d, b);
    };
    UnsubscriptionError = createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
    Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a3, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a3 = _parentage_1.return))
                    _a3.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError) {
                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a3;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a3 = this._finalizers) !== null && _a3 !== void 0 ? _a3 : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty = new Subscription2();
        empty.closed = true;
        return empty;
      }();
      return Subscription2;
    }();
    EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
    timeoutProvider = {
      setTimeout: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
    COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    context = null;
    Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription);
    _bind = Function.prototype.bind;
    ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop
    };
    observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(function() {
          var _a3 = _this, operator = _a3.operator, source2 = _a3.source;
          subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a3;
        return (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    OperatorSubscriber = function(_super) {
      __extends(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a3;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a3 = this.onFinalize) === null || _a3 === void 0 ? void 0 : _a3.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber);
    ObjectUnsubscribedError = createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
    Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext(function() {
          var e_1, _a3;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a3 = _b.return))
                  _a3.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a3;
          return ((_a3 = this.observers) === null || _a3 === void 0 ? void 0 : _a3.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a3 = this, hasError = _a3.hasError, isStopped = _a3.isStopped, observers = _a3.observers;
        if (hasError || isStopped) {
          return EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription(function() {
          _this.currentObservers = null;
          arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a3 = this, hasError = _a3.hasError, thrownError = _a3.thrownError, isStopped = _a3.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source2) {
        return new AnonymousSubject(destination, source2);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source2) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source2;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a3, _b;
        (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.next) === null || _b === void 0 ? void 0 : _b.call(_a3, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a3, _b;
        (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.error) === null || _b === void 0 ? void 0 : _b.call(_a3, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a3, _b;
        (_b = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.complete) === null || _b === void 0 ? void 0 : _b.call(_a3);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a3, _b;
        return (_b = (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
    dateTimestampProvider = {
      now: function() {
        return (dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
    ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a3 = this, isStopped = _a3.isStopped, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow, _timestampProvider = _a3._timestampProvider, _windowTime = _a3._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a3 = this, _infiniteTimeWindow = _a3._infiniteTimeWindow, _buffer = _a3._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a3 = this, _bufferSize = _a3._bufferSize, _timestampProvider = _a3._timestampProvider, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last2 = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last2 = i;
          }
          last2 && _buffer.splice(0, last2 + 1);
        }
      };
      return ReplaySubject2;
    }(Subject);
    Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription);
    intervalProvider = {
      setInterval: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
    AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay2) {
        var _a3;
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = (_a3 = this.id) !== null && _a3 !== void 0 ? _a3 : this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && this.delay === delay2 && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay2);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a3 = this, id = _a3.id, scheduler = _a3.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action);
    Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay2);
      };
      Scheduler2.now = dateTimestampProvider.now;
      return Scheduler2;
    }();
    AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
    EMPTY = new Observable(function(subscriber) {
      return subscriber.complete();
    });
    isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
    iterator = getSymbolIterator();
    EmptyError = createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
    isArray = Array.isArray;
    isArray2 = Array.isArray;
    getPrototypeOf = Object.getPrototypeOf;
    objectProto = Object.prototype;
    getKeys = Object.keys;
    nodeEventEmitterMethods = ["addListener", "removeListener"];
    eventTargetMethods = ["addEventListener", "removeEventListener"];
    jqueryMethods = ["on", "off"];
    NEVER = new Observable(noop);
    isArray3 = Array.isArray;
  }
});

// node_modules/puppeteer-core/lib/esm/third_party/mitt/mitt.js
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
var init_mitt = __esm({
  "node_modules/puppeteer-core/lib/esm/third_party/mitt/mitt.js"() {
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js
var disposeSymbol, asyncDisposeSymbol, DisposableStack, AsyncDisposableStack;
var init_disposable = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js"() {
    Symbol.dispose ??= Symbol("dispose");
    Symbol.asyncDispose ??= Symbol("asyncDispose");
    disposeSymbol = Symbol.dispose;
    asyncDisposeSymbol = Symbol.asyncDispose;
    DisposableStack = class {
      #disposed = false;
      #stack = [];
      /**
       * Returns a value indicating whether this stack has been disposed.
       */
      get disposed() {
        return this.#disposed;
      }
      /**
       * Disposes each resource in the stack in the reverse order that they were added.
       */
      dispose() {
        if (this.#disposed) {
          return;
        }
        this.#disposed = true;
        for (const resource of this.#stack.reverse()) {
          resource[disposeSymbol]();
        }
      }
      /**
       * Adds a disposable resource to the stack, returning the resource.
       *
       * @param value - The resource to add. `null` and `undefined` will not be added,
       * but will be returned.
       * @returns The provided `value`.
       */
      use(value) {
        if (value) {
          this.#stack.push(value);
        }
        return value;
      }
      /**
       * Adds a value and associated disposal callback as a resource to the stack.
       *
       * @param value - The value to add.
       * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
       * method. Will be invoked with `value` as the first parameter.
       * @returns The provided `value`.
       */
      adopt(value, onDispose) {
        this.#stack.push({
          [disposeSymbol]() {
            onDispose(value);
          }
        });
        return value;
      }
      /**
       * Adds a callback to be invoked when the stack is disposed.
       */
      defer(onDispose) {
        this.#stack.push({
          [disposeSymbol]() {
            onDispose();
          }
        });
      }
      /**
       * Move all resources out of this stack and into a new `DisposableStack`, and
       * marks this stack as disposed.
       *
       * @example
       *
       * ```ts
       * class C {
       *   #res1: Disposable;
       *   #res2: Disposable;
       *   #disposables: DisposableStack;
       *   constructor() {
       *     // stack will be disposed when exiting constructor for any reason
       *     using stack = new DisposableStack();
       *
       *     // get first resource
       *     this.#res1 = stack.use(getResource1());
       *
       *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
       *     this.#res2 = stack.use(getResource2());
       *
       *     // all operations succeeded, move resources out of `stack` so that
       *     // they aren't disposed when constructor exits
       *     this.#disposables = stack.move();
       *   }
       *
       *   [disposeSymbol]() {
       *     this.#disposables.dispose();
       *   }
       * }
       * ```
       */
      move() {
        if (this.#disposed) {
          throw new ReferenceError("a disposed stack can not use anything new");
        }
        const stack = new DisposableStack();
        stack.#stack = this.#stack;
        this.#disposed = true;
        return stack;
      }
      [disposeSymbol] = this.dispose;
      [Symbol.toStringTag] = "DisposableStack";
    };
    AsyncDisposableStack = class {
      #disposed = false;
      #stack = [];
      /**
       * Returns a value indicating whether this stack has been disposed.
       */
      get disposed() {
        return this.#disposed;
      }
      /**
       * Disposes each resource in the stack in the reverse order that they were added.
       */
      async dispose() {
        if (this.#disposed) {
          return;
        }
        this.#disposed = true;
        for (const resource of this.#stack.reverse()) {
          await resource[asyncDisposeSymbol]();
        }
      }
      /**
       * Adds a disposable resource to the stack, returning the resource.
       *
       * @param value - The resource to add. `null` and `undefined` will not be added,
       * but will be returned.
       * @returns The provided `value`.
       */
      use(value) {
        if (value) {
          this.#stack.push(value);
        }
        return value;
      }
      /**
       * Adds a value and associated disposal callback as a resource to the stack.
       *
       * @param value - The value to add.
       * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
       * method. Will be invoked with `value` as the first parameter.
       * @returns The provided `value`.
       */
      adopt(value, onDispose) {
        this.#stack.push({
          [asyncDisposeSymbol]() {
            return onDispose(value);
          }
        });
        return value;
      }
      /**
       * Adds a callback to be invoked when the stack is disposed.
       */
      defer(onDispose) {
        this.#stack.push({
          [asyncDisposeSymbol]() {
            return onDispose();
          }
        });
      }
      /**
       * Move all resources out of this stack and into a new `DisposableStack`, and
       * marks this stack as disposed.
       *
       * @example
       *
       * ```ts
       * class C {
       *   #res1: Disposable;
       *   #res2: Disposable;
       *   #disposables: DisposableStack;
       *   constructor() {
       *     // stack will be disposed when exiting constructor for any reason
       *     using stack = new DisposableStack();
       *
       *     // get first resource
       *     this.#res1 = stack.use(getResource1());
       *
       *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
       *     this.#res2 = stack.use(getResource2());
       *
       *     // all operations succeeded, move resources out of `stack` so that
       *     // they aren't disposed when constructor exits
       *     this.#disposables = stack.move();
       *   }
       *
       *   [disposeSymbol]() {
       *     this.#disposables.dispose();
       *   }
       * }
       * ```
       */
      move() {
        if (this.#disposed) {
          throw new ReferenceError("a disposed stack can not use anything new");
        }
        const stack = new AsyncDisposableStack();
        stack.#stack = this.#stack;
        this.#disposed = true;
        return stack;
      }
      [asyncDisposeSymbol] = this.dispose;
      [Symbol.toStringTag] = "AsyncDisposableStack";
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js
var EventEmitter;
var init_EventEmitter = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js"() {
    init_mitt();
    init_disposable();
    EventEmitter = class {
      #emitter;
      #handlers = /* @__PURE__ */ new Map();
      /**
       * If you pass an emitter, the returned emitter will wrap the passed emitter.
       *
       * @internal
       */
      constructor(emitter = mitt_default(/* @__PURE__ */ new Map())) {
        this.#emitter = emitter;
      }
      /**
       * Bind an event listener to fire when an event occurs.
       * @param type - the event type you'd like to listen to. Can be a string or symbol.
       * @param handler - the function to be called when the event occurs.
       * @returns `this` to enable you to chain method calls.
       */
      on(type, handler) {
        const handlers = this.#handlers.get(type);
        if (handlers === void 0) {
          this.#handlers.set(type, [handler]);
        } else {
          handlers.push(handler);
        }
        this.#emitter.on(type, handler);
        return this;
      }
      /**
       * Remove an event listener from firing.
       * @param type - the event type you'd like to stop listening to.
       * @param handler - the function that should be removed.
       * @returns `this` to enable you to chain method calls.
       */
      off(type, handler) {
        const handlers = this.#handlers.get(type) ?? [];
        if (handler === void 0) {
          for (const handler2 of handlers) {
            this.#emitter.off(type, handler2);
          }
          this.#handlers.delete(type);
          return this;
        }
        const index = handlers.lastIndexOf(handler);
        if (index > -1) {
          this.#emitter.off(type, ...handlers.splice(index, 1));
        }
        return this;
      }
      /**
       * Emit an event and call any associated listeners.
       *
       * @param type - the event you'd like to emit
       * @param eventData - any data you'd like to emit with the event
       * @returns `true` if there are any listeners, `false` if there are not.
       */
      emit(type, event) {
        this.#emitter.emit(type, event);
        return this.listenerCount(type) > 0;
      }
      /**
       * Like `on` but the listener will only be fired once and then it will be removed.
       * @param type - the event you'd like to listen to
       * @param handler - the handler function to run when the event occurs
       * @returns `this` to enable you to chain method calls.
       */
      once(type, handler) {
        const onceHandler = (eventData) => {
          handler(eventData);
          this.off(type, onceHandler);
        };
        return this.on(type, onceHandler);
      }
      /**
       * Gets the number of listeners for a given event.
       *
       * @param type - the event to get the listener count for
       * @returns the number of listeners bound to the given event
       */
      listenerCount(type) {
        return this.#handlers.get(type)?.length || 0;
      }
      /**
       * Removes all listeners. If given an event argument, it will remove only
       * listeners for that event.
       *
       * @param type - the event to remove listeners for.
       * @returns `this` to enable you to chain method calls.
       */
      removeAllListeners(type) {
        if (type !== void 0) {
          return this.off(type);
        }
        this[disposeSymbol]();
        return this;
      }
      /**
       * @internal
       */
      [disposeSymbol]() {
        for (const [type, handlers] of this.#handlers) {
          for (const handler of handlers) {
            this.#emitter.off(type, handler);
          }
        }
        this.#handlers.clear();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/environment.js
var isNode, environment;
var init_environment = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/environment.js"() {
    isNode = !!(typeof process !== "undefined" && process.version);
    environment = {
      value: {
        get fs() {
          throw new Error("fs is not available in this environment");
        },
        get ScreenRecorder() {
          throw new Error("ScreenRecorder is not available in this environment");
        }
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/generated/version.js
var packageVersion;
var init_version = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/generated/version.js"() {
    packageVersion = "24.4.0";
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js
var assert;
var init_assert = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js"() {
    assert = (value, message) => {
      if (!value) {
        throw new Error(message);
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/encoding.js
function stringToTypedArray(string, base64Encoded = false) {
  if (base64Encoded) {
    const binaryString = atob(string);
    return Uint8Array.from(binaryString, (m) => {
      return m.codePointAt(0);
    });
  }
  return new TextEncoder().encode(string);
}
function stringToBase64(str) {
  return typedArrayToBase64(new TextEncoder().encode(str));
}
function typedArrayToBase64(typedArray) {
  const chunkSize = 65534;
  const chunks = [];
  for (let i = 0; i < typedArray.length; i += chunkSize) {
    const chunk = typedArray.subarray(i, i + chunkSize);
    chunks.push(String.fromCodePoint.apply(null, chunk));
  }
  const binaryString = chunks.join("");
  return btoa(binaryString);
}
function mergeUint8Arrays(items) {
  let length = 0;
  for (const item of items) {
    length += item.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const item of items) {
    result.set(item, offset);
    offset += item.length;
  }
  return result;
}
var init_encoding = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/encoding.js"() {
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js
async function importDebug() {
  if (!debugModule) {
    debugModule = (await Promise.resolve().then(() => __toESM(require_browser(), 1))).default;
  }
  return debugModule;
}
var debugModule, debug, capturedLogs, captureLogs;
var init_Debug = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js"() {
    init_environment();
    debugModule = null;
    debug = (prefix) => {
      if (isNode) {
        return async (...logArgs) => {
          if (captureLogs) {
            capturedLogs.push(prefix + logArgs);
          }
          (await importDebug())(prefix)(logArgs);
        };
      }
      return (...logArgs) => {
        const debugLevel = globalThis.__PUPPETEER_DEBUG;
        if (!debugLevel) {
          return;
        }
        const everythingShouldBeLogged = debugLevel === "*";
        const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
         * If the debug level is `foo*`, that means we match any prefix that
         * starts with `foo`. If the level is `foo`, we match only the prefix
         * `foo`.
         */
        (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
        if (!prefixMatchesDebugLevel) {
          return;
        }
        console.log(`${prefix}:`, ...logArgs);
      };
    };
    capturedLogs = [];
    captureLogs = false;
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js
var PuppeteerError, TimeoutError, TouchError, ProtocolError, UnsupportedOperation, TargetCloseError;
var init_Errors = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js"() {
    PuppeteerError = class extends Error {
      /**
       * @internal
       */
      constructor(message, options) {
        super(message, options);
        this.name = this.constructor.name;
      }
      /**
       * @internal
       */
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    TimeoutError = class extends PuppeteerError {
    };
    TouchError = class extends PuppeteerError {
    };
    ProtocolError = class extends PuppeteerError {
      #code;
      #originalMessage = "";
      set code(code) {
        this.#code = code;
      }
      /**
       * @readonly
       * @public
       */
      get code() {
        return this.#code;
      }
      set originalMessage(originalMessage) {
        this.#originalMessage = originalMessage;
      }
      /**
       * @readonly
       * @public
       */
      get originalMessage() {
        return this.#originalMessage;
      }
    };
    UnsupportedOperation = class extends PuppeteerError {
    };
    TargetCloseError = class extends ProtocolError {
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js
var paperFormats;
var init_PDFOptions = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js"() {
    paperFormats = {
      letter: {
        cm: { width: 21.59, height: 27.94 },
        in: { width: 8.5, height: 11 }
      },
      legal: {
        cm: { width: 21.59, height: 35.56 },
        in: { width: 8.5, height: 14 }
      },
      tabloid: {
        cm: { width: 27.94, height: 43.18 },
        in: { width: 11, height: 17 }
      },
      ledger: {
        cm: { width: 43.18, height: 27.94 },
        in: { width: 17, height: 11 }
      },
      a0: {
        cm: { width: 84.1, height: 118.9 },
        in: { width: 33.1102, height: 46.811 }
      },
      a1: {
        cm: { width: 59.4, height: 84.1 },
        in: { width: 23.3858, height: 33.1102 }
      },
      a2: {
        cm: { width: 42, height: 59.4 },
        in: { width: 16.5354, height: 23.3858 }
      },
      a3: {
        cm: { width: 29.7, height: 42 },
        in: { width: 11.6929, height: 16.5354 }
      },
      a4: {
        cm: { width: 21, height: 29.7 },
        in: { width: 8.2677, height: 11.6929 }
      },
      a5: {
        cm: { width: 14.8, height: 21 },
        in: { width: 5.8268, height: 8.2677 }
      },
      a6: {
        cm: { width: 10.5, height: 14.8 },
        in: { width: 4.1339, height: 5.8268 }
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js
function evaluationString(fun, ...args) {
  if (isString(fun)) {
    assert(args.length === 0, "Cannot evaluate a string with arguments");
    return fun;
  }
  function serializeArgument(arg) {
    if (Object.is(arg, void 0)) {
      return "undefined";
    }
    return JSON.stringify(arg);
  }
  return `(${fun})(${args.map(serializeArgument).join(",")})`;
}
async function getReadableAsTypedArray(readable, path) {
  const buffers = [];
  const reader = readable.getReader();
  if (path) {
    const fileHandle = await environment.value.fs.promises.open(path, "w+");
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        buffers.push(value);
        await fileHandle.writeFile(value);
      }
    } finally {
      await fileHandle.close();
    }
  } else {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      buffers.push(value);
    }
  }
  try {
    const concat2 = mergeUint8Arrays(buffers);
    if (concat2.length === 0) {
      return null;
    }
    return concat2;
  } catch (error) {
    debugError(error);
    return null;
  }
}
async function getReadableFromProtocolStream(client, handle) {
  return new ReadableStream({
    async pull(controller) {
      function getUnit8Array(data2, isBase64) {
        if (isBase64) {
          return Uint8Array.from(atob(data2), (m) => {
            return m.codePointAt(0);
          });
        }
        const encoder = new TextEncoder();
        return encoder.encode(data2);
      }
      const { data, base64Encoded, eof } = await client.send("IO.read", {
        handle
      });
      controller.enqueue(getUnit8Array(data, base64Encoded ?? false));
      if (eof) {
        await client.send("IO.close", { handle });
        controller.close();
      }
    }
  });
}
function validateDialogType(type) {
  let dialogType = null;
  const validDialogTypes = /* @__PURE__ */ new Set([
    "alert",
    "confirm",
    "prompt",
    "beforeunload"
  ]);
  if (validDialogTypes.has(type)) {
    dialogType = type;
  }
  assert(dialogType, `Unknown javascript dialog type: ${type}`);
  return dialogType;
}
function timeout(ms, cause) {
  return ms === 0 ? NEVER : timer(ms).pipe(map(() => {
    throw new TimeoutError(`Timed out after waiting ${ms}ms`, { cause });
  }));
}
function getSourceUrlComment(url) {
  return `//# sourceURL=${url}`;
}
function parsePDFOptions(options = {}, lengthUnit = "in") {
  const defaults = {
    scale: 1,
    displayHeaderFooter: false,
    headerTemplate: "",
    footerTemplate: "",
    printBackground: false,
    landscape: false,
    pageRanges: "",
    preferCSSPageSize: false,
    omitBackground: false,
    outline: false,
    tagged: true,
    waitForFonts: true
  };
  let width = 8.5;
  let height = 11;
  if (options.format) {
    const format = paperFormats[options.format.toLowerCase()][lengthUnit];
    assert(format, "Unknown paper format: " + options.format);
    width = format.width;
    height = format.height;
  } else {
    width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
    height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;
  }
  const margin = {
    top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,
    left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,
    bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,
    right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0
  };
  if (options.outline) {
    options.tagged = true;
  }
  return {
    ...defaults,
    ...options,
    width,
    height,
    margin
  };
}
function convertPrintParameterToInches(parameter, lengthUnit = "in") {
  if (typeof parameter === "undefined") {
    return void 0;
  }
  let pixels;
  if (isNumber(parameter)) {
    pixels = parameter;
  } else if (isString(parameter)) {
    const text = parameter;
    let unit = text.substring(text.length - 2).toLowerCase();
    let valueText = "";
    if (unit in unitToPixels) {
      valueText = text.substring(0, text.length - 2);
    } else {
      unit = "px";
      valueText = text;
    }
    const value = Number(valueText);
    assert(!isNaN(value), "Failed to parse parameter value: " + text);
    pixels = value * unitToPixels[unit];
  } else {
    throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
  }
  return pixels / unitToPixels[lengthUnit];
}
function fromEmitterEvent(emitter, eventName) {
  return new Observable((subscriber) => {
    const listener = (event) => {
      subscriber.next(event);
    };
    emitter.on(eventName, listener);
    return () => {
      emitter.off(eventName, listener);
    };
  });
}
function fromAbortSignal(signal, cause) {
  return signal ? fromEvent(signal, "abort").pipe(map(() => {
    if (signal.reason instanceof Error) {
      signal.reason.cause = cause;
      throw signal.reason;
    }
    throw new Error(signal.reason, { cause });
  })) : NEVER;
}
function filterAsync(predicate) {
  return mergeMap((value) => {
    return from(Promise.resolve(predicate(value))).pipe(filter((isMatch) => {
      return isMatch;
    }), map(() => {
      return value;
    }));
  });
}
var debugError, DEFAULT_VIEWPORT, SOURCE_URL, _functionName, _siteString, _PuppeteerURL, PuppeteerURL, withSourcePuppeteerURLIfNone, getSourcePuppeteerURLIfAvailable, isString, isNumber, isPlainObject, isRegExp, isDate, UTILITY_WORLD_NAME, SOURCE_URL_REGEX, NETWORK_IDLE_TIME, unitToPixels;
var init_util = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js"() {
    init_rxjs();
    init_environment();
    init_version();
    init_assert();
    init_encoding();
    init_Debug();
    init_Errors();
    init_PDFOptions();
    debugError = debug("puppeteer:error");
    DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
    SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
    _PuppeteerURL = class {
      constructor() {
        __privateAdd(this, _functionName, void 0);
        __privateAdd(this, _siteString, void 0);
      }
      static fromCallSite(functionName, site) {
        const url = new _PuppeteerURL();
        __privateSet(url, _functionName, functionName);
        __privateSet(url, _siteString, site.toString());
        return url;
      }
      get functionName() {
        return __privateGet(this, _functionName);
      }
      get siteString() {
        return __privateGet(this, _siteString);
      }
      toString() {
        return `pptr:${[
          __privateGet(this, _functionName),
          encodeURIComponent(__privateGet(this, _siteString))
        ].join(";")}`;
      }
    };
    PuppeteerURL = _PuppeteerURL;
    _functionName = new WeakMap();
    _siteString = new WeakMap();
    __publicField(PuppeteerURL, "INTERNAL_URL", "pptr:internal");
    __publicField(PuppeteerURL, "parse", (url) => {
      url = url.slice("pptr:".length);
      const [functionName = "", siteString = ""] = url.split(";");
      const puppeteerUrl = new _PuppeteerURL();
      __privateSet(puppeteerUrl, _functionName, functionName);
      __privateSet(puppeteerUrl, _siteString, decodeURIComponent(siteString));
      return puppeteerUrl;
    });
    __publicField(PuppeteerURL, "isPuppeteerURL", (url) => {
      return url.startsWith("pptr:");
    });
    withSourcePuppeteerURLIfNone = (functionName, object) => {
      if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
        return object;
      }
      const original = Error.prepareStackTrace;
      Error.prepareStackTrace = (_, stack) => {
        return stack[2];
      };
      const site = new Error().stack;
      Error.prepareStackTrace = original;
      return Object.assign(object, {
        [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
      });
    };
    getSourcePuppeteerURLIfAvailable = (object) => {
      if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
        return object[SOURCE_URL];
      }
      return void 0;
    };
    isString = (obj) => {
      return typeof obj === "string" || obj instanceof String;
    };
    isNumber = (obj) => {
      return typeof obj === "number" || obj instanceof Number;
    };
    isPlainObject = (obj) => {
      return typeof obj === "object" && obj?.constructor === Object;
    };
    isRegExp = (obj) => {
      return typeof obj === "object" && obj?.constructor === RegExp;
    };
    isDate = (obj) => {
      return typeof obj === "object" && obj?.constructor === Date;
    };
    UTILITY_WORLD_NAME = "__puppeteer_utility_world__" + packageVersion;
    SOURCE_URL_REGEX = /^[\x20\t]*\/\/[@#] sourceURL=\s{0,10}(\S*?)\s{0,10}$/m;
    NETWORK_IDLE_TIME = 500;
    unitToPixels = {
      px: 1,
      in: 96,
      cm: 37.8,
      mm: 3.78
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js
var WEB_PERMISSION_TO_PROTOCOL_PERMISSION, Browser;
var init_Browser = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js"() {
    init_rxjs();
    init_EventEmitter();
    init_util();
    init_disposable();
    WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
      ["accelerometer", "sensors"],
      ["ambient-light-sensor", "sensors"],
      ["background-sync", "backgroundSync"],
      ["camera", "videoCapture"],
      ["clipboard-read", "clipboardReadWrite"],
      ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
      ["clipboard-write", "clipboardReadWrite"],
      ["geolocation", "geolocation"],
      ["gyroscope", "sensors"],
      ["idle-detection", "idleDetection"],
      ["keyboard-lock", "keyboardLock"],
      ["magnetometer", "sensors"],
      ["microphone", "audioCapture"],
      ["midi", "midi"],
      ["notifications", "notifications"],
      ["payment-handler", "paymentHandler"],
      ["persistent-storage", "durableStorage"],
      ["pointer-lock", "pointerLock"],
      // chrome-specific permissions we have.
      ["midi-sysex", "midiSysex"]
    ]);
    Browser = class extends EventEmitter {
      /**
       * @internal
       */
      constructor() {
        super();
      }
      /**
       * Waits until a {@link Target | target} matching the given `predicate`
       * appears and returns it.
       *
       * This will look all open {@link BrowserContext | browser contexts}.
       *
       * @example Finding a target for a page opened via `window.open`:
       *
       * ```ts
       * await page.evaluate(() => window.open('https://www.example.com/'));
       * const newWindowTarget = await browser.waitForTarget(
       *   target => target.url() === 'https://www.example.com/',
       * );
       * ```
       */
      async waitForTarget(predicate, options = {}) {
        const { timeout: ms = 3e4, signal } = options;
        return await firstValueFrom(merge(fromEmitterEvent(
          this,
          "targetcreated"
          /* BrowserEvent.TargetCreated */
        ), fromEmitterEvent(
          this,
          "targetchanged"
          /* BrowserEvent.TargetChanged */
        ), from(this.targets())).pipe(filterAsync(predicate), raceWith(fromAbortSignal(signal), timeout(ms))));
      }
      /**
       * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
       *
       * If there are multiple {@link BrowserContext | browser contexts}, this
       * returns all {@link Page | pages} in all
       * {@link BrowserContext | browser contexts}.
       *
       * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
       * will not be listed here. You can find them using {@link Target.page}.
       */
      async pages() {
        const contextPages = await Promise.all(this.browserContexts().map((context2) => {
          return context2.pages();
        }));
        return contextPages.reduce((acc, x) => {
          return acc.concat(x);
        }, []);
      }
      /**
       * Returns all cookies in the default {@link BrowserContext}.
       *
       * @remarks
       *
       * Shortcut for
       * {@link BrowserContext.cookies | browser.defaultBrowserContext().cookies()}.
       */
      async cookies() {
        return await this.defaultBrowserContext().cookies();
      }
      /**
       * Sets cookies in the default {@link BrowserContext}.
       *
       * @remarks
       *
       * Shortcut for
       * {@link BrowserContext.setCookie | browser.defaultBrowserContext().setCookie()}.
       */
      async setCookie(...cookies) {
        return await this.defaultBrowserContext().setCookie(...cookies);
      }
      /**
       * Removes cookies from the default {@link BrowserContext}.
       *
       * @remarks
       *
       * Shortcut for
       * {@link BrowserContext.deleteCookie | browser.defaultBrowserContext().deleteCookie()}.
       */
      async deleteCookie(...cookies) {
        return await this.defaultBrowserContext().deleteCookie(...cookies);
      }
      /**
       * Whether Puppeteer is connected to this {@link Browser | browser}.
       *
       * @deprecated Use {@link Browser | Browser.connected}.
       */
      isConnected() {
        return this.connected;
      }
      /** @internal */
      [disposeSymbol]() {
        if (this.process()) {
          return void this.close().catch(debugError);
        }
        return void this.disconnect().catch(debugError);
      }
      /** @internal */
      [asyncDisposeSymbol]() {
        if (this.process()) {
          return this.close();
        }
        return this.disconnect();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js
var Deferred;
var init_Deferred = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js"() {
    init_Errors();
    Deferred = class {
      static create(opts) {
        return new Deferred(opts);
      }
      static async race(awaitables) {
        const deferredWithTimeout = /* @__PURE__ */ new Set();
        try {
          const promises = awaitables.map((value) => {
            if (value instanceof Deferred) {
              if (value.#timeoutId) {
                deferredWithTimeout.add(value);
              }
              return value.valueOrThrow();
            }
            return value;
          });
          return await Promise.race(promises);
        } finally {
          for (const deferred of deferredWithTimeout) {
            deferred.reject(new Error("Timeout cleared"));
          }
        }
      }
      #isResolved = false;
      #isRejected = false;
      #value;
      // SAFETY: This is ensured by #taskPromise.
      #resolve;
      // TODO: Switch to Promise.withResolvers with Node 22
      #taskPromise = new Promise((resolve) => {
        this.#resolve = resolve;
      });
      #timeoutId;
      #timeoutError;
      constructor(opts) {
        if (opts && opts.timeout > 0) {
          this.#timeoutError = new TimeoutError(opts.message);
          this.#timeoutId = setTimeout(() => {
            this.reject(this.#timeoutError);
          }, opts.timeout);
        }
      }
      #finish(value) {
        clearTimeout(this.#timeoutId);
        this.#value = value;
        this.#resolve();
      }
      resolve(value) {
        if (this.#isRejected || this.#isResolved) {
          return;
        }
        this.#isResolved = true;
        this.#finish(value);
      }
      reject(error) {
        if (this.#isRejected || this.#isResolved) {
          return;
        }
        this.#isRejected = true;
        this.#finish(error);
      }
      resolved() {
        return this.#isResolved;
      }
      finished() {
        return this.#isResolved || this.#isRejected;
      }
      value() {
        return this.#value;
      }
      #promise;
      valueOrThrow() {
        if (!this.#promise) {
          this.#promise = (async () => {
            await this.#taskPromise;
            if (this.#isRejected) {
              throw this.#value;
            }
            return this.#value;
          })();
        }
        return this.#promise;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/Mutex.js
var _locked, _acquirers, _Mutex, Mutex;
var init_Mutex = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/Mutex.js"() {
    init_Deferred();
    init_disposable();
    _Mutex = class {
      constructor() {
        __privateAdd(this, _locked, false);
        __privateAdd(this, _acquirers, []);
      }
      // This is FIFO.
      async acquire(onRelease) {
        if (!__privateGet(this, _locked)) {
          __privateSet(this, _locked, true);
          return new _Mutex.Guard(this);
        }
        const deferred = Deferred.create();
        __privateGet(this, _acquirers).push(deferred.resolve.bind(deferred));
        await deferred.valueOrThrow();
        return new _Mutex.Guard(this, onRelease);
      }
      release() {
        const resolve = __privateGet(this, _acquirers).shift();
        if (!resolve) {
          __privateSet(this, _locked, false);
          return;
        }
        resolve();
      }
    };
    Mutex = _Mutex;
    _locked = new WeakMap();
    _acquirers = new WeakMap();
    __publicField(Mutex, "Guard", class Guard {
      #mutex;
      #onRelease;
      constructor(mutex, onRelease) {
        this.#mutex = mutex;
        this.#onRelease = onRelease;
      }
      [disposeSymbol]() {
        this.#onRelease?.();
        return this.#mutex.release();
      }
    });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js
var BrowserContext;
var init_BrowserContext = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js"() {
    init_rxjs();
    init_EventEmitter();
    init_util();
    init_disposable();
    init_Mutex();
    BrowserContext = class extends EventEmitter {
      /**
       * @internal
       */
      constructor() {
        super();
      }
      /**
       * If defined, indicates an ongoing screenshot opereation.
       */
      #pageScreenshotMutex;
      #screenshotOperationsCount = 0;
      /**
       * @internal
       */
      startScreenshot() {
        const mutex = this.#pageScreenshotMutex || new Mutex();
        this.#pageScreenshotMutex = mutex;
        this.#screenshotOperationsCount++;
        return mutex.acquire(() => {
          this.#screenshotOperationsCount--;
          if (this.#screenshotOperationsCount === 0) {
            this.#pageScreenshotMutex = void 0;
          }
        });
      }
      /**
       * @internal
       */
      waitForScreenshotOperations() {
        return this.#pageScreenshotMutex?.acquire();
      }
      /**
       * Waits until a {@link Target | target} matching the given `predicate`
       * appears and returns it.
       *
       * This will look all open {@link BrowserContext | browser contexts}.
       *
       * @example Finding a target for a page opened via `window.open`:
       *
       * ```ts
       * await page.evaluate(() => window.open('https://www.example.com/'));
       * const newWindowTarget = await browserContext.waitForTarget(
       *   target => target.url() === 'https://www.example.com/',
       * );
       * ```
       */
      async waitForTarget(predicate, options = {}) {
        const { timeout: ms = 3e4 } = options;
        return await firstValueFrom(merge(fromEmitterEvent(
          this,
          "targetcreated"
          /* BrowserContextEvent.TargetCreated */
        ), fromEmitterEvent(
          this,
          "targetchanged"
          /* BrowserContextEvent.TargetChanged */
        ), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms))));
      }
      /**
       * Removes cookie in the browser context
       * @param cookies - {@link Cookie | cookie} to remove
       */
      async deleteCookie(...cookies) {
        return await this.setCookie(...cookies.map((cookie) => {
          return {
            ...cookie,
            expires: 1
          };
        }));
      }
      /**
       * Whether this {@link BrowserContext | browser context} is closed.
       */
      get closed() {
        return !this.browser().browserContexts().includes(this);
      }
      /**
       * Identifier for this {@link BrowserContext | browser context}.
       */
      get id() {
        return void 0;
      }
      /** @internal */
      [disposeSymbol]() {
        return void this.close().catch(debugError);
      }
      /** @internal */
      [asyncDisposeSymbol]() {
        return this.close();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js
var CDPSessionEvent, CDPSession;
var init_CDPSession = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js"() {
    init_EventEmitter();
    (function(CDPSessionEvent2) {
      CDPSessionEvent2.Disconnected = Symbol("CDPSession.Disconnected");
      CDPSessionEvent2.Swapped = Symbol("CDPSession.Swapped");
      CDPSessionEvent2.Ready = Symbol("CDPSession.Ready");
      CDPSessionEvent2.SessionAttached = "sessionattached";
      CDPSessionEvent2.SessionDetached = "sessiondetached";
    })(CDPSessionEvent || (CDPSessionEvent = {}));
    CDPSession = class extends EventEmitter {
      /**
       * @internal
       */
      constructor() {
        super();
      }
      /**
       * Parent session in terms of CDP's auto-attach mechanism.
       *
       * @internal
       */
      parentSession() {
        return void 0;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js
var Dialog;
var init_Dialog = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js"() {
    init_assert();
    Dialog = class {
      #type;
      #message;
      #defaultValue;
      /**
       * @internal
       */
      handled = false;
      /**
       * @internal
       */
      constructor(type, message, defaultValue = "") {
        this.#type = type;
        this.#message = message;
        this.#defaultValue = defaultValue;
      }
      /**
       * The type of the dialog.
       */
      type() {
        return this.#type;
      }
      /**
       * The message displayed in the dialog.
       */
      message() {
        return this.#message;
      }
      /**
       * The default value of the prompt, or an empty string if the dialog
       * is not a `prompt`.
       */
      defaultValue() {
        return this.#defaultValue;
      }
      /**
       * A promise that resolves when the dialog has been accepted.
       *
       * @param promptText - optional text that will be entered in the dialog
       * prompt. Has no effect if the dialog's type is not `prompt`.
       *
       */
      async accept(promptText) {
        assert(!this.handled, "Cannot accept dialog which is already handled!");
        this.handled = true;
        await this.handle({
          accept: true,
          text: promptText
        });
      }
      /**
       * A promise which will resolve once the dialog has been dismissed
       */
      async dismiss() {
        assert(!this.handled, "Cannot dismiss dialog which is already handled!");
        this.handled = true;
        await this.handle({
          accept: false
        });
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js
var _isElementHandle;
var init_ElementHandleSymbol = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js"() {
    _isElementHandle = Symbol("_isElementHandle");
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
}
function rewriteError(error, message, originalMessage) {
  error.message = message;
  error.originalMessage = originalMessage ?? error.originalMessage;
  return error;
}
function createProtocolErrorMessage(object) {
  let message = object.error.message;
  if (object.error && typeof object.error === "object" && "data" in object.error) {
    message += ` ${object.error.data}`;
  }
  return message;
}
var init_ErrorLike = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js"() {
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js
function stringifyFunction(fn) {
  let value = fn.toString();
  try {
    new Function(`(${value})`);
  } catch (err) {
    if (err.message.includes(`Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive`)) {
      return value;
    }
    let prefix = "function ";
    if (value.startsWith("async ")) {
      prefix = `async ${prefix}`;
      value = value.substring("async ".length);
    }
    value = `${prefix}${value}`;
    try {
      new Function(`(${value})`);
    } catch {
      throw new Error("Passed function cannot be serialized!");
    }
  }
  return value;
}
var createdFunctions, createFunction, interpolateFunction;
var init_Function = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js"() {
    createdFunctions = /* @__PURE__ */ new Map();
    createFunction = (functionValue) => {
      let fn = createdFunctions.get(functionValue);
      if (fn) {
        return fn;
      }
      fn = new Function(`return ${functionValue}`)();
      createdFunctions.set(functionValue, fn);
      return fn;
    };
    interpolateFunction = (fn, replacements) => {
      let value = stringifyFunction(fn);
      for (const [name, jsValue] of Object.entries(replacements)) {
        value = value.replace(
          new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, "g"),
          // Wrapping this ensures tersers that accidentally inline PLACEHOLDER calls
          // are still valid. Without, we may get calls like ()=>{...}() which is
          // not valid.
          `(${jsValue})`
        );
      }
      return createFunction(value);
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js
async function* fastTransposeIteratorHandle(iterator2, size) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const array = __addDisposableResource(env_1, await iterator2.evaluateHandle(async (iterator3, size2) => {
      const results = [];
      while (results.length < size2) {
        const result = await iterator3.next();
        if (result.done) {
          break;
        }
        results.push(result.value);
      }
      return results;
    }, size), false);
    const properties = await array.getProperties();
    const handles = properties.values();
    const stack = __addDisposableResource(env_1, new DisposableStack(), false);
    stack.defer(() => {
      for (const handle_1 of handles) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource(env_2, handle_1, false);
          handle[disposeSymbol]();
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources(env_2);
        }
      }
    });
    yield* handles;
    return properties.size === 0;
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources(env_1);
  }
}
async function* transposeIteratorHandle(iterator2) {
  let size = DEFAULT_BATCH_SIZE;
  while (!(yield* fastTransposeIteratorHandle(iterator2, size))) {
    size <<= 1;
  }
}
async function* transposeIterableHandle(handle) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const generatorHandle = __addDisposableResource(env_3, await handle.evaluateHandle((iterable) => {
      return async function* () {
        yield* iterable;
      }();
    }), false);
    yield* transposeIteratorHandle(generatorHandle);
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    __disposeResources(env_3);
  }
}
var __addDisposableResource, __disposeResources, DEFAULT_BATCH_SIZE;
var init_HandleIterator = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js"() {
    init_disposable();
    __addDisposableResource = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    DEFAULT_BATCH_SIZE = 20;
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js
var _get, _LazyArg, LazyArg;
var init_LazyArg = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js"() {
    _LazyArg = class {
      constructor(get) {
        __privateAdd(this, _get, void 0);
        __privateSet(this, _get, get);
      }
      async get(context2) {
        return await __privateGet(this, _get).call(this, context2);
      }
    };
    LazyArg = _LazyArg;
    _get = new WeakMap();
    __publicField(LazyArg, "create", (get) => {
      return new _LazyArg(get);
    });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js
var __addDisposableResource2, __disposeResources2, QueryHandler;
var init_QueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js"() {
    init_ElementHandleSymbol();
    init_ErrorLike();
    init_Function();
    init_HandleIterator();
    init_LazyArg();
    __addDisposableResource2 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources2 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    QueryHandler = class {
      static get _querySelector() {
        if (this.querySelector) {
          return this.querySelector;
        }
        if (!this.querySelectorAll) {
          throw new Error("Cannot create default `querySelector`.");
        }
        return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
          const querySelectorAll = PLACEHOLDER("querySelectorAll");
          const results = querySelectorAll(node, selector, PuppeteerUtil);
          for await (const result of results) {
            return result;
          }
          return null;
        }, {
          querySelectorAll: stringifyFunction(this.querySelectorAll)
        });
      }
      static get _querySelectorAll() {
        if (this.querySelectorAll) {
          return this.querySelectorAll;
        }
        if (!this.querySelector) {
          throw new Error("Cannot create default `querySelectorAll`.");
        }
        return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
          const querySelector = PLACEHOLDER("querySelector");
          const result = await querySelector(node, selector, PuppeteerUtil);
          if (result) {
            yield result;
          }
        }, {
          querySelector: stringifyFunction(this.querySelector)
        });
      }
      /**
       * Queries for multiple nodes given a selector and {@link ElementHandle}.
       *
       * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
       */
      static async *queryAll(element, selector) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource2(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context2) => {
            return context2.puppeteerUtil;
          })), false);
          yield* transposeIterableHandle(handle);
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources2(env_1);
        }
      }
      /**
       * Queries for a single node given a selector and {@link ElementHandle}.
       *
       * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
       */
      static async queryOne(element, selector) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          const result = __addDisposableResource2(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create((context2) => {
            return context2.puppeteerUtil;
          })), false);
          if (!(_isElementHandle in result)) {
            return null;
          }
          return result.move();
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources2(env_2);
        }
      }
      /**
       * Waits until a single node appears for a given selector and
       * {@link ElementHandle}.
       *
       * This will always query the handle in the Puppeteer world and migrate the
       * result to the main world.
       */
      static async waitFor(elementOrFrame, selector, options) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
          let frame;
          const element = __addDisposableResource2(env_3, await (async () => {
            if (!(_isElementHandle in elementOrFrame)) {
              frame = elementOrFrame;
              return;
            }
            frame = elementOrFrame.frame;
            return await frame.isolatedRealm().adoptHandle(elementOrFrame);
          })(), false);
          const { visible = false, hidden = false, timeout: timeout2, signal } = options;
          const polling = visible || hidden ? "raf" : options.polling;
          try {
            const env_4 = { stack: [], error: void 0, hasError: false };
            try {
              signal?.throwIfAborted();
              const handle = __addDisposableResource2(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
                const querySelector = PuppeteerUtil.createFunction(query);
                const node = await querySelector(root ?? document, selector2, PuppeteerUtil);
                return PuppeteerUtil.checkVisibility(node, visible2);
              }, {
                polling,
                root: element,
                timeout: timeout2,
                signal
              }, LazyArg.create((context2) => {
                return context2.puppeteerUtil;
              }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : void 0), false);
              if (signal?.aborted) {
                throw signal.reason;
              }
              if (!(_isElementHandle in handle)) {
                return null;
              }
              return await frame.mainRealm().transferHandle(handle);
            } catch (e_3) {
              env_4.error = e_3;
              env_4.hasError = true;
            } finally {
              __disposeResources2(env_4);
            }
          } catch (error) {
            if (!isErrorLike(error)) {
              throw error;
            }
            if (error.name === "AbortError") {
              throw error;
            }
            error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
            throw error;
          }
        } catch (e_4) {
          env_3.error = e_4;
          env_3.hasError = true;
        } finally {
          __disposeResources2(env_3);
        }
      }
    };
    // Either one of these may be implemented, but at least one must be.
    __publicField(QueryHandler, "querySelectorAll");
    __publicField(QueryHandler, "querySelector");
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js
var AsyncIterableUtil;
var init_AsyncIterableUtil = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js"() {
    AsyncIterableUtil = class {
      static async *map(iterable, map2) {
        for await (const value of iterable) {
          yield await map2(value);
        }
      }
      static async *flatMap(iterable, map2) {
        for await (const value of iterable) {
          yield* map2(value);
        }
      }
      static async collect(iterable) {
        const result = [];
        for await (const value of iterable) {
          result.push(value);
        }
        return result;
      }
      static async first(iterable) {
        for await (const value of iterable) {
          return value;
        }
        return;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js
var isKnownAttribute, ATTRIBUTE_REGEXP, parseARIASelector, _ARIAQueryHandler, ARIAQueryHandler;
var init_AriaQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js"() {
    init_QueryHandler();
    init_assert();
    init_AsyncIterableUtil();
    isKnownAttribute = (attribute) => {
      return ["name", "role"].includes(attribute);
    };
    ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
    parseARIASelector = (selector) => {
      if (selector.length > 1e4) {
        throw new Error(`Selector ${selector} is too long`);
      }
      const queryOptions = {};
      const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
        assert(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
        queryOptions[attribute] = value;
        return "";
      });
      if (defaultName && !queryOptions.name) {
        queryOptions.name = defaultName;
      }
      return queryOptions;
    };
    _ARIAQueryHandler = class extends QueryHandler {
      static async *queryAll(element, selector) {
        const { name, role } = parseARIASelector(selector);
        yield* element.queryAXTree(name, role);
      }
    };
    ARIAQueryHandler = _ARIAQueryHandler;
    __publicField(ARIAQueryHandler, "querySelector", async (node, selector, { ariaQuerySelector }) => {
      return await ariaQuerySelector(node, selector);
    });
    __publicField(ARIAQueryHandler, "queryOne", async (element, selector) => {
      return await AsyncIterableUtil.first(_ARIAQueryHandler.queryAll(element, selector)) ?? null;
    });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/CSSQueryHandler.js
var CSSQueryHandler;
var init_CSSQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/CSSQueryHandler.js"() {
    init_QueryHandler();
    CSSQueryHandler = class extends QueryHandler {
    };
    __publicField(CSSQueryHandler, "querySelector", (element, selector, { cssQuerySelector }) => {
      return cssQuerySelector(element, selector);
    });
    __publicField(CSSQueryHandler, "querySelectorAll", (element, selector, { cssQuerySelectorAll }) => {
      return cssQuerySelectorAll(element, selector);
    });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/generated/injected.js
var source;
var init_injected = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/generated/injected.js"() {
    source = '"use strict";var g=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var l=(t,e)=>{for(var r in e)g(t,r,{get:e[r],enumerable:!0})},J=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of B(e))!Y.call(t,n)&&n!==r&&g(t,n,{get:()=>e[n],enumerable:!(o=X(e,n))||o.enumerable});return t};var z=t=>J(g({},"__esModule",{value:!0}),t);var pe={};l(pe,{default:()=>he});module.exports=z(pe);var N=class extends Error{constructor(e,r){super(e,r),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},p=class extends N{};var c=class t{static create(e){return new t(e)}static async race(e){let r=new Set;try{let o=e.map(n=>n instanceof t?(n.#n&&r.add(n),n.valueOrThrow()):n);return await Promise.race(o)}finally{for(let o of r)o.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#o;#t;#a=new Promise(e=>{this.#t=e});#n;#i;constructor(e){e&&e.timeout>0&&(this.#i=new p(e.message),this.#n=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#n),this.#o=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#o}#s;valueOrThrow(){return this.#s||(this.#s=(async()=>{if(await this.#a,this.#r)throw this.#o;return this.#o})()),this.#s}};var L=new Map,F=t=>{let e=L.get(t);return e||(e=new Function(`return ${t}`)(),L.set(t,e),e)};var x={};l(x,{ariaQuerySelector:()=>G,ariaQuerySelectorAll:()=>b});var G=(t,e)=>globalThis.__ariaQuerySelector(t,e),b=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var E={};l(E,{cssQuerySelector:()=>K,cssQuerySelectorAll:()=>Z});var K=(t,e)=>t.querySelector(e),Z=function(t,e){return t.querySelectorAll(e)};var A={};l(A,{customQuerySelectors:()=>P});var v=class{#e=new Map;register(e,r){if(!r.queryOne&&r.queryAll){let o=r.queryAll;r.queryOne=(n,i)=>{for(let s of o(n,i))return s;return null}}else if(r.queryOne&&!r.queryAll){let o=r.queryOne;r.queryAll=(n,i)=>{let s=o(n,i);return s?[s]:[]}}else if(!r.queryOne||!r.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:r.queryOne,querySelectorAll:r.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},P=new v;var R={};l(R,{pierceQuerySelector:()=>ee,pierceQuerySelectorAll:()=>te});var ee=(t,e)=>{let r=null,o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&!r&&s.matches(e)&&(r=s)}while(!r&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r},te=(t,e)=>{let r=[],o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&s.matches(e)&&r.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r};var u=(t,e)=>{if(!t)throw new Error(e)};var y=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=new MutationObserver(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())}),this.#o.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(this.#o.disconnect(),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}},w=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=c.create(),r=await this.#e();if(r){e.resolve(r);return}let o=async()=>{if(e.finished())return;let n=await this.#e();if(!n){window.requestAnimationFrame(o);return}e.resolve(n),await this.stop()};window.requestAnimationFrame(o)}async stop(){u(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return u(this.#r,"Polling never started."),this.#r.valueOrThrow()}},S=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=setInterval(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())},this.#r)}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(clearInterval(this.#o),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var _={};l(_,{PCombinator:()=>H,pQuerySelector:()=>fe,pQuerySelectorAll:()=>$});var a=class{static async*map(e,r){for await(let o of e)yield await r(o)}static async*flatMap(e,r){for await(let o of e)yield*r(o)}static async collect(e){let r=[];for await(let o of e)r.push(o);return r}static async first(e){for await(let r of e)return r}};var C={};l(C,{textQuerySelectorAll:()=>m});var re=new Set(["checkbox","image","radio"]),oe=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!re.has(t.type),ne=new Set(["SCRIPT","STYLE"]),f=t=>!ne.has(t.nodeName)&&!document.head?.contains(t),I=new WeakMap,j=t=>{for(;t;)I.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},W=new WeakSet,se=new MutationObserver(t=>{for(let e of t)j(e.target)}),d=t=>{let e=I.get(t);if(e||(e={full:"",immediate:[]},!f(t)))return e;let r="";if(oe(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",o=>{j(o.target)},{once:!0,capture:!0});else{for(let o=t.firstChild;o;o=o.nextSibling){if(o.nodeType===Node.TEXT_NODE){e.full+=o.nodeValue??"",r+=o.nodeValue??"";continue}r&&e.immediate.push(r),r="",o.nodeType===Node.ELEMENT_NODE&&(e.full+=d(o).full)}r&&e.immediate.push(r),t instanceof Element&&t.shadowRoot&&(e.full+=d(t.shadowRoot).full),W.has(t)||(se.observe(t,{childList:!0,characterData:!0,subtree:!0}),W.add(t))}return I.set(t,e),e};var m=function*(t,e){let r=!1;for(let o of t.childNodes)if(o instanceof Element&&f(o)){let n;o.shadowRoot?n=m(o.shadowRoot,e):n=m(o,e);for(let i of n)yield i,r=!0}r||t instanceof Element&&f(t)&&d(t).full.includes(e)&&(yield t)};var k={};l(k,{checkVisibility:()=>le,pierce:()=>T,pierceAll:()=>O});var ie=["hidden","collapse"],le=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let r=t.nodeType===Node.TEXT_NODE?t.parentElement:t,o=window.getComputedStyle(r),n=o&&!ie.includes(o.visibility)&&!ae(r);return e===n?t:!1};function ae(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var ce=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*T(t){ce(t)?yield t.shadowRoot:yield t}function*O(t){t=T(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let r of e){let o;for(;o=r.nextNode();)o.shadowRoot&&(yield o.shadowRoot,e.push(document.createTreeWalker(o.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var Q={};l(Q,{xpathQuerySelectorAll:()=>q});var q=function*(t,e,r=-1){let n=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=n.iterateNext())&&(i.push(s),!(r&&i.length===r)););for(let h=0;h<i.length;h++)s=i[h],yield s,delete i[h]};var ue=/[-\\w\\P{ASCII}*]/u,H=(r=>(r.Descendent=">>>",r.Child=">>>>",r))(H||{}),V=t=>"querySelectorAll"in t,M=class{#e;#r=[];#o=void 0;elements;constructor(e,r){this.elements=[e],this.#e=r,this.#t()}async run(){if(typeof this.#o=="string")switch(this.#o.trimStart()){case":scope":this.#t();break}for(;this.#o!==void 0;this.#t()){let e=this.#o;typeof e=="string"?e[0]&&ue.test(e[0])?this.elements=a.flatMap(this.elements,async function*(r){V(r)&&(yield*r.querySelectorAll(e))}):this.elements=a.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!V(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let n of r.parentElement.children)if(++o,n===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=a.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*m(r,e.value);break;case"xpath":yield*q(r,e.value);break;case"aria":yield*b(r,e.value);break;default:let o=P.get(e.name);if(!o)throw new Error(`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#t(){if(this.#r.length!==0){this.#o=this.#r.shift();return}if(this.#e.length===0){this.#o=void 0;return}let e=this.#e.shift();switch(e){case">>>>":{this.elements=a.flatMap(this.elements,T),this.#t();break}case">>>":{this.elements=a.flatMap(this.elements,O),this.#t();break}default:this.#r=e,this.#t();break}}},D=class{#e=new WeakMap;calculate(e,r=[]){if(e===null)return r;e instanceof ShadowRoot&&(e=e.host);let o=this.#e.get(e);if(o)return[...o,...r];let n=0;for(let s=e.previousSibling;s;s=s.previousSibling)++n;let i=this.calculate(e.parentNode,[n]);return this.#e.set(e,i),[...i,...r]}},U=(t,e)=>{if(t.length+e.length===0)return 0;let[r=-1,...o]=t,[n=-1,...i]=e;return r===n?U(o,i):r<n?-1:1},de=async function*(t){let e=new Set;for await(let o of t)e.add(o);let r=new D;yield*[...e.values()].map(o=>[o,r.calculate(o)]).sort(([,o],[,n])=>U(o,n)).map(([o])=>o)},$=function(t,e){let r=JSON.parse(e);if(r.some(o=>{let n=0;return o.some(i=>(typeof i=="string"?++n:n=0,n>1))}))throw new Error("Multiple deep combinators found in sequence.");return de(a.flatMap(r,o=>{let n=new M(t,o);return n.run(),n.elements}))},fe=async function(t,e){for await(let r of $(t,e))return r;return null};var me=Object.freeze({...x,...A,...R,..._,...C,...k,...Q,...E,Deferred:c,createFunction:F,createTextContent:d,IntervalPoller:S,isSuitableNodeForTextMatching:f,MutationPoller:y,RAFPoller:w}),he=me;\n';
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js
var ScriptInjector, scriptInjector;
var init_ScriptInjector = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js"() {
    init_injected();
    ScriptInjector = class {
      #updated = false;
      #amendments = /* @__PURE__ */ new Set();
      // Appends a statement of the form `(PuppeteerUtil) => {...}`.
      append(statement) {
        this.#update(() => {
          this.#amendments.add(statement);
        });
      }
      pop(statement) {
        this.#update(() => {
          this.#amendments.delete(statement);
        });
      }
      inject(inject, force = false) {
        if (this.#updated || force) {
          inject(this.#get());
        }
        this.#updated = false;
      }
      #update(callback) {
        callback();
        this.#updated = true;
      }
      #get() {
        return `(() => {
      const module = {};
      ${source}
      ${[...this.#amendments].map((statement) => {
          return `(${statement})(module.exports.default);`;
        }).join("")}
      return module.exports.default;
    })()`;
      }
    };
    scriptInjector = new ScriptInjector();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js
var CustomQueryHandlerRegistry, customQueryHandlers;
var init_CustomQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js"() {
    init_assert();
    init_Function();
    init_QueryHandler();
    init_ScriptInjector();
    CustomQueryHandlerRegistry = class {
      #handlers = /* @__PURE__ */ new Map();
      get(name) {
        const handler = this.#handlers.get(name);
        return handler ? handler[1] : void 0;
      }
      /**
       * Registers a {@link CustomQueryHandler | custom query handler}.
       *
       * @remarks
       * After registration, the handler can be used everywhere where a selector is
       * expected by prepending the selection string with `<name>/`. The name is
       * only allowed to consist of lower- and upper case latin letters.
       *
       * @example
       *
       * ```ts
       * Puppeteer.customQueryHandlers.register('lit', { … });
       * const aHandle = await page.$('lit/…');
       * ```
       *
       * @param name - Name to register under.
       * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
       * register.
       */
      register(name, handler) {
        assert(!this.#handlers.has(name), `Cannot register over existing handler: ${name}`);
        assert(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
        assert(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
        const Handler = class extends QueryHandler {
          static querySelectorAll = interpolateFunction((node, selector, PuppeteerUtil) => {
            return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
          }, { name: JSON.stringify(name) });
          static querySelector = interpolateFunction((node, selector, PuppeteerUtil) => {
            return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
          }, { name: JSON.stringify(name) });
        };
        const registerScript = interpolateFunction((PuppeteerUtil) => {
          PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
            queryAll: PLACEHOLDER("queryAll"),
            queryOne: PLACEHOLDER("queryOne")
          });
        }, {
          name: JSON.stringify(name),
          queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
          queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
        }).toString();
        this.#handlers.set(name, [registerScript, Handler]);
        scriptInjector.append(registerScript);
      }
      /**
       * Unregisters the {@link CustomQueryHandler | custom query handler} for the
       * given name.
       *
       * @throws `Error` if there is no handler under the given name.
       */
      unregister(name) {
        const handler = this.#handlers.get(name);
        if (!handler) {
          throw new Error(`Cannot unregister unknown handler: ${name}`);
        }
        scriptInjector.pop(handler[0]);
        this.#handlers.delete(name);
      }
      /**
       * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
       */
      names() {
        return [...this.#handlers.keys()];
      }
      /**
       * Unregisters all custom query handlers.
       */
      clear() {
        for (const [registerScript] of this.#handlers) {
          scriptInjector.pop(registerScript);
        }
        this.#handlers.clear();
      }
    };
    customQueryHandlers = new CustomQueryHandlerRegistry();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js
var PierceQueryHandler;
var init_PierceQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js"() {
    init_QueryHandler();
    PierceQueryHandler = class extends QueryHandler {
    };
    __publicField(PierceQueryHandler, "querySelector", (element, selector, { pierceQuerySelector }) => {
      return pierceQuerySelector(element, selector);
    });
    __publicField(PierceQueryHandler, "querySelectorAll", (element, selector, { pierceQuerySelectorAll }) => {
      return pierceQuerySelectorAll(element, selector);
    });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js
var PQueryHandler;
var init_PQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js"() {
    init_QueryHandler();
    PQueryHandler = class extends QueryHandler {
    };
    __publicField(PQueryHandler, "querySelectorAll", (element, selector, { pQuerySelectorAll }) => {
      return pQuerySelectorAll(element, selector);
    });
    __publicField(PQueryHandler, "querySelector", (element, selector, { pQuerySelector }) => {
      return pQuerySelector(element, selector);
    });
  }
});

// node_modules/puppeteer-core/lib/esm/third_party/parsel-js/parsel-js.js
function gobbleParens(text, offset) {
  let nesting = 0;
  let result = "";
  for (; offset < text.length; offset++) {
    const char = text[offset];
    switch (char) {
      case "(":
        ++nesting;
        break;
      case ")":
        --nesting;
        break;
    }
    result += char;
    if (nesting === 0) {
      return result;
    }
  }
  return result;
}
function tokenizeBy(text, grammar = TOKENS) {
  if (!text) {
    return [];
  }
  const tokens = [text];
  for (const [type, pattern] of Object.entries(grammar)) {
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (typeof token !== "string") {
        continue;
      }
      pattern.lastIndex = 0;
      const match = pattern.exec(token);
      if (!match) {
        continue;
      }
      const from2 = match.index - 1;
      const args = [];
      const content = match[0];
      const before = token.slice(0, from2 + 1);
      if (before) {
        args.push(before);
      }
      args.push({
        ...match.groups,
        type,
        content
      });
      const after = token.slice(from2 + content.length + 1);
      if (after) {
        args.push(after);
      }
      tokens.splice(i, 1, ...args);
    }
  }
  let offset = 0;
  for (const token of tokens) {
    switch (typeof token) {
      case "string":
        throw new Error(`Unexpected sequence ${token} found at index ${offset}`);
      case "object":
        offset += token.content.length;
        token.pos = [offset - token.content.length, offset];
        if (TRIM_TOKENS.has(token.type)) {
          token.content = token.content.trim() || " ";
        }
        break;
    }
  }
  return tokens;
}
function tokenize(selector, grammar = TOKENS) {
  selector = selector.trim();
  if (selector === "") {
    return [];
  }
  const replacements = [];
  selector = selector.replace(ESCAPE_PATTERN, (value, offset) => {
    replacements.push({ value, offset });
    return "\uE000".repeat(value.length);
  });
  selector = selector.replace(STRING_PATTERN, (value, quote, content, offset) => {
    replacements.push({ value, offset });
    return `${quote}${"\uE001".repeat(content.length)}${quote}`;
  });
  {
    let pos = 0;
    let offset;
    while ((offset = selector.indexOf("(", pos)) > -1) {
      const value = gobbleParens(selector, offset);
      replacements.push({ value, offset });
      selector = `${selector.substring(0, offset)}(${"\xB6".repeat(value.length - 2)})${selector.substring(offset + value.length)}`;
      pos = offset + value.length;
    }
  }
  const tokens = tokenizeBy(selector, grammar);
  const changedTokens = /* @__PURE__ */ new Set();
  for (const replacement of replacements.reverse()) {
    for (const token of tokens) {
      const { offset, value } = replacement;
      if (!(token.pos[0] <= offset && offset + value.length <= token.pos[1])) {
        continue;
      }
      const { content } = token;
      const tokenOffset = offset - token.pos[0];
      token.content = content.slice(0, tokenOffset) + value + content.slice(tokenOffset + value.length);
      if (token.content !== content) {
        changedTokens.add(token);
      }
    }
  }
  for (const token of changedTokens) {
    const pattern = getArgumentPatternByType(token.type);
    if (!pattern) {
      throw new Error(`Unknown token type: ${token.type}`);
    }
    pattern.lastIndex = 0;
    const match = pattern.exec(token.content);
    if (!match) {
      throw new Error(`Unable to parse content for ${token.type}: ${token.content}`);
    }
    Object.assign(token, match.groups);
  }
  return tokens;
}
function stringify(listOrNode) {
  if (Array.isArray(listOrNode)) {
    return listOrNode.map((token) => token.content).join("");
  }
  switch (listOrNode.type) {
    case "list":
      return listOrNode.list.map(stringify).join(",");
    case "relative":
      return listOrNode.combinator + stringify(listOrNode.right);
    case "complex":
      return stringify(listOrNode.left) + listOrNode.combinator + stringify(listOrNode.right);
    case "compound":
      return listOrNode.list.map(stringify).join("");
    default:
      return listOrNode.content;
  }
}
var TOKENS, TRIM_TOKENS, getArgumentPatternByType, STRING_PATTERN, ESCAPE_PATTERN;
var init_parsel_js = __esm({
  "node_modules/puppeteer-core/lib/esm/third_party/parsel-js/parsel-js.js"() {
    TOKENS = {
      attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
      id: /#(?<name>[-\w\P{ASCII}]+)/gu,
      class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
      comma: /\s*,\s*/g,
      combinator: /\s*[\s>+~]\s*/g,
      "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,
      "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,
      universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
      type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
      // this must be last
    };
    TRIM_TOKENS = /* @__PURE__ */ new Set(["combinator", "comma"]);
    getArgumentPatternByType = (type) => {
      switch (type) {
        case "pseudo-element":
        case "pseudo-class":
          return new RegExp(TOKENS[type].source.replace("(?<argument>\xB6*)", "(?<argument>.*)"), "gu");
        default:
          return TOKENS[type];
      }
    };
    STRING_PATTERN = /(['"])([^\\\n]+?)\1/g;
    ESCAPE_PATTERN = /\\./g;
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PSelectorParser.js
function parsePSelectors(selector) {
  let isPureCSS = true;
  let hasAria = false;
  let hasPseudoClasses = false;
  const tokens = tokenize(selector);
  if (tokens.length === 0) {
    return [[], isPureCSS, hasPseudoClasses, false];
  }
  let compoundSelector = [];
  let complexSelector = [compoundSelector];
  const selectors = [complexSelector];
  const storage = [];
  for (const token of tokens) {
    switch (token.type) {
      case "combinator":
        switch (token.content) {
          case ">>>":
            isPureCSS = false;
            if (storage.length) {
              compoundSelector.push(stringify(storage));
              storage.splice(0);
            }
            compoundSelector = [];
            complexSelector.push(
              ">>>"
              /* PCombinator.Descendent */
            );
            complexSelector.push(compoundSelector);
            continue;
          case ">>>>":
            isPureCSS = false;
            if (storage.length) {
              compoundSelector.push(stringify(storage));
              storage.splice(0);
            }
            compoundSelector = [];
            complexSelector.push(
              ">>>>"
              /* PCombinator.Child */
            );
            complexSelector.push(compoundSelector);
            continue;
        }
        break;
      case "pseudo-element":
        if (!token.name.startsWith("-p-")) {
          break;
        }
        isPureCSS = false;
        if (storage.length) {
          compoundSelector.push(stringify(storage));
          storage.splice(0);
        }
        const name = token.name.slice(3);
        if (name === "aria") {
          hasAria = true;
        }
        compoundSelector.push({
          name,
          value: unquote(token.argument ?? "")
        });
        continue;
      case "pseudo-class":
        hasPseudoClasses = true;
        break;
      case "comma":
        if (storage.length) {
          compoundSelector.push(stringify(storage));
          storage.splice(0);
        }
        compoundSelector = [];
        complexSelector = [compoundSelector];
        selectors.push(complexSelector);
        continue;
    }
    storage.push(token);
  }
  if (storage.length) {
    compoundSelector.push(stringify(storage));
  }
  return [selectors, isPureCSS, hasPseudoClasses, hasAria];
}
var ESCAPE_REGEXP, unquote;
var init_PSelectorParser = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/PSelectorParser.js"() {
    init_parsel_js();
    TOKENS["nesting"] = /&/g;
    TOKENS["combinator"] = /\s*(>>>>?|[\s>+~])\s*/g;
    ESCAPE_REGEXP = /\\[\s\S]/g;
    unquote = (text) => {
      if (text.length <= 1) {
        return text;
      }
      if ((text[0] === '"' || text[0] === "'") && text.endsWith(text[0])) {
        text = text.slice(1, -1);
      }
      return text.replace(ESCAPE_REGEXP, (match) => {
        return match[1];
      });
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js
var TextQueryHandler;
var init_TextQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js"() {
    init_QueryHandler();
    TextQueryHandler = class extends QueryHandler {
    };
    __publicField(TextQueryHandler, "querySelectorAll", (element, selector, { textQuerySelectorAll }) => {
      return textQuerySelectorAll(element, selector);
    });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js
var XPathQueryHandler;
var init_XPathQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js"() {
    init_QueryHandler();
    XPathQueryHandler = class extends QueryHandler {
    };
    __publicField(XPathQueryHandler, "querySelectorAll", (element, selector, { xpathQuerySelectorAll }) => {
      return xpathQuerySelectorAll(element, selector);
    });
    __publicField(XPathQueryHandler, "querySelector", (element, selector, { xpathQuerySelectorAll }) => {
      for (const result of xpathQuerySelectorAll(element, selector, 1)) {
        return result;
      }
      return null;
    });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js
function getQueryHandlerAndSelector(selector) {
  for (const handlerMap of [
    customQueryHandlers.names().map((name) => {
      return [name, customQueryHandlers.get(name)];
    }),
    Object.entries(BUILTIN_QUERY_HANDLERS)
  ]) {
    for (const [name, QueryHandler2] of handlerMap) {
      for (const separator of QUERY_SEPARATORS) {
        const prefix = `${name}${separator}`;
        if (selector.startsWith(prefix)) {
          selector = selector.slice(prefix.length);
          return {
            updatedSelector: selector,
            polling: name === "aria" ? "raf" : "mutation",
            QueryHandler: QueryHandler2
          };
        }
      }
    }
  }
  try {
    const [pSelector, isPureCSS, hasPseudoClasses, hasAria] = parsePSelectors(selector);
    if (isPureCSS) {
      return {
        updatedSelector: selector,
        polling: hasPseudoClasses ? "raf" : "mutation",
        QueryHandler: CSSQueryHandler
      };
    }
    return {
      updatedSelector: JSON.stringify(pSelector),
      polling: hasAria ? "raf" : "mutation",
      QueryHandler: PQueryHandler
    };
  } catch {
    return {
      updatedSelector: selector,
      polling: "mutation",
      QueryHandler: CSSQueryHandler
    };
  }
}
var BUILTIN_QUERY_HANDLERS, QUERY_SEPARATORS;
var init_GetQueryHandler = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js"() {
    init_AriaQueryHandler();
    init_CSSQueryHandler();
    init_CustomQueryHandler();
    init_PierceQueryHandler();
    init_PQueryHandler();
    init_PSelectorParser();
    init_TextQueryHandler();
    init_XPathQueryHandler();
    BUILTIN_QUERY_HANDLERS = {
      aria: ARIAQueryHandler,
      pierce: PierceQueryHandler,
      xpath: XPathQueryHandler,
      text: TextQueryHandler
    };
    QUERY_SEPARATORS = ["=", "/"];
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js
function moveable(Class, _) {
  let hasDispose = false;
  if (Class.prototype[disposeSymbol]) {
    const dispose = Class.prototype[disposeSymbol];
    Class.prototype[disposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return dispose.call(this);
    };
    hasDispose = true;
  }
  if (Class.prototype[asyncDisposeSymbol]) {
    const asyncDispose = Class.prototype[asyncDisposeSymbol];
    Class.prototype[asyncDisposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return asyncDispose.call(this);
    };
    hasDispose = true;
  }
  if (hasDispose) {
    Class.prototype.move = function() {
      instances.add(this);
      return this;
    };
  }
  return Class;
}
function throwIfDisposed(message = (value) => {
  return `Attempted to use disposed ${value.constructor.name}.`;
}) {
  return (target, _) => {
    return function(...args) {
      if (this.disposed) {
        throw new Error(message(this));
      }
      return target.call(this, ...args);
    };
  };
}
function inertIfDisposed(target, _) {
  return function(...args) {
    if (this.disposed) {
      return;
    }
    return target.call(this, ...args);
  };
}
function invokeAtMostOnceForArguments(target, _) {
  const cache = /* @__PURE__ */ new WeakMap();
  let cacheDepth = -1;
  return function(...args) {
    if (cacheDepth === -1) {
      cacheDepth = args.length;
    }
    if (cacheDepth !== args.length) {
      throw new Error("Memoized method was called with the wrong number of arguments");
    }
    let freshArguments = false;
    let cacheIterator = cache;
    for (const arg of args) {
      if (cacheIterator.has(arg)) {
        cacheIterator = cacheIterator.get(arg);
      } else {
        freshArguments = true;
        cacheIterator.set(arg, /* @__PURE__ */ new WeakMap());
        cacheIterator = cacheIterator.get(arg);
      }
    }
    if (!freshArguments) {
      return;
    }
    return target.call(this, ...args);
  };
}
function guarded(getKey = function() {
  return this;
}) {
  return (target, _) => {
    const mutexes = /* @__PURE__ */ new WeakMap();
    return async function(...args) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const key = getKey.call(this);
        let mutex = mutexes.get(key);
        if (!mutex) {
          mutex = new Mutex();
          mutexes.set(key, mutex);
        }
        const _2 = __addDisposableResource3(env_1, await mutex.acquire(), true);
        return await target.call(this, ...args);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        const result_1 = __disposeResources3(env_1);
        if (result_1)
          await result_1;
      }
    };
  };
}
function bubble(events) {
  return ({ set, get }, context2) => {
    context2.addInitializer(function() {
      return bubbleInitializer.apply(this, [events]);
    });
    return {
      set(emitter) {
        const handler = bubbleHandlers.get(this).get(events);
        const oldEmitter = get.call(this);
        if (oldEmitter !== void 0) {
          oldEmitter.off("*", handler);
        }
        if (emitter === void 0) {
          return;
        }
        emitter.on("*", handler);
        set.call(this, emitter);
      },
      init(emitter) {
        if (emitter === void 0) {
          return emitter;
        }
        bubbleInitializer.apply(this, [events]);
        const handler = bubbleHandlers.get(this).get(events);
        emitter.on("*", handler);
        return emitter;
      }
    };
  };
}
var __addDisposableResource3, __disposeResources3, instances, bubbleHandlers, bubbleInitializer;
var init_decorators = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js"() {
    init_disposable();
    init_Mutex();
    __addDisposableResource3 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources3 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    instances = /* @__PURE__ */ new WeakSet();
    bubbleHandlers = /* @__PURE__ */ new WeakMap();
    bubbleInitializer = function(events) {
      const handlers = bubbleHandlers.get(this) ?? /* @__PURE__ */ new Map();
      if (handlers.has(events)) {
        return;
      }
      const handler = events !== void 0 ? (type, event) => {
        if (events.includes(type)) {
          this.emit(type, event);
        }
      } : (type, event) => {
        this.emit(type, event);
      };
      handlers.set(events, handler);
      bubbleHandlers.set(this, handlers);
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js
var __runInitializers, __esDecorate, __addDisposableResource4, __disposeResources4, JSHandle;
var init_JSHandle = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js"() {
    init_util();
    init_decorators();
    init_disposable();
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __addDisposableResource4 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources4 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    JSHandle = (() => {
      let _classDecorators = [moveable];
      let _classDescriptor;
      let _classExtraInitializers = [];
      let _classThis;
      let _instanceExtraInitializers = [];
      let _getProperty_decorators;
      let _getProperties_decorators;
      var JSHandle2 = class {
        static {
          _classThis = this;
        }
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
          __esDecorate(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
          JSHandle2 = _classThis = _classDescriptor.value;
          if (_metadata)
            Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          __runInitializers(_classThis, _classExtraInitializers);
        }
        /**
         * @internal
         */
        constructor() {
          __runInitializers(this, _instanceExtraInitializers);
        }
        /**
         * Evaluates the given function with the current handle as its first argument.
         */
        async evaluate(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
          return await this.realm.evaluate(pageFunction, this, ...args);
        }
        /**
         * Evaluates the given function with the current handle as its first argument.
         *
         */
        async evaluateHandle(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
          return await this.realm.evaluateHandle(pageFunction, this, ...args);
        }
        /**
         * @internal
         */
        async getProperty(propertyName) {
          return await this.evaluateHandle((object, propertyName2) => {
            return object[propertyName2];
          }, propertyName);
        }
        /**
         * Gets a map of handles representing the properties of the current handle.
         *
         * @example
         *
         * ```ts
         * const listHandle = await page.evaluateHandle(() => document.body.children);
         * const properties = await listHandle.getProperties();
         * const children = [];
         * for (const property of properties.values()) {
         *   const element = property.asElement();
         *   if (element) {
         *     children.push(element);
         *   }
         * }
         * children; // holds elementHandles to all children of document.body
         * ```
         */
        async getProperties() {
          const propertyNames = await this.evaluate((object) => {
            const enumerableProperties = [];
            const descriptors = Object.getOwnPropertyDescriptors(object);
            for (const propertyName in descriptors) {
              if (descriptors[propertyName]?.enumerable) {
                enumerableProperties.push(propertyName);
              }
            }
            return enumerableProperties;
          });
          const map2 = /* @__PURE__ */ new Map();
          const results = await Promise.all(propertyNames.map((key) => {
            return this.getProperty(key);
          }));
          for (const [key, value] of Object.entries(propertyNames)) {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource4(env_1, results[key], false);
              if (handle) {
                map2.set(value, handle.move());
              }
            } catch (e_1) {
              env_1.error = e_1;
              env_1.hasError = true;
            } finally {
              __disposeResources4(env_1);
            }
          }
          return map2;
        }
        /** @internal */
        [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
          return void this.dispose().catch(debugError);
        }
        /** @internal */
        [asyncDisposeSymbol]() {
          return this.dispose();
        }
      };
      return JSHandle2 = _classThis;
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js
function bindIsolatedHandle(target, _) {
  return async function(...args) {
    if (this.realm === this.frame.isolatedRealm()) {
      return await target.call(this, ...args);
    }
    let adoptedThis;
    if (this["isolatedHandle"]) {
      adoptedThis = this["isolatedHandle"];
    } else {
      this["isolatedHandle"] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);
    }
    const result = await target.call(adoptedThis, ...args);
    if (result === adoptedThis) {
      return this;
    }
    if (result instanceof JSHandle) {
      return await this.realm.transferHandle(result);
    }
    if (Array.isArray(result)) {
      await Promise.all(result.map(async (item, index, result2) => {
        if (item instanceof JSHandle) {
          result2[index] = await this.realm.transferHandle(item);
        }
      }));
    }
    if (result instanceof Map) {
      await Promise.all([...result.entries()].map(async ([key, value]) => {
        if (value instanceof JSHandle) {
          result.set(key, await this.realm.transferHandle(value));
        }
      }));
    }
    return result;
  };
}
function intersectBoundingBox(box, width, height) {
  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
}
var __runInitializers2, __esDecorate2, __addDisposableResource5, __disposeResources5, __setFunctionName, ElementHandle;
var init_ElementHandle = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js"() {
    init_GetQueryHandler();
    init_LazyArg();
    init_util();
    init_assert();
    init_AsyncIterableUtil();
    init_decorators();
    init_ElementHandleSymbol();
    init_JSHandle();
    __runInitializers2 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __addDisposableResource5 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources5 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    ElementHandle = (() => {
      let _classSuper = JSHandle;
      let _instanceExtraInitializers = [];
      let _getProperty_decorators;
      let _getProperties_decorators;
      let _jsonValue_decorators;
      let _$_decorators;
      let _$$_decorators;
      let _private_$$_decorators;
      let _private_$$_descriptor;
      let _waitForSelector_decorators;
      let _isVisible_decorators;
      let _isHidden_decorators;
      let _toElement_decorators;
      let _clickablePoint_decorators;
      let _hover_decorators;
      let _click_decorators;
      let _drag_decorators;
      let _dragEnter_decorators;
      let _dragOver_decorators;
      let _drop_decorators;
      let _dragAndDrop_decorators;
      let _select_decorators;
      let _tap_decorators;
      let _touchStart_decorators;
      let _touchMove_decorators;
      let _touchEnd_decorators;
      let _focus_decorators;
      let _type_decorators;
      let _press_decorators;
      let _boundingBox_decorators;
      let _boxModel_decorators;
      let _screenshot_decorators;
      let _isIntersectingViewport_decorators;
      let _scrollIntoView_decorators;
      return class ElementHandle2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _getProperty_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _getProperties_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _jsonValue_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _$_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _$$_decorators = [throwIfDisposed()];
          _private_$$_decorators = [bindIsolatedHandle];
          _waitForSelector_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _isVisible_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _isHidden_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _toElement_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _clickablePoint_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _hover_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _click_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _drag_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _dragEnter_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _dragOver_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _drop_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _dragAndDrop_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _select_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _tap_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _touchStart_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _touchMove_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _touchEnd_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _focus_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _type_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _press_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _boundingBox_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _boxModel_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _screenshot_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _isIntersectingViewport_decorators = [throwIfDisposed(), bindIsolatedHandle];
          _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
          __esDecorate2(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: (obj) => "jsonValue" in obj, get: (obj) => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, _private_$$_descriptor = { value: __setFunctionName(async function(selector) {
            return await this.#$$impl(selector);
          }, "#$$") }, _private_$$_decorators, { kind: "method", name: "#$$", static: false, private: true, access: { has: (obj) => #$$ in obj, get: (obj) => obj.#$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: (obj) => "isVisible" in obj, get: (obj) => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: (obj) => "isHidden" in obj, get: (obj) => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: (obj) => "toElement" in obj, get: (obj) => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: (obj) => "clickablePoint" in obj, get: (obj) => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: (obj) => "drag" in obj, get: (obj) => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: (obj) => "dragEnter" in obj, get: (obj) => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: (obj) => "dragOver" in obj, get: (obj) => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: (obj) => "drop" in obj, get: (obj) => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: (obj) => "dragAndDrop" in obj, get: (obj) => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: (obj) => "touchStart" in obj, get: (obj) => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: (obj) => "touchMove" in obj, get: (obj) => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: (obj) => "touchEnd" in obj, get: (obj) => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: (obj) => "press" in obj, get: (obj) => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: (obj) => "boundingBox" in obj, get: (obj) => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: (obj) => "boxModel" in obj, get: (obj) => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: (obj) => "isIntersectingViewport" in obj, get: (obj) => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate2(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        /**
         * @internal
         * Cached isolatedHandle to prevent
         * trying to adopt it multiple times
         */
        isolatedHandle = __runInitializers2(this, _instanceExtraInitializers);
        /**
         * @internal
         */
        handle;
        /**
         * @internal
         */
        constructor(handle) {
          super();
          this.handle = handle;
          this[_isElementHandle] = true;
        }
        /**
         * @internal
         */
        get id() {
          return this.handle.id;
        }
        /**
         * @internal
         */
        get disposed() {
          return this.handle.disposed;
        }
        /**
         * @internal
         */
        async getProperty(propertyName) {
          return await this.handle.getProperty(propertyName);
        }
        /**
         * @internal
         */
        async getProperties() {
          return await this.handle.getProperties();
        }
        /**
         * @internal
         */
        async evaluate(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
          return await this.handle.evaluate(pageFunction, ...args);
        }
        /**
         * @internal
         */
        async evaluateHandle(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
          return await this.handle.evaluateHandle(pageFunction, ...args);
        }
        /**
         * @internal
         */
        async jsonValue() {
          return await this.handle.jsonValue();
        }
        /**
         * @internal
         */
        toString() {
          return this.handle.toString();
        }
        /**
         * @internal
         */
        remoteObject() {
          return this.handle.remoteObject();
        }
        /**
         * @internal
         */
        async dispose() {
          await Promise.all([this.handle.dispose(), this.isolatedHandle?.dispose()]);
        }
        /**
         * @internal
         */
        asElement() {
          return this;
        }
        /**
         * Queries the current element for an element matching the given selector.
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @returns A {@link ElementHandle | element handle} to the first element
         * matching the given selector. Otherwise, `null`.
         */
        async $(selector) {
          const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
          return await QueryHandler2.queryOne(this, updatedSelector);
        }
        /**
         * Queries the current element for all elements matching the given selector.
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @returns An array of {@link ElementHandle | element handles} that point to
         * elements matching the given selector.
         */
        async $$(selector, options) {
          if (options?.isolate === false) {
            return await this.#$$impl(selector);
          }
          return await this.#$$(selector);
        }
        /**
         * Isolates {@link ElementHandle.$$} if needed.
         *
         * @internal
         */
        get #$$() {
          return _private_$$_descriptor.value;
        }
        /**
         * Implementation for {@link ElementHandle.$$}.
         *
         * @internal
         */
        async #$$impl(selector) {
          const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
          return await AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
        }
        /**
         * Runs the given function on the first element matching the given selector in
         * the current element.
         *
         * If the given function returns a promise, then this method will wait till
         * the promise resolves.
         *
         * @example
         *
         * ```ts
         * const tweetHandle = await page.$('.tweet');
         * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
         *   '100',
         * );
         * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
         *   '10',
         * );
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param pageFunction - The function to be evaluated in this element's page's
         * context. The first element matching the selector will be passed in as the
         * first argument.
         * @param args - Additional arguments to pass to `pageFunction`.
         * @returns A promise to the result of the function.
         */
        async $eval(selector, pageFunction, ...args) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
            const elementHandle = __addDisposableResource5(env_1, await this.$(selector), false);
            if (!elementHandle) {
              throw new Error(`Error: failed to find element matching selector "${selector}"`);
            }
            return await elementHandle.evaluate(pageFunction, ...args);
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources5(env_1);
          }
        }
        /**
         * Runs the given function on an array of elements matching the given selector
         * in the current element.
         *
         * If the given function returns a promise, then this method will wait till
         * the promise resolves.
         *
         * @example
         * HTML:
         *
         * ```html
         * <div class="feed">
         *   <div class="tweet">Hello!</div>
         *   <div class="tweet">Hi!</div>
         * </div>
         * ```
         *
         * JavaScript:
         *
         * ```ts
         * const feedHandle = await page.$('.feed');
         * expect(
         *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)),
         * ).toEqual(['Hello!', 'Hi!']);
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param pageFunction - The function to be evaluated in the element's page's
         * context. An array of elements matching the given selector will be passed to
         * the function as its first argument.
         * @param args - Additional arguments to pass to `pageFunction`.
         * @returns A promise to the result of the function.
         */
        async $$eval(selector, pageFunction, ...args) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
            const results = await this.$$(selector);
            const elements = __addDisposableResource5(env_2, await this.evaluateHandle((_, ...elements2) => {
              return elements2;
            }, ...results), false);
            const [result] = await Promise.all([
              elements.evaluate(pageFunction, ...args),
              ...results.map((results2) => {
                return results2.dispose();
              })
            ]);
            return result;
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            __disposeResources5(env_2);
          }
        }
        /**
         * Wait for an element matching the given selector to appear in the current
         * element.
         *
         * Unlike {@link Frame.waitForSelector}, this method does not work across
         * navigations or if the element is detached from DOM.
         *
         * @example
         *
         * ```ts
         * import puppeteer from 'puppeteer';
         *
         * (async () => {
         *   const browser = await puppeteer.launch();
         *   const page = await browser.newPage();
         *   let currentURL;
         *   page
         *     .mainFrame()
         *     .waitForSelector('img')
         *     .then(() => console.log('First URL with image: ' + currentURL));
         *
         *   for (currentURL of [
         *     'https://example.com',
         *     'https://google.com',
         *     'https://bbc.com',
         *   ]) {
         *     await page.goto(currentURL);
         *   }
         *   await browser.close();
         * })();
         * ```
         *
         * @param selector - The selector to query and wait for.
         * @param options - Options for customizing waiting behavior.
         * @returns An element matching the given selector.
         * @throws Throws if an element matching the given selector doesn't appear.
         */
        async waitForSelector(selector, options = {}) {
          const { updatedSelector, QueryHandler: QueryHandler2, polling } = getQueryHandlerAndSelector(selector);
          return await QueryHandler2.waitFor(this, updatedSelector, {
            polling,
            ...options
          });
        }
        async #checkVisibility(visibility) {
          return await this.evaluate(async (element, PuppeteerUtil, visibility2) => {
            return Boolean(PuppeteerUtil.checkVisibility(element, visibility2));
          }, LazyArg.create((context2) => {
            return context2.puppeteerUtil;
          }), visibility);
        }
        /**
         * An element is considered to be visible if all of the following is
         * true:
         *
         * - the element has
         *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
         *
         * - the element has a non-empty
         *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
         *
         * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
         *   is not `hidden` or `collapse`.
         */
        async isVisible() {
          return await this.#checkVisibility(true);
        }
        /**
         * An element is considered to be hidden if at least one of the following is true:
         *
         * - the element has no
         *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
         *
         * - the element has an empty
         *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
         *
         * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
         *   is `hidden` or `collapse`.
         */
        async isHidden() {
          return await this.#checkVisibility(false);
        }
        /**
         * Converts the current handle to the given element type.
         *
         * @example
         *
         * ```ts
         * const element: ElementHandle<Element> = await page.$(
         *   '.class-name-of-anchor',
         * );
         * // DO NOT DISPOSE `element`, this will be always be the same handle.
         * const anchor: ElementHandle<HTMLAnchorElement> =
         *   await element.toElement('a');
         * ```
         *
         * @param tagName - The tag name of the desired element type.
         * @throws An error if the handle does not match. **The handle will not be
         * automatically disposed.**
         */
        async toElement(tagName) {
          const isMatchingTagName = await this.evaluate((node, tagName2) => {
            return node.nodeName === tagName2.toUpperCase();
          }, tagName);
          if (!isMatchingTagName) {
            throw new Error(`Element is not a(n) \`${tagName}\` element`);
          }
          return this;
        }
        /**
         * Returns the middle point within an element unless a specific offset is provided.
         */
        async clickablePoint(offset) {
          const box = await this.#clickableBox();
          if (!box) {
            throw new Error("Node is either not clickable or not an Element");
          }
          if (offset !== void 0) {
            return {
              x: box.x + offset.x,
              y: box.y + offset.y
            };
          }
          return {
            x: box.x + box.width / 2,
            y: box.y + box.height / 2
          };
        }
        /**
         * This method scrolls element into view if needed, and then
         * uses {@link Page.mouse} to hover over the center of the element.
         * If the element is detached from DOM, the method throws an error.
         */
        async hover() {
          await this.scrollIntoViewIfNeeded();
          const { x, y } = await this.clickablePoint();
          await this.frame.page().mouse.move(x, y);
        }
        /**
         * This method scrolls element into view if needed, and then
         * uses {@link Page.mouse} to click in the center of the element.
         * If the element is detached from DOM, the method throws an error.
         */
        async click(options = {}) {
          await this.scrollIntoViewIfNeeded();
          const { x, y } = await this.clickablePoint(options.offset);
          await this.frame.page().mouse.click(x, y, options);
        }
        /**
         * Drags an element over the given element or point.
         *
         * @returns DEPRECATED. When drag interception is enabled, the drag payload is
         * returned.
         */
        async drag(target) {
          await this.scrollIntoViewIfNeeded();
          const page = this.frame.page();
          if (page.isDragInterceptionEnabled()) {
            const source2 = await this.clickablePoint();
            if (target instanceof ElementHandle2) {
              target = await target.clickablePoint();
            }
            return await page.mouse.drag(source2, target);
          }
          try {
            if (!page._isDragging) {
              page._isDragging = true;
              await this.hover();
              await page.mouse.down();
            }
            if (target instanceof ElementHandle2) {
              await target.hover();
            } else {
              await page.mouse.move(target.x, target.y);
            }
          } catch (error) {
            page._isDragging = false;
            throw error;
          }
        }
        /**
         * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
         */
        async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
          const page = this.frame.page();
          await this.scrollIntoViewIfNeeded();
          const target = await this.clickablePoint();
          await page.mouse.dragEnter(target, data);
        }
        /**
         * @deprecated Do not use. `dragover` will automatically be performed during dragging.
         */
        async dragOver(data = { items: [], dragOperationsMask: 1 }) {
          const page = this.frame.page();
          await this.scrollIntoViewIfNeeded();
          const target = await this.clickablePoint();
          await page.mouse.dragOver(target, data);
        }
        /**
         * @internal
         */
        async drop(dataOrElement = {
          items: [],
          dragOperationsMask: 1
        }) {
          const page = this.frame.page();
          if ("items" in dataOrElement) {
            await this.scrollIntoViewIfNeeded();
            const destination = await this.clickablePoint();
            await page.mouse.drop(destination, dataOrElement);
          } else {
            await dataOrElement.drag(this);
            page._isDragging = false;
            await page.mouse.up();
          }
        }
        /**
         * @deprecated Use `ElementHandle.drop` instead.
         */
        async dragAndDrop(target, options) {
          const page = this.frame.page();
          assert(page.isDragInterceptionEnabled(), "Drag Interception is not enabled!");
          await this.scrollIntoViewIfNeeded();
          const startPoint = await this.clickablePoint();
          const targetPoint = await target.clickablePoint();
          await page.mouse.dragAndDrop(startPoint, targetPoint, options);
        }
        /**
         * Triggers a `change` and `input` event once all the provided options have been
         * selected. If there's no `<select>` element matching `selector`, the method
         * throws an error.
         *
         * @example
         *
         * ```ts
         * handle.select('blue'); // single selection
         * handle.select('red', 'green', 'blue'); // multiple selections
         * ```
         *
         * @param values - Values of options to select. If the `<select>` has the
         * `multiple` attribute, all values are considered, otherwise only the first
         * one is taken into account.
         */
        async select(...values) {
          for (const value of values) {
            assert(isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
          }
          return await this.evaluate((element, vals) => {
            const values2 = new Set(vals);
            if (!(element instanceof HTMLSelectElement)) {
              throw new Error("Element is not a <select> element.");
            }
            const selectedValues = /* @__PURE__ */ new Set();
            if (!element.multiple) {
              for (const option of element.options) {
                option.selected = false;
              }
              for (const option of element.options) {
                if (values2.has(option.value)) {
                  option.selected = true;
                  selectedValues.add(option.value);
                  break;
                }
              }
            } else {
              for (const option of element.options) {
                option.selected = values2.has(option.value);
                if (option.selected) {
                  selectedValues.add(option.value);
                }
              }
            }
            element.dispatchEvent(new Event("input", { bubbles: true }));
            element.dispatchEvent(new Event("change", { bubbles: true }));
            return [...selectedValues.values()];
          }, values);
        }
        /**
         * This method scrolls element into view if needed, and then uses
         * {@link Touchscreen.tap} to tap in the center of the element.
         * If the element is detached from DOM, the method throws an error.
         */
        async tap() {
          await this.scrollIntoViewIfNeeded();
          const { x, y } = await this.clickablePoint();
          await this.frame.page().touchscreen.tap(x, y);
        }
        /**
         * This method scrolls the element into view if needed, and then
         * starts a touch in the center of the element.
         * @returns A {@link TouchHandle} representing the touch that was started
         */
        async touchStart() {
          await this.scrollIntoViewIfNeeded();
          const { x, y } = await this.clickablePoint();
          return await this.frame.page().touchscreen.touchStart(x, y);
        }
        /**
         * This method scrolls the element into view if needed, and then
         * moves the touch to the center of the element.
         * @param touch - An optional {@link TouchHandle}. If provided, this touch
         * will be moved. If not provided, the first active touch will be moved.
         */
        async touchMove(touch) {
          await this.scrollIntoViewIfNeeded();
          const { x, y } = await this.clickablePoint();
          if (touch) {
            return await touch.move(x, y);
          }
          await this.frame.page().touchscreen.touchMove(x, y);
        }
        async touchEnd() {
          await this.scrollIntoViewIfNeeded();
          await this.frame.page().touchscreen.touchEnd();
        }
        /**
         * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
         */
        async focus() {
          await this.evaluate((element) => {
            if (!(element instanceof HTMLElement)) {
              throw new Error("Cannot focus non-HTMLElement");
            }
            return element.focus();
          });
        }
        /**
         * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
         * `keyup` event for each character in the text.
         *
         * To press a special key, like `Control` or `ArrowDown`,
         * use {@link ElementHandle.press}.
         *
         * @example
         *
         * ```ts
         * await elementHandle.type('Hello'); // Types instantly
         * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
         * ```
         *
         * @example
         * An example of typing into a text field and then submitting the form:
         *
         * ```ts
         * const elementHandle = await page.$('input');
         * await elementHandle.type('some text');
         * await elementHandle.press('Enter');
         * ```
         *
         * @param options - Delay in milliseconds. Defaults to 0.
         */
        async type(text, options) {
          await this.focus();
          await this.frame.page().keyboard.type(text, options);
        }
        /**
         * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
         *
         * @remarks
         * If `key` is a single character and no modifier keys besides `Shift`
         * are being held down, a `keypress`/`input` event will also be generated.
         * The `text` option can be specified to force an input event to be generated.
         *
         * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
         * will type the text in upper case.
         *
         * @param key - Name of key to press, such as `ArrowLeft`.
         * See {@link KeyInput} for a list of all key names.
         */
        async press(key, options) {
          await this.focus();
          await this.frame.page().keyboard.press(key, options);
        }
        async #clickableBox() {
          const boxes = await this.evaluate((element) => {
            if (!(element instanceof Element)) {
              return null;
            }
            return [...element.getClientRects()].map((rect) => {
              return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
            });
          });
          if (!boxes?.length) {
            return null;
          }
          await this.#intersectBoundingBoxesWithFrame(boxes);
          let frame = this.frame;
          let parentFrame;
          while (parentFrame = frame?.parentFrame()) {
            const env_3 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource5(env_3, await frame.frameElement(), false);
              if (!handle) {
                throw new Error("Unsupported frame type");
              }
              const parentBox = await handle.evaluate((element) => {
                if (element.getClientRects().length === 0) {
                  return null;
                }
                const rect = element.getBoundingClientRect();
                const style = window.getComputedStyle(element);
                return {
                  left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
                  top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
                };
              });
              if (!parentBox) {
                return null;
              }
              for (const box2 of boxes) {
                box2.x += parentBox.left;
                box2.y += parentBox.top;
              }
              await handle.#intersectBoundingBoxesWithFrame(boxes);
              frame = parentFrame;
            } catch (e_3) {
              env_3.error = e_3;
              env_3.hasError = true;
            } finally {
              __disposeResources5(env_3);
            }
          }
          const box = boxes.find((box2) => {
            return box2.width >= 1 && box2.height >= 1;
          });
          if (!box) {
            return null;
          }
          return {
            x: box.x,
            y: box.y,
            height: box.height,
            width: box.width
          };
        }
        async #intersectBoundingBoxesWithFrame(boxes) {
          const { documentWidth, documentHeight } = await this.frame.isolatedRealm().evaluate(() => {
            return {
              documentWidth: document.documentElement.clientWidth,
              documentHeight: document.documentElement.clientHeight
            };
          });
          for (const box of boxes) {
            intersectBoundingBox(box, documentWidth, documentHeight);
          }
        }
        /**
         * This method returns the bounding box of the element (relative to the main frame),
         * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
         * (example: `display: none`).
         */
        async boundingBox() {
          const box = await this.evaluate((element) => {
            if (!(element instanceof Element)) {
              return null;
            }
            if (element.getClientRects().length === 0) {
              return null;
            }
            const rect = element.getBoundingClientRect();
            return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
          });
          if (!box) {
            return null;
          }
          const offset = await this.#getTopLeftCornerOfFrame();
          if (!offset) {
            return null;
          }
          return {
            x: box.x + offset.x,
            y: box.y + offset.y,
            height: box.height,
            width: box.width
          };
        }
        /**
         * This method returns boxes of the element,
         * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
         * (example: `display: none`).
         *
         * @remarks
         *
         * Boxes are represented as an array of points;
         * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
         */
        async boxModel() {
          const model = await this.evaluate((element) => {
            if (!(element instanceof Element)) {
              return null;
            }
            if (element.getClientRects().length === 0) {
              return null;
            }
            const rect = element.getBoundingClientRect();
            const style = window.getComputedStyle(element);
            const offsets = {
              padding: {
                left: parseInt(style.paddingLeft, 10),
                top: parseInt(style.paddingTop, 10),
                right: parseInt(style.paddingRight, 10),
                bottom: parseInt(style.paddingBottom, 10)
              },
              margin: {
                left: -parseInt(style.marginLeft, 10),
                top: -parseInt(style.marginTop, 10),
                right: -parseInt(style.marginRight, 10),
                bottom: -parseInt(style.marginBottom, 10)
              },
              border: {
                left: parseInt(style.borderLeft, 10),
                top: parseInt(style.borderTop, 10),
                right: parseInt(style.borderRight, 10),
                bottom: parseInt(style.borderBottom, 10)
              }
            };
            const border = [
              { x: rect.left, y: rect.top },
              { x: rect.left + rect.width, y: rect.top },
              { x: rect.left + rect.width, y: rect.top + rect.height },
              { x: rect.left, y: rect.top + rect.height }
            ];
            const padding = transformQuadWithOffsets(border, offsets.border);
            const content = transformQuadWithOffsets(padding, offsets.padding);
            const margin = transformQuadWithOffsets(border, offsets.margin);
            return {
              content,
              padding,
              border,
              margin,
              width: rect.width,
              height: rect.height
            };
            function transformQuadWithOffsets(quad, offsets2) {
              return [
                {
                  x: quad[0].x + offsets2.left,
                  y: quad[0].y + offsets2.top
                },
                {
                  x: quad[1].x - offsets2.right,
                  y: quad[1].y + offsets2.top
                },
                {
                  x: quad[2].x - offsets2.right,
                  y: quad[2].y - offsets2.bottom
                },
                {
                  x: quad[3].x + offsets2.left,
                  y: quad[3].y - offsets2.bottom
                }
              ];
            }
          });
          if (!model) {
            return null;
          }
          const offset = await this.#getTopLeftCornerOfFrame();
          if (!offset) {
            return null;
          }
          for (const attribute of [
            "content",
            "padding",
            "border",
            "margin"
          ]) {
            for (const point of model[attribute]) {
              point.x += offset.x;
              point.y += offset.y;
            }
          }
          return model;
        }
        async #getTopLeftCornerOfFrame() {
          const point = { x: 0, y: 0 };
          let frame = this.frame;
          let parentFrame;
          while (parentFrame = frame?.parentFrame()) {
            const env_4 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource5(env_4, await frame.frameElement(), false);
              if (!handle) {
                throw new Error("Unsupported frame type");
              }
              const parentBox = await handle.evaluate((element) => {
                if (element.getClientRects().length === 0) {
                  return null;
                }
                const rect = element.getBoundingClientRect();
                const style = window.getComputedStyle(element);
                return {
                  left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
                  top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
                };
              });
              if (!parentBox) {
                return null;
              }
              point.x += parentBox.left;
              point.y += parentBox.top;
              frame = parentFrame;
            } catch (e_4) {
              env_4.error = e_4;
              env_4.hasError = true;
            } finally {
              __disposeResources5(env_4);
            }
          }
          return point;
        }
        async screenshot(options = {}) {
          const { scrollIntoView = true, clip } = options;
          const page = this.frame.page();
          if (scrollIntoView) {
            await this.scrollIntoViewIfNeeded();
          }
          const elementClip = await this.#nonEmptyVisibleBoundingBox();
          const [pageLeft, pageTop] = await this.evaluate(() => {
            if (!window.visualViewport) {
              throw new Error("window.visualViewport is not supported.");
            }
            return [
              window.visualViewport.pageLeft,
              window.visualViewport.pageTop
            ];
          });
          elementClip.x += pageLeft;
          elementClip.y += pageTop;
          if (clip) {
            elementClip.x += clip.x;
            elementClip.y += clip.y;
            elementClip.height = clip.height;
            elementClip.width = clip.width;
          }
          return await page.screenshot({ ...options, clip: elementClip });
        }
        async #nonEmptyVisibleBoundingBox() {
          const box = await this.boundingBox();
          assert(box, "Node is either not visible or not an HTMLElement");
          assert(box.width !== 0, "Node has 0 width.");
          assert(box.height !== 0, "Node has 0 height.");
          return box;
        }
        /**
         * @internal
         */
        async assertConnectedElement() {
          const error = await this.evaluate(async (element) => {
            if (!element.isConnected) {
              return "Node is detached from document";
            }
            if (element.nodeType !== Node.ELEMENT_NODE) {
              return "Node is not of type HTMLElement";
            }
            return;
          });
          if (error) {
            throw new Error(error);
          }
        }
        /**
         * @internal
         */
        async scrollIntoViewIfNeeded() {
          if (await this.isIntersectingViewport({
            threshold: 1
          })) {
            return;
          }
          await this.scrollIntoView();
        }
        /**
         * Resolves to true if the element is visible in the current viewport. If an
         * element is an SVG, we check if the svg owner element is in the viewport
         * instead. See https://crbug.com/963246.
         *
         * @param options - Threshold for the intersection between 0 (no intersection) and 1
         * (full intersection). Defaults to 1.
         */
        async isIntersectingViewport(options = {}) {
          const env_5 = { stack: [], error: void 0, hasError: false };
          try {
            await this.assertConnectedElement();
            const handle = await this.#asSVGElementHandle();
            const target = __addDisposableResource5(env_5, handle && await handle.#getOwnerSVGElement(), false);
            return await (target ?? this).evaluate(async (element, threshold) => {
              const visibleRatio = await new Promise((resolve) => {
                const observer = new IntersectionObserver((entries) => {
                  resolve(entries[0].intersectionRatio);
                  observer.disconnect();
                });
                observer.observe(element);
              });
              return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
            }, options.threshold ?? 0);
          } catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
          } finally {
            __disposeResources5(env_5);
          }
        }
        /**
         * Scrolls the element into view using either the automation protocol client
         * or by calling element.scrollIntoView.
         */
        async scrollIntoView() {
          await this.assertConnectedElement();
          await this.evaluate(async (element) => {
            element.scrollIntoView({
              block: "center",
              inline: "center",
              behavior: "instant"
            });
          });
        }
        /**
         * Returns true if an element is an SVGElement (included svg, path, rect
         * etc.).
         */
        async #asSVGElementHandle() {
          if (await this.evaluate((element) => {
            return element instanceof SVGElement;
          })) {
            return this;
          } else {
            return null;
          }
        }
        async #getOwnerSVGElement() {
          return await this.evaluateHandle((element) => {
            if (element instanceof SVGSVGElement) {
              return element;
            }
            return element.ownerSVGElement;
          });
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/locators/locators.js
function checkLocatorArray(locators) {
  for (const locator of locators) {
    if (!(locator instanceof Locator)) {
      throw new Error("Unknown locator for race candidate");
    }
  }
  return locators;
}
var __addDisposableResource6, __disposeResources6, LocatorEvent, Locator, FunctionLocator, DelegatedLocator, FilteredLocator, MappedLocator, NodeLocator, RaceLocator, RETRY_DELAY;
var init_locators = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/locators/locators.js"() {
    init_rxjs();
    init_EventEmitter();
    init_util();
    __addDisposableResource6 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources6 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    (function(LocatorEvent2) {
      LocatorEvent2["Action"] = "action";
    })(LocatorEvent || (LocatorEvent = {}));
    Locator = class extends EventEmitter {
      /**
       * Creates a race between multiple locators trying to locate elements in
       * parallel but ensures that only a single element receives the action.
       *
       * @public
       */
      static race(locators) {
        return RaceLocator.create(locators);
      }
      /**
       * @internal
       */
      visibility = null;
      /**
       * @internal
       */
      _timeout = 3e4;
      #ensureElementIsInTheViewport = true;
      #waitForEnabled = true;
      #waitForStableBoundingBox = true;
      /**
       * @internal
       */
      operators = {
        conditions: (conditions, signal) => {
          return mergeMap((handle) => {
            return merge(...conditions.map((condition) => {
              return condition(handle, signal);
            })).pipe(defaultIfEmpty(handle));
          });
        },
        retryAndRaceWithSignalAndTimer: (signal, cause) => {
          const candidates = [];
          if (signal) {
            candidates.push(fromAbortSignal(signal, cause));
          }
          candidates.push(timeout(this._timeout, cause));
          return pipe(retry({ delay: RETRY_DELAY }), raceWith(...candidates));
        }
      };
      // Determines when the locator will timeout for actions.
      get timeout() {
        return this._timeout;
      }
      /**
       * Creates a new locator instance by cloning the current locator and setting
       * the total timeout for the locator actions.
       *
       * Pass `0` to disable timeout.
       *
       * @defaultValue `Page.getDefaultTimeout()`
       */
      setTimeout(timeout2) {
        const locator = this._clone();
        locator._timeout = timeout2;
        return locator;
      }
      /**
       * Creates a new locator instance by cloning the current locator with the
       * visibility property changed to the specified value.
       */
      setVisibility(visibility) {
        const locator = this._clone();
        locator.visibility = visibility;
        return locator;
      }
      /**
       * Creates a new locator instance by cloning the current locator and
       * specifying whether to wait for input elements to become enabled before the
       * action. Applicable to `click` and `fill` actions.
       *
       * @defaultValue `true`
       */
      setWaitForEnabled(value) {
        const locator = this._clone();
        locator.#waitForEnabled = value;
        return locator;
      }
      /**
       * Creates a new locator instance by cloning the current locator and
       * specifying whether the locator should scroll the element into viewport if
       * it is not in the viewport already.
       *
       * @defaultValue `true`
       */
      setEnsureElementIsInTheViewport(value) {
        const locator = this._clone();
        locator.#ensureElementIsInTheViewport = value;
        return locator;
      }
      /**
       * Creates a new locator instance by cloning the current locator and
       * specifying whether the locator has to wait for the element's bounding box
       * to be same between two consecutive animation frames.
       *
       * @defaultValue `true`
       */
      setWaitForStableBoundingBox(value) {
        const locator = this._clone();
        locator.#waitForStableBoundingBox = value;
        return locator;
      }
      /**
       * @internal
       */
      copyOptions(locator) {
        this._timeout = locator._timeout;
        this.visibility = locator.visibility;
        this.#waitForEnabled = locator.#waitForEnabled;
        this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;
        this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;
        return this;
      }
      /**
       * If the element has a "disabled" property, wait for the element to be
       * enabled.
       */
      #waitForEnabledIfNeeded = (handle, signal) => {
        if (!this.#waitForEnabled) {
          return EMPTY;
        }
        return from(handle.frame.waitForFunction((element) => {
          if (!(element instanceof HTMLElement)) {
            return true;
          }
          const isNativeFormControl = [
            "BUTTON",
            "INPUT",
            "SELECT",
            "TEXTAREA",
            "OPTION",
            "OPTGROUP"
          ].includes(element.nodeName);
          return !isNativeFormControl || !element.hasAttribute("disabled");
        }, {
          timeout: this._timeout,
          signal
        }, handle)).pipe(ignoreElements());
      };
      /**
       * Compares the bounding box of the element for two consecutive animation
       * frames and waits till they are the same.
       */
      #waitForStableBoundingBoxIfNeeded = (handle) => {
        if (!this.#waitForStableBoundingBox) {
          return EMPTY;
        }
        return defer(() => {
          return from(handle.evaluate((element) => {
            return new Promise((resolve) => {
              window.requestAnimationFrame(() => {
                const rect1 = element.getBoundingClientRect();
                window.requestAnimationFrame(() => {
                  const rect2 = element.getBoundingClientRect();
                  resolve([
                    {
                      x: rect1.x,
                      y: rect1.y,
                      width: rect1.width,
                      height: rect1.height
                    },
                    {
                      x: rect2.x,
                      y: rect2.y,
                      width: rect2.width,
                      height: rect2.height
                    }
                  ]);
                });
              });
            });
          }));
        }).pipe(first(([rect1, rect2]) => {
          return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
        }), retry({ delay: RETRY_DELAY }), ignoreElements());
      };
      /**
       * Checks if the element is in the viewport and auto-scrolls it if it is not.
       */
      #ensureElementIsInTheViewportIfNeeded = (handle) => {
        if (!this.#ensureElementIsInTheViewport) {
          return EMPTY;
        }
        return from(handle.isIntersectingViewport({ threshold: 0 })).pipe(filter((isIntersectingViewport) => {
          return !isIntersectingViewport;
        }), mergeMap(() => {
          return from(handle.scrollIntoView());
        }), mergeMap(() => {
          return defer(() => {
            return from(handle.isIntersectingViewport({ threshold: 0 }));
          }).pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
        }));
      };
      #click(options) {
        const signal = options?.signal;
        const cause = new Error("Locator.click");
        return this._wait(options).pipe(this.operators.conditions([
          this.#ensureElementIsInTheViewportIfNeeded,
          this.#waitForStableBoundingBoxIfNeeded,
          this.#waitForEnabledIfNeeded
        ], signal), tap(() => {
          return this.emit(LocatorEvent.Action, void 0);
        }), mergeMap((handle) => {
          return from(handle.click(options)).pipe(catchError((err) => {
            void handle.dispose().catch(debugError);
            throw err;
          }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
      }
      #fill(value, options) {
        const signal = options?.signal;
        const cause = new Error("Locator.fill");
        return this._wait(options).pipe(this.operators.conditions([
          this.#ensureElementIsInTheViewportIfNeeded,
          this.#waitForStableBoundingBoxIfNeeded,
          this.#waitForEnabledIfNeeded
        ], signal), tap(() => {
          return this.emit(LocatorEvent.Action, void 0);
        }), mergeMap((handle) => {
          return from(handle.evaluate((el) => {
            if (el instanceof HTMLSelectElement) {
              return "select";
            }
            if (el instanceof HTMLTextAreaElement) {
              return "typeable-input";
            }
            if (el instanceof HTMLInputElement) {
              if ((/* @__PURE__ */ new Set([
                "textarea",
                "text",
                "url",
                "tel",
                "search",
                "password",
                "number",
                "email"
              ])).has(el.type)) {
                return "typeable-input";
              } else {
                return "other-input";
              }
            }
            if (el.isContentEditable) {
              return "contenteditable";
            }
            return "unknown";
          })).pipe(mergeMap((inputType) => {
            switch (inputType) {
              case "select":
                return from(handle.select(value).then(noop));
              case "contenteditable":
              case "typeable-input":
                return from(handle.evaluate((input, newValue) => {
                  const currentValue = input.isContentEditable ? input.innerText : input.value;
                  if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
                    if (input.isContentEditable) {
                      input.innerText = "";
                    } else {
                      input.value = "";
                    }
                    return newValue;
                  }
                  const originalValue = input.isContentEditable ? input.innerText : input.value;
                  if (input.isContentEditable) {
                    input.innerText = "";
                    input.innerText = originalValue;
                  } else {
                    input.value = "";
                    input.value = originalValue;
                  }
                  return newValue.substring(originalValue.length);
                }, value)).pipe(mergeMap((textToType) => {
                  return from(handle.type(textToType));
                }));
              case "other-input":
                return from(handle.focus()).pipe(mergeMap(() => {
                  return from(handle.evaluate((input, value2) => {
                    input.value = value2;
                    input.dispatchEvent(new Event("input", { bubbles: true }));
                    input.dispatchEvent(new Event("change", { bubbles: true }));
                  }, value));
                }));
              case "unknown":
                throw new Error(`Element cannot be filled out.`);
            }
          })).pipe(catchError((err) => {
            void handle.dispose().catch(debugError);
            throw err;
          }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
      }
      #hover(options) {
        const signal = options?.signal;
        const cause = new Error("Locator.hover");
        return this._wait(options).pipe(this.operators.conditions([
          this.#ensureElementIsInTheViewportIfNeeded,
          this.#waitForStableBoundingBoxIfNeeded
        ], signal), tap(() => {
          return this.emit(LocatorEvent.Action, void 0);
        }), mergeMap((handle) => {
          return from(handle.hover()).pipe(catchError((err) => {
            void handle.dispose().catch(debugError);
            throw err;
          }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
      }
      #scroll(options) {
        const signal = options?.signal;
        const cause = new Error("Locator.scroll");
        return this._wait(options).pipe(this.operators.conditions([
          this.#ensureElementIsInTheViewportIfNeeded,
          this.#waitForStableBoundingBoxIfNeeded
        ], signal), tap(() => {
          return this.emit(LocatorEvent.Action, void 0);
        }), mergeMap((handle) => {
          return from(handle.evaluate((el, scrollTop, scrollLeft) => {
            if (scrollTop !== void 0) {
              el.scrollTop = scrollTop;
            }
            if (scrollLeft !== void 0) {
              el.scrollLeft = scrollLeft;
            }
          }, options?.scrollTop, options?.scrollLeft)).pipe(catchError((err) => {
            void handle.dispose().catch(debugError);
            throw err;
          }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
      }
      /**
       * Clones the locator.
       */
      clone() {
        return this._clone();
      }
      /**
       * Waits for the locator to get a handle from the page.
       *
       * @public
       */
      async waitHandle(options) {
        const cause = new Error("Locator.waitHandle");
        return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal, cause)));
      }
      /**
       * Waits for the locator to get the serialized value from the page.
       *
       * Note this requires the value to be JSON-serializable.
       *
       * @public
       */
      async wait(options) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource6(env_1, await this.waitHandle(options), false);
          return await handle.jsonValue();
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources6(env_1);
        }
      }
      /**
       * Maps the locator using the provided mapper.
       *
       * @public
       */
      map(mapper) {
        return new MappedLocator(this._clone(), (handle) => {
          return handle.evaluateHandle(mapper);
        });
      }
      /**
       * Creates an expectation that is evaluated against located values.
       *
       * If the expectations do not match, then the locator will retry.
       *
       * @public
       */
      filter(predicate) {
        return new FilteredLocator(this._clone(), async (handle, signal) => {
          await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
          return true;
        });
      }
      /**
       * Creates an expectation that is evaluated against located handles.
       *
       * If the expectations do not match, then the locator will retry.
       *
       * @internal
       */
      filterHandle(predicate) {
        return new FilteredLocator(this._clone(), predicate);
      }
      /**
       * Maps the locator using the provided mapper.
       *
       * @internal
       */
      mapHandle(mapper) {
        return new MappedLocator(this._clone(), mapper);
      }
      /**
       * Clicks the located element.
       */
      click(options) {
        return firstValueFrom(this.#click(options));
      }
      /**
       * Fills out the input identified by the locator using the provided value. The
       * type of the input is determined at runtime and the appropriate fill-out
       * method is chosen based on the type. `contenteditable`, select, textarea and
       * input elements are supported.
       */
      fill(value, options) {
        return firstValueFrom(this.#fill(value, options));
      }
      /**
       * Hovers over the located element.
       */
      hover(options) {
        return firstValueFrom(this.#hover(options));
      }
      /**
       * Scrolls the located element.
       */
      scroll(options) {
        return firstValueFrom(this.#scroll(options));
      }
    };
    FunctionLocator = class extends Locator {
      static create(pageOrFrame, func) {
        return new FunctionLocator(pageOrFrame, func).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
      }
      #pageOrFrame;
      #func;
      constructor(pageOrFrame, func) {
        super();
        this.#pageOrFrame = pageOrFrame;
        this.#func = func;
      }
      _clone() {
        return new FunctionLocator(this.#pageOrFrame, this.#func);
      }
      _wait(options) {
        const signal = options?.signal;
        return defer(() => {
          return from(this.#pageOrFrame.waitForFunction(this.#func, {
            timeout: this.timeout,
            signal
          }));
        }).pipe(throwIfEmpty());
      }
    };
    DelegatedLocator = class extends Locator {
      #delegate;
      constructor(delegate) {
        super();
        this.#delegate = delegate;
        this.copyOptions(this.#delegate);
      }
      get delegate() {
        return this.#delegate;
      }
      setTimeout(timeout2) {
        const locator = super.setTimeout(timeout2);
        locator.#delegate = this.#delegate.setTimeout(timeout2);
        return locator;
      }
      setVisibility(visibility) {
        const locator = super.setVisibility(visibility);
        locator.#delegate = locator.#delegate.setVisibility(visibility);
        return locator;
      }
      setWaitForEnabled(value) {
        const locator = super.setWaitForEnabled(value);
        locator.#delegate = this.#delegate.setWaitForEnabled(value);
        return locator;
      }
      setEnsureElementIsInTheViewport(value) {
        const locator = super.setEnsureElementIsInTheViewport(value);
        locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);
        return locator;
      }
      setWaitForStableBoundingBox(value) {
        const locator = super.setWaitForStableBoundingBox(value);
        locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);
        return locator;
      }
    };
    FilteredLocator = class extends DelegatedLocator {
      #predicate;
      constructor(base, predicate) {
        super(base);
        this.#predicate = predicate;
      }
      _clone() {
        return new FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);
      }
      _wait(options) {
        return this.delegate._wait(options).pipe(mergeMap((handle) => {
          return from(Promise.resolve(this.#predicate(handle, options?.signal))).pipe(filter((value) => {
            return value;
          }), map(() => {
            return handle;
          }));
        }), throwIfEmpty());
      }
    };
    MappedLocator = class extends DelegatedLocator {
      #mapper;
      constructor(base, mapper) {
        super(base);
        this.#mapper = mapper;
      }
      _clone() {
        return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);
      }
      _wait(options) {
        return this.delegate._wait(options).pipe(mergeMap((handle) => {
          return from(Promise.resolve(this.#mapper(handle, options?.signal)));
        }));
      }
    };
    NodeLocator = class extends Locator {
      static create(pageOrFrame, selector) {
        return new NodeLocator(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
      }
      #pageOrFrame;
      #selector;
      constructor(pageOrFrame, selector) {
        super();
        this.#pageOrFrame = pageOrFrame;
        this.#selector = selector;
      }
      /**
       * Waits for the element to become visible or hidden. visibility === 'visible'
       * means that the element has a computed style, the visibility property other
       * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
       * 'hidden' means the opposite of that.
       */
      #waitForVisibilityIfNeeded = (handle) => {
        if (!this.visibility) {
          return EMPTY;
        }
        return (() => {
          switch (this.visibility) {
            case "hidden":
              return defer(() => {
                return from(handle.isHidden());
              });
            case "visible":
              return defer(() => {
                return from(handle.isVisible());
              });
          }
        })().pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
      };
      _clone() {
        return new NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);
      }
      _wait(options) {
        const signal = options?.signal;
        return defer(() => {
          return from(this.#pageOrFrame.waitForSelector(this.#selector, {
            visible: false,
            timeout: this._timeout,
            signal
          }));
        }).pipe(filter((value) => {
          return value !== null;
        }), throwIfEmpty(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));
      }
    };
    RaceLocator = class extends Locator {
      static create(locators) {
        const array = checkLocatorArray(locators);
        return new RaceLocator(array);
      }
      #locators;
      constructor(locators) {
        super();
        this.#locators = locators;
      }
      _clone() {
        return new RaceLocator(this.#locators.map((locator) => {
          return locator.clone();
        })).copyOptions(this);
      }
      _wait(options) {
        return race(...this.#locators.map((locator) => {
          return locator._wait(options);
        }));
      }
    };
    RETRY_DELAY = 100;
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js
var __runInitializers3, __esDecorate3, __addDisposableResource7, __disposeResources7, FrameEvent, throwIfDetached, Frame;
var init_Frame = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js"() {
    init_EventEmitter();
    init_GetQueryHandler();
    init_HandleIterator();
    init_util();
    init_environment();
    init_assert();
    init_decorators();
    init_locators();
    __runInitializers3 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __addDisposableResource7 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources7 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    (function(FrameEvent2) {
      FrameEvent2.FrameNavigated = Symbol("Frame.FrameNavigated");
      FrameEvent2.FrameSwapped = Symbol("Frame.FrameSwapped");
      FrameEvent2.LifecycleEvent = Symbol("Frame.LifecycleEvent");
      FrameEvent2.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument");
      FrameEvent2.FrameDetached = Symbol("Frame.FrameDetached");
      FrameEvent2.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
    })(FrameEvent || (FrameEvent = {}));
    throwIfDetached = throwIfDisposed((frame) => {
      return `Attempted to use detached Frame '${frame._id}'.`;
    });
    Frame = (() => {
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _frameElement_decorators;
      let _evaluateHandle_decorators;
      let _evaluate_decorators;
      let _locator_decorators;
      let _$_decorators;
      let _$$_decorators;
      let _$eval_decorators;
      let _$$eval_decorators;
      let _waitForSelector_decorators;
      let _waitForFunction_decorators;
      let _content_decorators;
      let _addScriptTag_decorators;
      let _addStyleTag_decorators;
      let _click_decorators;
      let _focus_decorators;
      let _hover_decorators;
      let _select_decorators;
      let _tap_decorators;
      let _type_decorators;
      let _title_decorators;
      return class Frame extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _frameElement_decorators = [throwIfDetached];
          _evaluateHandle_decorators = [throwIfDetached];
          _evaluate_decorators = [throwIfDetached];
          _locator_decorators = [throwIfDetached];
          _$_decorators = [throwIfDetached];
          _$$_decorators = [throwIfDetached];
          _$eval_decorators = [throwIfDetached];
          _$$eval_decorators = [throwIfDetached];
          _waitForSelector_decorators = [throwIfDetached];
          _waitForFunction_decorators = [throwIfDetached];
          _content_decorators = [throwIfDetached];
          _addScriptTag_decorators = [throwIfDetached];
          _addStyleTag_decorators = [throwIfDetached];
          _click_decorators = [throwIfDetached];
          _focus_decorators = [throwIfDetached];
          _hover_decorators = [throwIfDetached];
          _select_decorators = [throwIfDetached];
          _tap_decorators = [throwIfDetached];
          _type_decorators = [throwIfDetached];
          _title_decorators = [throwIfDetached];
          __esDecorate3(this, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: (obj) => "frameElement" in obj, get: (obj) => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: (obj) => "evaluateHandle" in obj, get: (obj) => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: (obj) => "locator" in obj, get: (obj) => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: (obj) => "$eval" in obj, get: (obj) => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: (obj) => "$$eval" in obj, get: (obj) => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: (obj) => "waitForFunction" in obj, get: (obj) => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: (obj) => "content" in obj, get: (obj) => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: (obj) => "addScriptTag" in obj, get: (obj) => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: (obj) => "addStyleTag" in obj, get: (obj) => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate3(this, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: (obj) => "title" in obj, get: (obj) => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        /**
         * @internal
         */
        _id = __runInitializers3(this, _instanceExtraInitializers);
        /**
         * @internal
         */
        _parentId;
        /**
         * @internal
         */
        _name;
        /**
         * @internal
         */
        _hasStartedLoading = false;
        /**
         * @internal
         */
        constructor() {
          super();
        }
        #_document;
        /**
         * @internal
         */
        #document() {
          if (!this.#_document) {
            this.#_document = this.mainRealm().evaluateHandle(() => {
              return document;
            });
          }
          return this.#_document;
        }
        /**
         * Used to clear the document handle that has been destroyed.
         *
         * @internal
         */
        clearDocumentHandle() {
          this.#_document = void 0;
        }
        /**
         * @returns The frame element associated with this frame (if any).
         */
        async frameElement() {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const parentFrame = this.parentFrame();
            if (!parentFrame) {
              return null;
            }
            const list = __addDisposableResource7(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
              return document.querySelectorAll("iframe,frame");
            }), false);
            for await (const iframe_1 of transposeIterableHandle(list)) {
              const env_2 = { stack: [], error: void 0, hasError: false };
              try {
                const iframe = __addDisposableResource7(env_2, iframe_1, false);
                const frame = await iframe.contentFrame();
                if (frame?._id === this._id) {
                  return await parentFrame.mainRealm().adoptHandle(iframe);
                }
              } catch (e_1) {
                env_2.error = e_1;
                env_2.hasError = true;
              } finally {
                __disposeResources7(env_2);
              }
            }
            return null;
          } catch (e_2) {
            env_1.error = e_2;
            env_1.hasError = true;
          } finally {
            __disposeResources7(env_1);
          }
        }
        /**
         * Behaves identically to {@link Page.evaluateHandle} except it's run within
         * the context of this frame.
         *
         * See {@link Page.evaluateHandle} for details.
         */
        async evaluateHandle(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
          return await this.mainRealm().evaluateHandle(pageFunction, ...args);
        }
        /**
         * Behaves identically to {@link Page.evaluate} except it's run within
         * the context of this frame.
         *
         * See {@link Page.evaluate} for details.
         */
        async evaluate(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
          return await this.mainRealm().evaluate(pageFunction, ...args);
        }
        /**
         * @internal
         */
        locator(selectorOrFunc) {
          if (typeof selectorOrFunc === "string") {
            return NodeLocator.create(this, selectorOrFunc);
          } else {
            return FunctionLocator.create(this, selectorOrFunc);
          }
        }
        /**
         * Queries the frame for an element matching the given selector.
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         *
         * @returns A {@link ElementHandle | element handle} to the first element
         * matching the given selector. Otherwise, `null`.
         */
        async $(selector) {
          const document2 = await this.#document();
          return await document2.$(selector);
        }
        /**
         * Queries the frame for all elements matching the given selector.
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         *
         * @returns An array of {@link ElementHandle | element handles} that point to
         * elements matching the given selector.
         */
        async $$(selector, options) {
          const document2 = await this.#document();
          return await document2.$$(selector, options);
        }
        /**
         * Runs the given function on the first element matching the given selector in
         * the frame.
         *
         * If the given function returns a promise, then this method will wait till
         * the promise resolves.
         *
         * @example
         *
         * ```ts
         * const searchValue = await frame.$eval('#search', el => el.value);
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param pageFunction - The function to be evaluated in the frame's context.
         * The first element matching the selector will be passed to the function as
         * its first argument.
         * @param args - Additional arguments to pass to `pageFunction`.
         * @returns A promise to the result of the function.
         */
        async $eval(selector, pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
          const document2 = await this.#document();
          return await document2.$eval(selector, pageFunction, ...args);
        }
        /**
         * Runs the given function on an array of elements matching the given selector
         * in the frame.
         *
         * If the given function returns a promise, then this method will wait till
         * the promise resolves.
         *
         * @example
         *
         * ```ts
         * const divsCounts = await frame.$$eval('div', divs => divs.length);
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param pageFunction - The function to be evaluated in the frame's context.
         * An array of elements matching the given selector will be passed to the
         * function as its first argument.
         * @param args - Additional arguments to pass to `pageFunction`.
         * @returns A promise to the result of the function.
         */
        async $$eval(selector, pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
          const document2 = await this.#document();
          return await document2.$$eval(selector, pageFunction, ...args);
        }
        /**
         * Waits for an element matching the given selector to appear in the frame.
         *
         * This method works across navigations.
         *
         * @example
         *
         * ```ts
         * import puppeteer from 'puppeteer';
         *
         * (async () => {
         *   const browser = await puppeteer.launch();
         *   const page = await browser.newPage();
         *   let currentURL;
         *   page
         *     .mainFrame()
         *     .waitForSelector('img')
         *     .then(() => console.log('First URL with image: ' + currentURL));
         *
         *   for (currentURL of [
         *     'https://example.com',
         *     'https://google.com',
         *     'https://bbc.com',
         *   ]) {
         *     await page.goto(currentURL);
         *   }
         *   await browser.close();
         * })();
         * ```
         *
         * @param selector - The selector to query and wait for.
         * @param options - Options for customizing waiting behavior.
         * @returns An element matching the given selector.
         * @throws Throws if an element matching the given selector doesn't appear.
         */
        async waitForSelector(selector, options = {}) {
          const { updatedSelector, QueryHandler: QueryHandler2, polling } = getQueryHandlerAndSelector(selector);
          return await QueryHandler2.waitFor(this, updatedSelector, {
            polling,
            ...options
          });
        }
        /**
         * @example
         * The `waitForFunction` can be used to observe viewport size change:
         *
         * ```ts
         * import puppeteer from 'puppeteer';
         *
         * (async () => {
         * .  const browser = await puppeteer.launch();
         * .  const page = await browser.newPage();
         * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
         * .  page.setViewport({width: 50, height: 50});
         * .  await watchDog;
         * .  await browser.close();
         * })();
         * ```
         *
         * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
         *
         * ```ts
         * const selector = '.foo';
         * await frame.waitForFunction(
         *   selector => !!document.querySelector(selector),
         *   {}, // empty options object
         *   selector,
         * );
         * ```
         *
         * @param pageFunction - the function to evaluate in the frame context.
         * @param options - options to configure the polling method and timeout.
         * @param args - arguments to pass to the `pageFunction`.
         * @returns the promise which resolve when the `pageFunction` returns a truthy value.
         */
        async waitForFunction(pageFunction, options = {}, ...args) {
          return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
        }
        /**
         * The full HTML contents of the frame, including the DOCTYPE.
         */
        async content() {
          return await this.evaluate(() => {
            let content = "";
            for (const node of document.childNodes) {
              switch (node) {
                case document.documentElement:
                  content += document.documentElement.outerHTML;
                  break;
                default:
                  content += new XMLSerializer().serializeToString(node);
                  break;
              }
            }
            return content;
          });
        }
        /**
         * @internal
         */
        async setFrameContent(content) {
          return await this.evaluate((html) => {
            document.open();
            document.write(html);
            document.close();
          }, content);
        }
        /**
         * The frame's `name` attribute as specified in the tag.
         *
         * @remarks
         * If the name is empty, it returns the `id` attribute instead.
         *
         * @remarks
         * This value is calculated once when the frame is created, and will not
         * update if the attribute is changed later.
         *
         * @deprecated Use
         *
         * ```ts
         * const element = await frame.frameElement();
         * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);
         * ```
         */
        name() {
          return this._name || "";
        }
        /**
         * Is`true` if the frame has been detached. Otherwise, `false`.
         *
         * @deprecated Use the `detached` getter.
         */
        isDetached() {
          return this.detached;
        }
        /**
         * @internal
         */
        get disposed() {
          return this.detached;
        }
        /**
         * Adds a `<script>` tag into the page with the desired url or content.
         *
         * @param options - Options for the script.
         * @returns An {@link ElementHandle | element handle} to the injected
         * `<script>` element.
         */
        async addScriptTag(options) {
          let { content = "", type } = options;
          const { path } = options;
          if (+!!options.url + +!!path + +!!content !== 1) {
            throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
          }
          if (path) {
            content = await environment.value.fs.promises.readFile(path, "utf8");
            content += `//# sourceURL=${path.replace(/\n/g, "")}`;
          }
          type = type ?? "text/javascript";
          return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, id, type: type2, content: content2 }) => {
            return await new Promise((resolve, reject) => {
              const script = document.createElement("script");
              script.type = type2;
              script.text = content2;
              script.addEventListener("error", (event) => {
                reject(new Error(event.message ?? "Could not load script"));
              }, { once: true });
              if (id) {
                script.id = id;
              }
              if (url) {
                script.src = url;
                script.addEventListener("load", () => {
                  resolve(script);
                }, { once: true });
                document.head.appendChild(script);
              } else {
                document.head.appendChild(script);
                resolve(script);
              }
            });
          }, { ...options, type, content }));
        }
        /**
         * @internal
         */
        async addStyleTag(options) {
          let { content = "" } = options;
          const { path } = options;
          if (+!!options.url + +!!path + +!!content !== 1) {
            throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
          }
          if (path) {
            content = await environment.value.fs.promises.readFile(path, "utf8");
            content += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
            options.content = content;
          }
          return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, content: content2 }) => {
            return await new Promise((resolve, reject) => {
              let element;
              if (!url) {
                element = document.createElement("style");
                element.appendChild(document.createTextNode(content2));
              } else {
                const link = document.createElement("link");
                link.rel = "stylesheet";
                link.href = url;
                element = link;
              }
              element.addEventListener("load", () => {
                resolve(element);
              }, { once: true });
              element.addEventListener("error", (event) => {
                reject(new Error(event.message ?? "Could not load style"));
              }, { once: true });
              document.head.appendChild(element);
              return element;
            });
          }, options));
        }
        /**
         * Clicks the first element found that matches `selector`.
         *
         * @remarks
         * If `click()` triggers a navigation event and there's a separate
         * `page.waitForNavigation()` promise to be resolved, you may end up with a
         * race condition that yields unexpected results. The correct pattern for
         * click and wait for navigation is the following:
         *
         * ```ts
         * const [response] = await Promise.all([
         *   page.waitForNavigation(waitOptions),
         *   frame.click(selector, clickOptions),
         * ]);
         * ```
         *
         * @param selector - The selector to query for.
         */
        async click(selector, options = {}) {
          const env_3 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource7(env_3, await this.$(selector), false);
            assert(handle, `No element found for selector: ${selector}`);
            await handle.click(options);
            await handle.dispose();
          } catch (e_3) {
            env_3.error = e_3;
            env_3.hasError = true;
          } finally {
            __disposeResources7(env_3);
          }
        }
        /**
         * Focuses the first element that matches the `selector`.
         *
         * @param selector - The selector to query for.
         * @throws Throws if there's no element matching `selector`.
         */
        async focus(selector) {
          const env_4 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource7(env_4, await this.$(selector), false);
            assert(handle, `No element found for selector: ${selector}`);
            await handle.focus();
          } catch (e_4) {
            env_4.error = e_4;
            env_4.hasError = true;
          } finally {
            __disposeResources7(env_4);
          }
        }
        /**
         * Hovers the pointer over the center of the first element that matches the
         * `selector`.
         *
         * @param selector - The selector to query for.
         * @throws Throws if there's no element matching `selector`.
         */
        async hover(selector) {
          const env_5 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource7(env_5, await this.$(selector), false);
            assert(handle, `No element found for selector: ${selector}`);
            await handle.hover();
          } catch (e_5) {
            env_5.error = e_5;
            env_5.hasError = true;
          } finally {
            __disposeResources7(env_5);
          }
        }
        /**
         * Selects a set of value on the first `<select>` element that matches the
         * `selector`.
         *
         * @example
         *
         * ```ts
         * frame.select('select#colors', 'blue'); // single selection
         * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
         * ```
         *
         * @param selector - The selector to query for.
         * @param values - The array of values to select. If the `<select>` has the
         * `multiple` attribute, all values are considered, otherwise only the first
         * one is taken into account.
         * @returns the list of values that were successfully selected.
         * @throws Throws if there's no `<select>` matching `selector`.
         */
        async select(selector, ...values) {
          const env_6 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource7(env_6, await this.$(selector), false);
            assert(handle, `No element found for selector: ${selector}`);
            return await handle.select(...values);
          } catch (e_6) {
            env_6.error = e_6;
            env_6.hasError = true;
          } finally {
            __disposeResources7(env_6);
          }
        }
        /**
         * Taps the first element that matches the `selector`.
         *
         * @param selector - The selector to query for.
         * @throws Throws if there's no element matching `selector`.
         */
        async tap(selector) {
          const env_7 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource7(env_7, await this.$(selector), false);
            assert(handle, `No element found for selector: ${selector}`);
            await handle.tap();
          } catch (e_7) {
            env_7.error = e_7;
            env_7.hasError = true;
          } finally {
            __disposeResources7(env_7);
          }
        }
        /**
         * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
         * in the text.
         *
         * @remarks
         * To press a special key, like `Control` or `ArrowDown`, use
         * {@link Keyboard.press}.
         *
         * @example
         *
         * ```ts
         * await frame.type('#mytextarea', 'Hello'); // Types instantly
         * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
         * ```
         *
         * @param selector - the selector for the element to type into. If there are
         * multiple the first will be used.
         * @param text - text to type into the element
         * @param options - takes one option, `delay`, which sets the time to wait
         * between key presses in milliseconds. Defaults to `0`.
         */
        async type(selector, text, options) {
          const env_8 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource7(env_8, await this.$(selector), false);
            assert(handle, `No element found for selector: ${selector}`);
            await handle.type(text, options);
          } catch (e_8) {
            env_8.error = e_8;
            env_8.hasError = true;
          } finally {
            __disposeResources7(env_8);
          }
        }
        /**
         * The frame's title.
         */
        async title() {
          return await this.isolatedRealm().evaluate(() => {
            return document.title;
          });
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js
function headersArray(headers) {
  const result = [];
  for (const name in headers) {
    const value = headers[name];
    if (!Object.is(value, void 0)) {
      const values = Array.isArray(value) ? value : [value];
      result.push(...values.map((value2) => {
        return { name, value: value2 + "" };
      }));
    }
  }
  return result;
}
function handleError(error) {
  if (error.originalMessage.includes("Invalid header") || error.originalMessage.includes("Unsafe header") || error.originalMessage.includes('Expected "header"') || // WebDriver BiDi error for invalid values, for example, headers.
  error.originalMessage.includes("invalid argument")) {
    throw error;
  }
  debugError(error);
}
var HTTPRequest, InterceptResolutionAction, STATUS_TEXTS, errorReasons;
var init_HTTPRequest = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js"() {
    init_util();
    init_assert();
    init_encoding();
    HTTPRequest = class {
      /**
       * @internal
       */
      _interceptionId;
      /**
       * @internal
       */
      _failureText = null;
      /**
       * @internal
       */
      _response = null;
      /**
       * @internal
       */
      _fromMemoryCache = false;
      /**
       * @internal
       */
      _redirectChain = [];
      /**
       * @internal
       */
      interception = {
        enabled: false,
        handled: false,
        handlers: [],
        resolutionState: {
          action: InterceptResolutionAction.None
        },
        requestOverrides: {},
        response: null,
        abortReason: null
      };
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * The `ContinueRequestOverrides` that will be used
       * if the interception is allowed to continue (ie, `abort()` and
       * `respond()` aren't called).
       */
      continueRequestOverrides() {
        assert(this.interception.enabled, "Request Interception is not enabled!");
        return this.interception.requestOverrides;
      }
      /**
       * The `ResponseForRequest` that gets used if the
       * interception is allowed to respond (ie, `abort()` is not called).
       */
      responseForRequest() {
        assert(this.interception.enabled, "Request Interception is not enabled!");
        return this.interception.response;
      }
      /**
       * The most recent reason for aborting the request
       */
      abortErrorReason() {
        assert(this.interception.enabled, "Request Interception is not enabled!");
        return this.interception.abortReason;
      }
      /**
       * An InterceptResolutionState object describing the current resolution
       * action and priority.
       *
       * InterceptResolutionState contains:
       * action: InterceptResolutionAction
       * priority?: number
       *
       * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
       * `disabled`, `none`, or `already-handled`.
       */
      interceptResolutionState() {
        if (!this.interception.enabled) {
          return { action: InterceptResolutionAction.Disabled };
        }
        if (this.interception.handled) {
          return { action: InterceptResolutionAction.AlreadyHandled };
        }
        return { ...this.interception.resolutionState };
      }
      /**
       * Is `true` if the intercept resolution has already been handled,
       * `false` otherwise.
       */
      isInterceptResolutionHandled() {
        return this.interception.handled;
      }
      /**
       * Adds an async request handler to the processing queue.
       * Deferred handlers are not guaranteed to execute in any particular order,
       * but they are guaranteed to resolve before the request interception
       * is finalized.
       */
      enqueueInterceptAction(pendingHandler) {
        this.interception.handlers.push(pendingHandler);
      }
      /**
       * Awaits pending interception handlers and then decides how to fulfill
       * the request interception.
       */
      async finalizeInterceptions() {
        await this.interception.handlers.reduce((promiseChain, interceptAction) => {
          return promiseChain.then(interceptAction);
        }, Promise.resolve());
        this.interception.handlers = [];
        const { action } = this.interceptResolutionState();
        switch (action) {
          case "abort":
            return await this._abort(this.interception.abortReason);
          case "respond":
            if (this.interception.response === null) {
              throw new Error("Response is missing for the interception");
            }
            return await this._respond(this.interception.response);
          case "continue":
            return await this._continue(this.interception.requestOverrides);
        }
      }
      #canBeIntercepted() {
        return !this.url().startsWith("data:") && !this._fromMemoryCache;
      }
      /**
       * Continues request with optional request overrides.
       *
       * @example
       *
       * ```ts
       * await page.setRequestInterception(true);
       * page.on('request', request => {
       *   // Override headers
       *   const headers = Object.assign({}, request.headers(), {
       *     foo: 'bar', // set "foo" header
       *     origin: undefined, // remove "origin" header
       *   });
       *   request.continue({headers});
       * });
       * ```
       *
       * @param overrides - optional overrides to apply to the request.
       * @param priority - If provided, intercept is resolved using cooperative
       * handling rules. Otherwise, intercept is resolved immediately.
       *
       * @remarks
       *
       * To use this, request interception should be enabled with
       * {@link Page.setRequestInterception}.
       *
       * Exception is immediately thrown if the request interception is not enabled.
       */
      async continue(overrides = {}, priority) {
        if (!this.#canBeIntercepted()) {
          return;
        }
        assert(this.interception.enabled, "Request Interception is not enabled!");
        assert(!this.interception.handled, "Request is already handled!");
        if (priority === void 0) {
          return await this._continue(overrides);
        }
        this.interception.requestOverrides = overrides;
        if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
          this.interception.resolutionState = {
            action: InterceptResolutionAction.Continue,
            priority
          };
          return;
        }
        if (priority === this.interception.resolutionState.priority) {
          if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond") {
            return;
          }
          this.interception.resolutionState.action = InterceptResolutionAction.Continue;
        }
        return;
      }
      /**
       * Fulfills a request with the given response.
       *
       * @example
       * An example of fulfilling all requests with 404 responses:
       *
       * ```ts
       * await page.setRequestInterception(true);
       * page.on('request', request => {
       *   request.respond({
       *     status: 404,
       *     contentType: 'text/plain',
       *     body: 'Not Found!',
       *   });
       * });
       * ```
       *
       * NOTE: Mocking responses for dataURL requests is not supported.
       * Calling `request.respond` for a dataURL request is a noop.
       *
       * @param response - the response to fulfill the request with.
       * @param priority - If provided, intercept is resolved using
       * cooperative handling rules. Otherwise, intercept is resolved
       * immediately.
       *
       * @remarks
       *
       * To use this, request
       * interception should be enabled with {@link Page.setRequestInterception}.
       *
       * Exception is immediately thrown if the request interception is not enabled.
       */
      async respond(response, priority) {
        if (!this.#canBeIntercepted()) {
          return;
        }
        assert(this.interception.enabled, "Request Interception is not enabled!");
        assert(!this.interception.handled, "Request is already handled!");
        if (priority === void 0) {
          return await this._respond(response);
        }
        this.interception.response = response;
        if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
          this.interception.resolutionState = {
            action: InterceptResolutionAction.Respond,
            priority
          };
          return;
        }
        if (priority === this.interception.resolutionState.priority) {
          if (this.interception.resolutionState.action === "abort") {
            return;
          }
          this.interception.resolutionState.action = InterceptResolutionAction.Respond;
        }
      }
      /**
       * Aborts a request.
       *
       * @param errorCode - optional error code to provide.
       * @param priority - If provided, intercept is resolved using
       * cooperative handling rules. Otherwise, intercept is resolved
       * immediately.
       *
       * @remarks
       *
       * To use this, request interception should be enabled with
       * {@link Page.setRequestInterception}. If it is not enabled, this method will
       * throw an exception immediately.
       */
      async abort(errorCode = "failed", priority) {
        if (!this.#canBeIntercepted()) {
          return;
        }
        const errorReason = errorReasons[errorCode];
        assert(errorReason, "Unknown error code: " + errorCode);
        assert(this.interception.enabled, "Request Interception is not enabled!");
        assert(!this.interception.handled, "Request is already handled!");
        if (priority === void 0) {
          return await this._abort(errorReason);
        }
        this.interception.abortReason = errorReason;
        if (this.interception.resolutionState.priority === void 0 || priority >= this.interception.resolutionState.priority) {
          this.interception.resolutionState = {
            action: InterceptResolutionAction.Abort,
            priority
          };
          return;
        }
      }
      /**
       * @internal
       */
      static getResponse(body) {
        const byteBody = isString(body) ? new TextEncoder().encode(body) : body;
        return {
          contentLength: byteBody.byteLength,
          base64: typedArrayToBase64(byteBody)
        };
      }
    };
    (function(InterceptResolutionAction2) {
      InterceptResolutionAction2["Abort"] = "abort";
      InterceptResolutionAction2["Respond"] = "respond";
      InterceptResolutionAction2["Continue"] = "continue";
      InterceptResolutionAction2["Disabled"] = "disabled";
      InterceptResolutionAction2["None"] = "none";
      InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
    })(InterceptResolutionAction || (InterceptResolutionAction = {}));
    STATUS_TEXTS = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "Switch Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    errorReasons = {
      aborted: "Aborted",
      accessdenied: "AccessDenied",
      addressunreachable: "AddressUnreachable",
      blockedbyclient: "BlockedByClient",
      blockedbyresponse: "BlockedByResponse",
      connectionaborted: "ConnectionAborted",
      connectionclosed: "ConnectionClosed",
      connectionfailed: "ConnectionFailed",
      connectionrefused: "ConnectionRefused",
      connectionreset: "ConnectionReset",
      internetdisconnected: "InternetDisconnected",
      namenotresolved: "NameNotResolved",
      timedout: "TimedOut",
      failed: "Failed"
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js
var HTTPResponse;
var init_HTTPResponse = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js"() {
    HTTPResponse = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * True if the response was successful (status in the range 200-299).
       */
      ok() {
        const status = this.status();
        return status === 0 || status >= 200 && status <= 299;
      }
      /**
       * {@inheritDoc HTTPResponse.content}
       */
      async buffer() {
        const content = await this.content();
        return Buffer.from(content);
      }
      /**
       * Promise which resolves to a text (utf8) representation of response body.
       */
      async text() {
        const content = await this.content();
        return new TextDecoder().decode(content);
      }
      /**
       * Promise which resolves to a JSON representation of response body.
       *
       * @remarks
       *
       * This method will throw if the response body is not parsable via
       * `JSON.parse`.
       */
      async json() {
        const content = await this.text();
        return JSON.parse(content);
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/incremental-id-generator.js
function createIncrementalIdGenerator() {
  let id = 0;
  return () => {
    return ++id;
  };
}
var init_incremental_id_generator = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/util/incremental-id-generator.js"() {
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js
var Keyboard, MouseButton, Mouse, Touchscreen;
var init_Input = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js"() {
    init_Errors();
    init_incremental_id_generator();
    Keyboard = class {
      /**
       * @internal
       */
      constructor() {
      }
    };
    MouseButton = Object.freeze({
      Left: "left",
      Right: "right",
      Middle: "middle",
      Back: "back",
      Forward: "forward"
    });
    Mouse = class {
      /**
       * @internal
       */
      constructor() {
      }
    };
    Touchscreen = class {
      /**
       * @internal
       */
      idGenerator = createIncrementalIdGenerator();
      /**
       * @internal
       */
      touches = [];
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * @internal
       */
      removeHandle(handle) {
        const index = this.touches.indexOf(handle);
        if (index === -1) {
          return;
        }
        this.touches.splice(index, 1);
      }
      /**
       * Dispatches a `touchstart` and `touchend` event.
       * @param x - Horizontal position of the tap.
       * @param y - Vertical position of the tap.
       */
      async tap(x, y) {
        const touch = await this.touchStart(x, y);
        await touch.end();
      }
      /**
       * Dispatches a `touchMove` event on the first touch that is active.
       * @param x - Horizontal position of the move.
       * @param y - Vertical position of the move.
       *
       * @remarks
       *
       * Not every `touchMove` call results in a `touchmove` event being emitted,
       * depending on the browser's optimizations. For example, Chrome
       * {@link https://developer.chrome.com/blog/a-more-compatible-smoother-touch/#chromes-new-model-the-throttled-async-touchmove-model | throttles}
       * touch move events.
       */
      async touchMove(x, y) {
        const touch = this.touches[0];
        if (!touch) {
          throw new TouchError("Must start a new Touch first");
        }
        return await touch.move(x, y);
      }
      /**
       * Dispatches a `touchend` event on the first touch that is active.
       */
      async touchEnd() {
        const touch = this.touches.shift();
        if (!touch) {
          throw new TouchError("Must start a new Touch first");
        }
        await touch.end();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js
var DEFAULT_TIMEOUT, TimeoutSettings;
var init_TimeoutSettings = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js"() {
    DEFAULT_TIMEOUT = 3e4;
    TimeoutSettings = class {
      #defaultTimeout;
      #defaultNavigationTimeout;
      constructor() {
        this.#defaultTimeout = null;
        this.#defaultNavigationTimeout = null;
      }
      setDefaultTimeout(timeout2) {
        this.#defaultTimeout = timeout2;
      }
      setDefaultNavigationTimeout(timeout2) {
        this.#defaultNavigationTimeout = timeout2;
      }
      navigationTimeout() {
        if (this.#defaultNavigationTimeout !== null) {
          return this.#defaultNavigationTimeout;
        }
        if (this.#defaultTimeout !== null) {
          return this.#defaultTimeout;
        }
        return DEFAULT_TIMEOUT;
      }
      timeout() {
        if (this.#defaultTimeout !== null) {
          return this.#defaultTimeout;
        }
        return DEFAULT_TIMEOUT;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js
function setDefaultScreenshotOptions(options) {
  options.optimizeForSpeed ??= false;
  options.type ??= "png";
  options.fromSurface ??= true;
  options.fullPage ??= false;
  options.omitBackground ??= false;
  options.encoding ??= "binary";
  options.captureBeyondViewport ??= true;
}
function normalizeRectangle(clip) {
  return {
    ...clip,
    ...clip.width < 0 ? {
      x: clip.x + clip.width,
      width: -clip.width
    } : {
      x: clip.x,
      width: clip.width
    },
    ...clip.height < 0 ? {
      y: clip.y + clip.height,
      height: -clip.height
    } : {
      y: clip.y,
      height: clip.height
    }
  };
}
function roundRectangle(clip) {
  const x = Math.round(clip.x);
  const y = Math.round(clip.y);
  const width = Math.round(clip.width + clip.x - x);
  const height = Math.round(clip.height + clip.y - y);
  return { ...clip, x, y, width, height };
}
var __runInitializers4, __esDecorate4, __addDisposableResource8, __disposeResources8, Page;
var init_Page = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js"() {
    init_rxjs();
    init_Errors();
    init_EventEmitter();
    init_TimeoutSettings();
    init_util();
    init_environment();
    init_decorators();
    init_disposable();
    init_encoding();
    init_locators();
    __runInitializers4 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __addDisposableResource8 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources8 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    Page = (() => {
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _screenshot_decorators;
      return class Page extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate4(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        /**
         * @internal
         */
        _isDragging = (__runInitializers4(this, _instanceExtraInitializers), false);
        /**
         * @internal
         */
        _timeoutSettings = new TimeoutSettings();
        #requestHandlers = /* @__PURE__ */ new WeakMap();
        #inflight$ = new ReplaySubject(1);
        /**
         * @internal
         */
        constructor() {
          super();
          fromEmitterEvent(
            this,
            "request"
            /* PageEvent.Request */
          ).pipe(mergeMap((originalRequest) => {
            return concat(of(1), merge(fromEmitterEvent(
              this,
              "requestfailed"
              /* PageEvent.RequestFailed */
            ), fromEmitterEvent(
              this,
              "requestfinished"
              /* PageEvent.RequestFinished */
            ), fromEmitterEvent(
              this,
              "response"
              /* PageEvent.Response */
            ).pipe(map((response) => {
              return response.request();
            }))).pipe(filter((request) => {
              return request.id === originalRequest.id;
            }), take(1), map(() => {
              return -1;
            })));
          }), mergeScan((acc, addend) => {
            return of(acc + addend);
          }, 0), takeUntil(fromEmitterEvent(
            this,
            "close"
            /* PageEvent.Close */
          )), startWith(0)).subscribe(this.#inflight$);
        }
        /**
         * Listen to page events.
         *
         * @remarks
         * This method exists to define event typings and handle proper wireup of
         * cooperative request interception. Actual event listening and dispatching is
         * delegated to {@link EventEmitter}.
         *
         * @internal
         */
        on(type, handler) {
          if (type !== "request") {
            return super.on(type, handler);
          }
          let wrapper = this.#requestHandlers.get(handler);
          if (wrapper === void 0) {
            wrapper = (event) => {
              event.enqueueInterceptAction(() => {
                return handler(event);
              });
            };
            this.#requestHandlers.set(handler, wrapper);
          }
          return super.on(type, wrapper);
        }
        /**
         * @internal
         */
        off(type, handler) {
          if (type === "request") {
            handler = this.#requestHandlers.get(handler) || handler;
          }
          return super.off(type, handler);
        }
        /**
         * {@inheritDoc Accessibility}
         */
        get accessibility() {
          return this.mainFrame().accessibility;
        }
        locator(selectorOrFunc) {
          if (typeof selectorOrFunc === "string") {
            return NodeLocator.create(this, selectorOrFunc);
          } else {
            return FunctionLocator.create(this, selectorOrFunc);
          }
        }
        /**
         * A shortcut for {@link Locator.race} that does not require static imports.
         *
         * @internal
         */
        locatorRace(locators) {
          return Locator.race(locators);
        }
        /**
         * Finds the first element that matches the selector. If no element matches
         * the selector, the return value resolves to `null`.
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         *
         * @remarks
         *
         * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.
         */
        async $(selector) {
          return await this.mainFrame().$(selector);
        }
        /**
         * Finds elements on the page that match the selector. If no elements
         * match the selector, the return value resolves to `[]`.
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         *
         * @remarks
         *
         * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
         */
        async $$(selector, options) {
          return await this.mainFrame().$$(selector, options);
        }
        /**
         * @remarks
         *
         * The only difference between {@link Page.evaluate | page.evaluate} and
         * `page.evaluateHandle` is that `evaluateHandle` will return the value
         * wrapped in an in-page object.
         *
         * If the function passed to `page.evaluateHandle` returns a Promise, the
         * function will wait for the promise to resolve and return its value.
         *
         * You can pass a string instead of a function (although functions are
         * recommended as they are easier to debug and use with TypeScript):
         *
         * @example
         *
         * ```ts
         * const aHandle = await page.evaluateHandle('document');
         * ```
         *
         * @example
         * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
         *
         * ```ts
         * const aHandle = await page.evaluateHandle(() => document.body);
         * const resultHandle = await page.evaluateHandle(
         *   body => body.innerHTML,
         *   aHandle,
         * );
         * console.log(await resultHandle.jsonValue());
         * await resultHandle.dispose();
         * ```
         *
         * Most of the time this function returns a {@link JSHandle},
         * but if `pageFunction` returns a reference to an element,
         * you instead get an {@link ElementHandle} back:
         *
         * @example
         *
         * ```ts
         * const button = await page.evaluateHandle(() =>
         *   document.querySelector('button'),
         * );
         * // can call `click` because `button` is an `ElementHandle`
         * await button.click();
         * ```
         *
         * The TypeScript definitions assume that `evaluateHandle` returns
         * a `JSHandle`, but if you know it's going to return an
         * `ElementHandle`, pass it as the generic argument:
         *
         * ```ts
         * const button = await page.evaluateHandle<ElementHandle>(...);
         * ```
         *
         * @param pageFunction - a function that is run within the page
         * @param args - arguments to be passed to the pageFunction
         */
        async evaluateHandle(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
          return await this.mainFrame().evaluateHandle(pageFunction, ...args);
        }
        /**
         * This method finds the first element within the page that matches the selector
         * and passes the result as the first argument to the `pageFunction`.
         *
         * @remarks
         *
         * If no element is found matching `selector`, the method will throw an error.
         *
         * If `pageFunction` returns a promise `$eval` will wait for the promise to
         * resolve and then return its value.
         *
         * @example
         *
         * ```ts
         * const searchValue = await page.$eval('#search', el => el.value);
         * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
         * const html = await page.$eval('.main-container', el => el.outerHTML);
         * ```
         *
         * If you are using TypeScript, you may have to provide an explicit type to the
         * first argument of the `pageFunction`.
         * By default it is typed as `Element`, but you may need to provide a more
         * specific sub-type:
         *
         * @example
         *
         * ```ts
         * // if you don't provide HTMLInputElement here, TS will error
         * // as `value` is not on `Element`
         * const searchValue = await page.$eval(
         *   '#search',
         *   (el: HTMLInputElement) => el.value,
         * );
         * ```
         *
         * The compiler should be able to infer the return type
         * from the `pageFunction` you provide. If it is unable to, you can use the generic
         * type to tell the compiler what return type you expect from `$eval`:
         *
         * @example
         *
         * ```ts
         * // The compiler can infer the return type in this case, but if it can't
         * // or if you want to be more explicit, provide it as the generic type.
         * const searchValue = await page.$eval<string>(
         *   '#search',
         *   (el: HTMLInputElement) => el.value,
         * );
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param pageFunction - the function to be evaluated in the page context.
         * Will be passed the result of the element matching the selector as its
         * first argument.
         * @param args - any additional arguments to pass through to `pageFunction`.
         *
         * @returns The result of calling `pageFunction`. If it returns an element it
         * is wrapped in an {@link ElementHandle}, else the raw value itself is
         * returned.
         */
        async $eval(selector, pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
          return await this.mainFrame().$eval(selector, pageFunction, ...args);
        }
        /**
         * This method returns all elements matching the selector and passes the
         * resulting array as the first argument to the `pageFunction`.
         *
         * @remarks
         * If `pageFunction` returns a promise `$$eval` will wait for the promise to
         * resolve and then return its value.
         *
         * @example
         *
         * ```ts
         * // get the amount of divs on the page
         * const divCount = await page.$$eval('div', divs => divs.length);
         *
         * // get the text content of all the `.options` elements:
         * const options = await page.$$eval('div > span.options', options => {
         *   return options.map(option => option.textContent);
         * });
         * ```
         *
         * If you are using TypeScript, you may have to provide an explicit type to the
         * first argument of the `pageFunction`.
         * By default it is typed as `Element[]`, but you may need to provide a more
         * specific sub-type:
         *
         * @example
         *
         * ```ts
         * await page.$$eval('input', elements => {
         *   return elements.map(e => e.value);
         * });
         * ```
         *
         * The compiler should be able to infer the return type
         * from the `pageFunction` you provide. If it is unable to, you can use the generic
         * type to tell the compiler what return type you expect from `$$eval`:
         *
         * @example
         *
         * ```ts
         * const allInputValues = await page.$$eval('input', elements =>
         *   elements.map(e => e.textContent),
         * );
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param pageFunction - the function to be evaluated in the page context.
         * Will be passed an array of matching elements as its first argument.
         * @param args - any additional arguments to pass through to `pageFunction`.
         *
         * @returns The result of calling `pageFunction`. If it returns an element it
         * is wrapped in an {@link ElementHandle}, else the raw value itself is
         * returned.
         */
        async $$eval(selector, pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
          return await this.mainFrame().$$eval(selector, pageFunction, ...args);
        }
        /**
         * Adds a `<script>` tag into the page with the desired URL or content.
         *
         * @remarks
         * Shortcut for
         * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
         *
         * @param options - Options for the script.
         * @returns An {@link ElementHandle | element handle} to the injected
         * `<script>` element.
         */
        async addScriptTag(options) {
          return await this.mainFrame().addScriptTag(options);
        }
        async addStyleTag(options) {
          return await this.mainFrame().addStyleTag(options);
        }
        /**
         * The page's URL.
         *
         * @remarks
         *
         * Shortcut for {@link Frame.url | page.mainFrame().url()}.
         */
        url() {
          return this.mainFrame().url();
        }
        /**
         * The full HTML contents of the page, including the DOCTYPE.
         */
        async content() {
          return await this.mainFrame().content();
        }
        /**
         * Set the content of the page.
         *
         * @param html - HTML markup to assign to the page.
         * @param options - Parameters that has some properties.
         */
        async setContent(html, options) {
          await this.mainFrame().setContent(html, options);
        }
        /**
         * {@inheritDoc Frame.goto}
         */
        async goto(url, options) {
          return await this.mainFrame().goto(url, options);
        }
        /**
         * Waits for the page to navigate to a new URL or to reload. It is useful when
         * you run code that will indirectly cause the page to navigate.
         *
         * @example
         *
         * ```ts
         * const [response] = await Promise.all([
         *   page.waitForNavigation(), // The promise resolves after navigation has finished
         *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
         * ]);
         * ```
         *
         * @remarks
         *
         * Usage of the
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
         * to change the URL is considered a navigation.
         *
         * @param options - Navigation parameters which might have the following
         * properties:
         * @returns A `Promise` which resolves to the main resource response.
         *
         * - In case of multiple redirects, the navigation will resolve with the
         *   response of the last redirect.
         * - In case of navigation to a different anchor or navigation due to History
         *   API usage, the navigation will resolve with `null`.
         */
        async waitForNavigation(options = {}) {
          return await this.mainFrame().waitForNavigation(options);
        }
        /**
         * @param urlOrPredicate - A URL or predicate to wait for
         * @param options - Optional waiting parameters
         * @returns Promise which resolves to the matched request
         * @example
         *
         * ```ts
         * const firstRequest = await page.waitForRequest(
         *   'https://example.com/resource',
         * );
         * const finalRequest = await page.waitForRequest(
         *   request => request.url() === 'https://example.com',
         * );
         * return finalRequest.response()?.ok();
         * ```
         *
         * @remarks
         * Optional Waiting Parameters have:
         *
         * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass
         *   `0` to disable the timeout. The default value can be changed by using the
         *   {@link Page.setDefaultTimeout} method.
         */
        waitForRequest(urlOrPredicate, options = {}) {
          const { timeout: ms = this._timeoutSettings.timeout(), signal } = options;
          if (typeof urlOrPredicate === "string") {
            const url = urlOrPredicate;
            urlOrPredicate = (request) => {
              return request.url() === url;
            };
          }
          const observable$ = fromEmitterEvent(
            this,
            "request"
            /* PageEvent.Request */
          ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(
            this,
            "close"
            /* PageEvent.Close */
          ).pipe(map(() => {
            throw new TargetCloseError("Page closed!");
          }))));
          return firstValueFrom(observable$);
        }
        /**
         * @param urlOrPredicate - A URL or predicate to wait for.
         * @param options - Optional waiting parameters
         * @returns Promise which resolves to the matched response.
         * @example
         *
         * ```ts
         * const firstResponse = await page.waitForResponse(
         *   'https://example.com/resource',
         * );
         * const finalResponse = await page.waitForResponse(
         *   response =>
         *     response.url() === 'https://example.com' && response.status() === 200,
         * );
         * const finalResponse = await page.waitForResponse(async response => {
         *   return (await response.text()).includes('<html>');
         * });
         * return finalResponse.ok();
         * ```
         *
         * @remarks
         * Optional Parameter have:
         *
         * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,
         *   pass `0` to disable the timeout. The default value can be changed by using
         *   the {@link Page.setDefaultTimeout} method.
         */
        waitForResponse(urlOrPredicate, options = {}) {
          const { timeout: ms = this._timeoutSettings.timeout(), signal } = options;
          if (typeof urlOrPredicate === "string") {
            const url = urlOrPredicate;
            urlOrPredicate = (response) => {
              return response.url() === url;
            };
          }
          const observable$ = fromEmitterEvent(
            this,
            "response"
            /* PageEvent.Response */
          ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(
            this,
            "close"
            /* PageEvent.Close */
          ).pipe(map(() => {
            throw new TargetCloseError("Page closed!");
          }))));
          return firstValueFrom(observable$);
        }
        /**
         * Waits for the network to be idle.
         *
         * @param options - Options to configure waiting behavior.
         * @returns A promise which resolves once the network is idle.
         */
        waitForNetworkIdle(options = {}) {
          return firstValueFrom(this.waitForNetworkIdle$(options));
        }
        /**
         * @internal
         */
        waitForNetworkIdle$(options = {}) {
          const { timeout: ms = this._timeoutSettings.timeout(), idleTime = NETWORK_IDLE_TIME, concurrency = 0, signal } = options;
          return this.#inflight$.pipe(switchMap((inflight) => {
            if (inflight > concurrency) {
              return EMPTY;
            }
            return timer(idleTime);
          }), map(() => {
          }), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(
            this,
            "close"
            /* PageEvent.Close */
          ).pipe(map(() => {
            throw new TargetCloseError("Page closed!");
          }))));
        }
        /**
         * Waits for a frame matching the given conditions to appear.
         *
         * @example
         *
         * ```ts
         * const frame = await page.waitForFrame(async frame => {
         *   return frame.name() === 'Test';
         * });
         * ```
         */
        async waitForFrame(urlOrPredicate, options = {}) {
          const { timeout: ms = this.getDefaultTimeout(), signal } = options;
          const predicate = isString(urlOrPredicate) ? (frame) => {
            return urlOrPredicate === frame.url();
          } : urlOrPredicate;
          return await firstValueFrom(merge(fromEmitterEvent(
            this,
            "frameattached"
            /* PageEvent.FrameAttached */
          ), fromEmitterEvent(
            this,
            "framenavigated"
            /* PageEvent.FrameNavigated */
          ), from(this.frames())).pipe(filterAsync(predicate), first(), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(
            this,
            "close"
            /* PageEvent.Close */
          ).pipe(map(() => {
            throw new TargetCloseError("Page closed.");
          })))));
        }
        /**
         * Emulates a given device's metrics and user agent.
         *
         * To aid emulation, Puppeteer provides a list of known devices that can be
         * via {@link KnownDevices}.
         *
         * @remarks
         * This method is a shortcut for calling two methods:
         * {@link Page.setUserAgent} and {@link Page.setViewport}.
         *
         * This method will resize the page. A lot of websites don't expect phones to
         * change size, so you should emulate before navigating to the page.
         *
         * @example
         *
         * ```ts
         * import {KnownDevices} from 'puppeteer';
         * const iPhone = KnownDevices['iPhone 15 Pro'];
         *
         * (async () => {
         *   const browser = await puppeteer.launch();
         *   const page = await browser.newPage();
         *   await page.emulate(iPhone);
         *   await page.goto('https://www.google.com');
         *   // other actions...
         *   await browser.close();
         * })();
         * ```
         */
        async emulate(device) {
          await Promise.all([
            this.setUserAgent(device.userAgent),
            this.setViewport(device.viewport)
          ]);
        }
        /**
         * Evaluates a function in the page's context and returns the result.
         *
         * If the function passed to `page.evaluate` returns a Promise, the
         * function will wait for the promise to resolve and return its value.
         *
         * @example
         *
         * ```ts
         * const result = await frame.evaluate(() => {
         *   return Promise.resolve(8 * 7);
         * });
         * console.log(result); // prints "56"
         * ```
         *
         * You can pass a string instead of a function (although functions are
         * recommended as they are easier to debug and use with TypeScript):
         *
         * @example
         *
         * ```ts
         * const aHandle = await page.evaluate('1 + 2');
         * ```
         *
         * To get the best TypeScript experience, you should pass in as the
         * generic the type of `pageFunction`:
         *
         * ```ts
         * const aHandle = await page.evaluate(() => 2);
         * ```
         *
         * @example
         *
         * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
         * as arguments to the `pageFunction`:
         *
         * ```ts
         * const bodyHandle = await page.$('body');
         * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
         * await bodyHandle.dispose();
         * ```
         *
         * @param pageFunction - a function that is run within the page
         * @param args - arguments to be passed to the pageFunction
         *
         * @returns the return value of `pageFunction`.
         */
        async evaluate(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
          return await this.mainFrame().evaluate(pageFunction, ...args);
        }
        /**
         * @internal
         */
        async _maybeWriteTypedArrayToFile(path, typedArray) {
          if (!path) {
            return;
          }
          await environment.value.fs.promises.writeFile(path, typedArray);
        }
        /**
         * Captures a screencast of this {@link Page | page}.
         *
         * @example
         * Recording a {@link Page | page}:
         *
         * ```
         * import puppeteer from 'puppeteer';
         *
         * // Launch a browser
         * const browser = await puppeteer.launch();
         *
         * // Create a new page
         * const page = await browser.newPage();
         *
         * // Go to your site.
         * await page.goto("https://www.example.com");
         *
         * // Start recording.
         * const recorder = await page.screencast({path: 'recording.webm'});
         *
         * // Do something.
         *
         * // Stop recording.
         * await recorder.stop();
         *
         * browser.close();
         * ```
         *
         * @param options - Configures screencast behavior.
         *
         * @experimental
         *
         * @remarks
         *
         * All recordings will be {@link https://www.webmproject.org/ | WebM} format using
         * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.
         *
         * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
         */
        async screencast(options = {}) {
          const ScreenRecorder = environment.value.ScreenRecorder;
          const [width, height, devicePixelRatio] = await this.#getNativePixelDimensions();
          let crop;
          if (options.crop) {
            const { x, y, width: cropWidth, height: cropHeight } = roundRectangle(normalizeRectangle(options.crop));
            if (x < 0 || y < 0) {
              throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
            }
            if (cropWidth <= 0 || cropHeight <= 0) {
              throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
            }
            const viewportWidth = width / devicePixelRatio;
            const viewportHeight = height / devicePixelRatio;
            if (x + cropWidth > viewportWidth) {
              throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
            }
            if (y + cropHeight > viewportHeight) {
              throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
            }
            crop = {
              x: x * devicePixelRatio,
              y: y * devicePixelRatio,
              width: cropWidth * devicePixelRatio,
              height: cropHeight * devicePixelRatio
            };
          }
          if (options.speed !== void 0 && options.speed <= 0) {
            throw new Error(`\`speed\` must be greater than 0.`);
          }
          if (options.scale !== void 0 && options.scale <= 0) {
            throw new Error(`\`scale\` must be greater than 0.`);
          }
          const recorder = new ScreenRecorder(this, width, height, {
            ...options,
            path: options.ffmpegPath,
            crop
          });
          try {
            await this._startScreencast();
          } catch (error) {
            void recorder.stop();
            throw error;
          }
          if (options.path) {
            const { createWriteStream } = environment.value.fs;
            const stream = createWriteStream(options.path, "binary");
            recorder.pipe(stream);
          }
          return recorder;
        }
        #screencastSessionCount = 0;
        #startScreencastPromise;
        /**
         * @internal
         */
        async _startScreencast() {
          ++this.#screencastSessionCount;
          if (!this.#startScreencastPromise) {
            this.#startScreencastPromise = this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => {
              return new Promise((resolve) => {
                return this.mainFrame().client.once("Page.screencastFrame", () => {
                  return resolve();
                });
              });
            });
          }
          await this.#startScreencastPromise;
        }
        /**
         * @internal
         */
        async _stopScreencast() {
          --this.#screencastSessionCount;
          if (!this.#startScreencastPromise) {
            return;
          }
          this.#startScreencastPromise = void 0;
          if (this.#screencastSessionCount === 0) {
            await this.mainFrame().client.send("Page.stopScreencast");
          }
        }
        /**
         * Gets the native, non-emulated dimensions of the viewport.
         */
        async #getNativePixelDimensions() {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const viewport = this.viewport();
            const stack = __addDisposableResource8(env_1, new DisposableStack(), false);
            if (viewport && viewport.deviceScaleFactor !== 0) {
              await this.setViewport({ ...viewport, deviceScaleFactor: 0 });
              stack.defer(() => {
                void this.setViewport(viewport).catch(debugError);
              });
            }
            return await this.mainFrame().isolatedRealm().evaluate(() => {
              return [
                window.visualViewport.width * window.devicePixelRatio,
                window.visualViewport.height * window.devicePixelRatio,
                window.devicePixelRatio
              ];
            });
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources8(env_1);
          }
        }
        async screenshot(userOptions = {}) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const _guard = __addDisposableResource8(env_2, await this.browserContext().startScreenshot(), false);
            const options = {
              ...userOptions,
              clip: userOptions.clip ? {
                ...userOptions.clip
              } : void 0
            };
            if (options.type === void 0 && options.path !== void 0) {
              const filePath = options.path;
              const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
              switch (extension) {
                case "png":
                  options.type = "png";
                  break;
                case "jpeg":
                case "jpg":
                  options.type = "jpeg";
                  break;
                case "webp":
                  options.type = "webp";
                  break;
              }
            }
            if (options.quality !== void 0) {
              if (options.quality < 0 || options.quality > 100) {
                throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
              }
              if (options.type === void 0 || !["jpeg", "webp"].includes(options.type)) {
                throw new Error(`${options.type ?? "png"} screenshots do not support 'quality'.`);
              }
            }
            if (options.clip) {
              if (options.clip.width <= 0) {
                throw new Error("'width' in 'clip' must be positive.");
              }
              if (options.clip.height <= 0) {
                throw new Error("'height' in 'clip' must be positive.");
              }
            }
            setDefaultScreenshotOptions(options);
            const stack = __addDisposableResource8(env_2, new AsyncDisposableStack(), true);
            if (options.clip) {
              if (options.fullPage) {
                throw new Error("'clip' and 'fullPage' are mutually exclusive");
              }
              options.clip = roundRectangle(normalizeRectangle(options.clip));
            } else {
              if (options.fullPage) {
                if (!options.captureBeyondViewport) {
                  const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                    const element = document.documentElement;
                    return {
                      width: element.scrollWidth,
                      height: element.scrollHeight
                    };
                  });
                  const viewport = this.viewport();
                  await this.setViewport({
                    ...viewport,
                    ...scrollDimensions
                  });
                  stack.defer(async () => {
                    await this.setViewport(viewport).catch(debugError);
                  });
                }
              } else {
                options.captureBeyondViewport = false;
              }
            }
            const data = await this._screenshot(options);
            if (options.encoding === "base64") {
              return data;
            }
            const typedArray = stringToTypedArray(data, true);
            await this._maybeWriteTypedArrayToFile(options.path, typedArray);
            return typedArray;
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            const result_1 = __disposeResources8(env_2);
            if (result_1)
              await result_1;
          }
        }
        /**
         * The page's title
         *
         * @remarks
         *
         * Shortcut for {@link Frame.title | page.mainFrame().title()}.
         */
        async title() {
          return await this.mainFrame().title();
        }
        /**
         * This method fetches an element with `selector`, scrolls it into view if
         * needed, and then uses {@link Page.mouse} to click in the center of the
         * element. If there's no element matching `selector`, the method throws an
         * error.
         *
         * @remarks
         *
         * Bear in mind that if `click()` triggers a navigation event and
         * there's a separate `page.waitForNavigation()` promise to be resolved, you
         * may end up with a race condition that yields unexpected results. The
         * correct pattern for click and wait for navigation is the following:
         *
         * ```ts
         * const [response] = await Promise.all([
         *   page.waitForNavigation(waitOptions),
         *   page.click(selector, clickOptions),
         * ]);
         * ```
         *
         * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are
         * multiple elements satisfying the `selector`, the first will be clicked
         * @param options - `Object`
         * @returns Promise which resolves when the element matching `selector` is
         * successfully clicked. The Promise will be rejected if there is no element
         * matching `selector`.
         */
        click(selector, options) {
          return this.mainFrame().click(selector, options);
        }
        /**
         * This method fetches an element with `selector` and focuses it. If
         * there's no element matching `selector`, the method throws an error.
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * If there are multiple elements satisfying the selector, the first
         * will be focused.
         * @returns Promise which resolves when the element matching selector
         * is successfully focused. The promise will be rejected if there is
         * no element matching selector.
         *
         * @remarks
         *
         * Shortcut for
         * {@link Frame.focus | page.mainFrame().focus(selector)}.
         */
        focus(selector) {
          return this.mainFrame().focus(selector);
        }
        /**
         * This method fetches an element with `selector`, scrolls it into view if
         * needed, and then uses {@link Page.mouse}
         * to hover over the center of the element.
         * If there's no element matching `selector`, the method throws an error.
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are
         * multiple elements satisfying the `selector`, the first will be hovered.
         * @returns Promise which resolves when the element matching `selector` is
         * successfully hovered. Promise gets rejected if there's no element matching
         * `selector`.
         *
         * @remarks
         *
         * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
         */
        hover(selector) {
          return this.mainFrame().hover(selector);
        }
        /**
         * Triggers a `change` and `input` event once all the provided options have been
         * selected. If there's no `<select>` element matching `selector`, the method
         * throws an error.
         *
         * @example
         *
         * ```ts
         * page.select('select#colors', 'blue'); // single selection
         * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param values - Values of options to select. If the `<select>` has the
         * `multiple` attribute, all values are considered, otherwise only the first one
         * is taken into account.
         * @returns
         *
         * @remarks
         *
         * Shortcut for {@link Frame.select | page.mainFrame().select()}
         */
        select(selector, ...values) {
          return this.mainFrame().select(selector, ...values);
        }
        /**
         * This method fetches an element with `selector`, scrolls it into view if
         * needed, and then uses {@link Page.touchscreen}
         * to tap in the center of the element.
         * If there's no element matching `selector`, the method throws an error.
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}. If there are multiple elements satisfying the
         * selector, the first will be tapped.
         *
         * @remarks
         *
         * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
         */
        tap(selector) {
          return this.mainFrame().tap(selector);
        }
        /**
         * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
         * in the text.
         *
         * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
         * @example
         *
         * ```ts
         * await page.type('#mytextarea', 'Hello');
         * // Types instantly
         * await page.type('#mytextarea', 'World', {delay: 100});
         * // Types slower, like a user
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param text - A text to type into a focused element.
         * @param options - have property `delay` which is the Time to wait between
         * key presses in milliseconds. Defaults to `0`.
         * @returns
         */
        type(selector, text, options) {
          return this.mainFrame().type(selector, text, options);
        }
        /**
         * Wait for the `selector` to appear in page. If at the moment of calling the
         * method the `selector` already exists, the method will return immediately. If
         * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
         * function will throw.
         *
         * @example
         * This method works across navigations:
         *
         * ```ts
         * import puppeteer from 'puppeteer';
         * (async () => {
         *   const browser = await puppeteer.launch();
         *   const page = await browser.newPage();
         *   let currentURL;
         *   page
         *     .waitForSelector('img')
         *     .then(() => console.log('First URL with image: ' + currentURL));
         *   for (currentURL of [
         *     'https://example.com',
         *     'https://google.com',
         *     'https://bbc.com',
         *   ]) {
         *     await page.goto(currentURL);
         *   }
         *   await browser.close();
         * })();
         * ```
         *
         * @param selector -
         * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
         * to query the page for.
         * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
         * can be passed as-is and a
         * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
         * allows querying by
         * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
         * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
         * and
         * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
         * and
         * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
         * Alternatively, you can specify the selector type using a
         * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
         * @param options - Optional waiting parameters
         * @returns Promise which resolves when element specified by selector string
         * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
         * selector is not found in DOM.
         *
         * @remarks
         * The optional Parameter in Arguments `options` are:
         *
         * - `visible`: A boolean wait for element to be present in DOM and to be
         *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
         *   properties. Defaults to `false`.
         *
         * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
         *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
         *   `false`.
         *
         * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
         *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
         *   by using the {@link Page.setDefaultTimeout} method.
         */
        async waitForSelector(selector, options = {}) {
          return await this.mainFrame().waitForSelector(selector, options);
        }
        /**
         * Waits for the provided function, `pageFunction`, to return a truthy value when
         * evaluated in the page's context.
         *
         * @example
         * {@link Page.waitForFunction} can be used to observe a viewport size change:
         *
         * ```ts
         * import puppeteer from 'puppeteer';
         * (async () => {
         *   const browser = await puppeteer.launch();
         *   const page = await browser.newPage();
         *   const watchDog = page.waitForFunction('window.innerWidth < 100');
         *   await page.setViewport({width: 50, height: 50});
         *   await watchDog;
         *   await browser.close();
         * })();
         * ```
         *
         * @example
         * Arguments can be passed from Node.js to `pageFunction`:
         *
         * ```ts
         * const selector = '.foo';
         * await page.waitForFunction(
         *   selector => !!document.querySelector(selector),
         *   {},
         *   selector,
         * );
         * ```
         *
         * @example
         * The provided `pageFunction` can be asynchronous:
         *
         * ```ts
         * const username = 'github-username';
         * await page.waitForFunction(
         *   async username => {
         *     const githubResponse = await fetch(
         *       `https://api.github.com/users/${username}`,
         *     );
         *     const githubUser = await githubResponse.json();
         *     // show the avatar
         *     const img = document.createElement('img');
         *     img.src = githubUser.avatar_url;
         *     // wait 3 seconds
         *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
         *     img.remove();
         *   },
         *   {},
         *   username,
         * );
         * ```
         *
         * @param pageFunction - Function to be evaluated in browser context until it returns a
         * truthy value.
         * @param options - Options for configuring waiting behavior.
         */
        waitForFunction(pageFunction, options, ...args) {
          return this.mainFrame().waitForFunction(pageFunction, options, ...args);
        }
        /** @internal */
        [(_screenshot_decorators = [guarded(function() {
          return this.browser();
        })], disposeSymbol)]() {
          return void this.close().catch(debugError);
        }
        /** @internal */
        [asyncDisposeSymbol]() {
          return this.close();
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/WaitTask.js
var WaitTask, TaskManager;
var init_WaitTask = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/WaitTask.js"() {
    init_Deferred();
    init_ErrorLike();
    init_Function();
    init_Errors();
    init_LazyArg();
    WaitTask = class {
      #world;
      #polling;
      #root;
      #fn;
      #args;
      #timeout;
      #timeoutError;
      #result = Deferred.create();
      #poller;
      #signal;
      #reruns = [];
      constructor(world, options, fn, ...args) {
        this.#world = world;
        this.#polling = options.polling;
        this.#root = options.root;
        this.#signal = options.signal;
        this.#signal?.addEventListener("abort", this.#onAbortSignal, {
          once: true
        });
        switch (typeof fn) {
          case "string":
            this.#fn = `() => {return (${fn});}`;
            break;
          default:
            this.#fn = stringifyFunction(fn);
            break;
        }
        this.#args = args;
        this.#world.taskManager.add(this);
        if (options.timeout) {
          this.#timeoutError = new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`);
          this.#timeout = setTimeout(() => {
            void this.terminate(this.#timeoutError);
          }, options.timeout);
        }
        void this.rerun();
      }
      get result() {
        return this.#result.valueOrThrow();
      }
      async rerun() {
        for (const prev of this.#reruns) {
          prev.abort();
        }
        this.#reruns.length = 0;
        const controller = new AbortController();
        this.#reruns.push(controller);
        try {
          switch (this.#polling) {
            case "raf":
              this.#poller = await this.#world.evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn, ...args) => {
                const fun = createFunction2(fn);
                return new RAFPoller(() => {
                  return fun(...args);
                });
              }, LazyArg.create((context2) => {
                return context2.puppeteerUtil;
              }), this.#fn, ...this.#args);
              break;
            case "mutation":
              this.#poller = await this.#world.evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root, fn, ...args) => {
                const fun = createFunction2(fn);
                return new MutationPoller(() => {
                  return fun(...args);
                }, root || document);
              }, LazyArg.create((context2) => {
                return context2.puppeteerUtil;
              }), this.#root, this.#fn, ...this.#args);
              break;
            default:
              this.#poller = await this.#world.evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms, fn, ...args) => {
                const fun = createFunction2(fn);
                return new IntervalPoller(() => {
                  return fun(...args);
                }, ms);
              }, LazyArg.create((context2) => {
                return context2.puppeteerUtil;
              }), this.#polling, this.#fn, ...this.#args);
              break;
          }
          await this.#poller.evaluate((poller) => {
            void poller.start();
          });
          const result = await this.#poller.evaluateHandle((poller) => {
            return poller.result();
          });
          this.#result.resolve(result);
          await this.terminate();
        } catch (error) {
          if (controller.signal.aborted) {
            return;
          }
          const badError = this.getBadError(error);
          if (badError) {
            await this.terminate(badError);
          }
        }
      }
      async terminate(error) {
        this.#world.taskManager.delete(this);
        this.#signal?.removeEventListener("abort", this.#onAbortSignal);
        clearTimeout(this.#timeout);
        if (error && !this.#result.finished()) {
          this.#result.reject(error);
        }
        if (this.#poller) {
          try {
            await this.#poller.evaluate(async (poller) => {
              await poller.stop();
            });
            if (this.#poller) {
              await this.#poller.dispose();
              this.#poller = void 0;
            }
          } catch {
          }
        }
      }
      /**
       * Not all errors lead to termination. They usually imply we need to rerun the task.
       */
      getBadError(error) {
        if (isErrorLike(error)) {
          if (error.message.includes("Execution context is not available in detached frame")) {
            return new Error("Waiting failed: Frame detached");
          }
          if (error.message.includes("Execution context was destroyed")) {
            return;
          }
          if (error.message.includes("Cannot find context with specified id")) {
            return;
          }
          if (error.message.includes("DiscardedBrowsingContextError")) {
            return;
          }
          return error;
        }
        return new Error("WaitTask failed with an error", {
          cause: error
        });
      }
      #onAbortSignal = () => {
        void this.terminate(this.#signal?.reason);
      };
    };
    TaskManager = class {
      #tasks = /* @__PURE__ */ new Set();
      add(task) {
        this.#tasks.add(task);
      }
      delete(task) {
        this.#tasks.delete(task);
      }
      terminateAll(error) {
        for (const task of this.#tasks) {
          void task.terminate(error);
        }
        this.#tasks.clear();
      }
      async rerunAll() {
        await Promise.all([...this.#tasks].map((task) => {
          return task.rerun();
        }));
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js
var Realm;
var init_Realm = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js"() {
    init_WaitTask();
    init_disposable();
    Realm = class {
      timeoutSettings;
      taskManager = new TaskManager();
      constructor(timeoutSettings) {
        this.timeoutSettings = timeoutSettings;
      }
      async waitForFunction(pageFunction, options = {}, ...args) {
        const { polling = "raf", timeout: timeout2 = this.timeoutSettings.timeout(), root, signal } = options;
        if (typeof polling === "number" && polling < 0) {
          throw new Error("Cannot poll with non-positive interval");
        }
        const waitTask = new WaitTask(this, {
          polling,
          root,
          timeout: timeout2,
          signal
        }, pageFunction, ...args);
        return await waitTask.result;
      }
      get disposed() {
        return this.#disposed;
      }
      #disposed = false;
      /** @internal */
      dispose() {
        this.#disposed = true;
        this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
      }
      /** @internal */
      [disposeSymbol]() {
        this.dispose();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js
var TargetType, Target;
var init_Target = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js"() {
    (function(TargetType2) {
      TargetType2["PAGE"] = "page";
      TargetType2["BACKGROUND_PAGE"] = "background_page";
      TargetType2["SERVICE_WORKER"] = "service_worker";
      TargetType2["SHARED_WORKER"] = "shared_worker";
      TargetType2["BROWSER"] = "browser";
      TargetType2["WEBVIEW"] = "webview";
      TargetType2["OTHER"] = "other";
      TargetType2["TAB"] = "tab";
    })(TargetType || (TargetType = {}));
    Target = class {
      /**
       * @internal
       */
      constructor() {
      }
      /**
       * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
       */
      async worker() {
        return null;
      }
      /**
       * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
       * returns `null`.
       */
      async page() {
        return null;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/WebWorker.js
var WebWorker;
var init_WebWorker = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/api/WebWorker.js"() {
    init_Errors();
    init_EventEmitter();
    init_TimeoutSettings();
    init_util();
    WebWorker = class extends EventEmitter {
      /**
       * @internal
       */
      timeoutSettings = new TimeoutSettings();
      #url;
      /**
       * @internal
       */
      constructor(url) {
        super();
        this.#url = url;
      }
      /**
       * The URL of this web worker.
       */
      url() {
        return this.#url;
      }
      /**
       * Evaluates a given function in the {@link WebWorker | worker}.
       *
       * @remarks If the given function returns a promise,
       * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
       *
       * As a rule of thumb, if the return value of the given function is more
       * complicated than a JSON object (e.g. most classes), then
       * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
       * value (or `{}`). This is because we are not returning the actual return
       * value, but a deserialized version as a result of transferring the return
       * value through a protocol to Puppeteer.
       *
       * In general, you should use
       * {@link WebWorker.evaluateHandle | evaluateHandle} if
       * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
       * properly or you need a mutable {@link JSHandle | handle} to the return
       * object.
       *
       * @param func - Function to be evaluated.
       * @param args - Arguments to pass into `func`.
       * @returns The result of `func`.
       */
      async evaluate(func, ...args) {
        func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
        return await this.mainRealm().evaluate(func, ...args);
      }
      /**
       * Evaluates a given function in the {@link WebWorker | worker}.
       *
       * @remarks If the given function returns a promise,
       * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
       *
       * In general, you should use
       * {@link WebWorker.evaluateHandle | evaluateHandle} if
       * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
       * properly or you need a mutable {@link JSHandle | handle} to the return
       * object.
       *
       * @param func - Function to be evaluated.
       * @param args - Arguments to pass into `func`.
       * @returns A {@link JSHandle | handle} to the return value of `func`.
       */
      async evaluateHandle(func, ...args) {
        func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
        return await this.mainRealm().evaluateHandle(func, ...args);
      }
      async close() {
        throw new UnsupportedOperation("WebWorker.close() is not supported");
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js
var __addDisposableResource9, __disposeResources9, Accessibility, AXNode;
var init_Accessibility = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js"() {
    __addDisposableResource9 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources9 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    Accessibility = class {
      #realm;
      #frameId;
      /**
       * @internal
       */
      constructor(realm, frameId = "") {
        this.#realm = realm;
        this.#frameId = frameId;
      }
      /**
       * Captures the current state of the accessibility tree.
       * The returned object represents the root accessible node of the page.
       *
       * @remarks
       *
       * **NOTE** The Chrome accessibility tree contains nodes that go unused on
       * most platforms and by most screen readers. Puppeteer will discard them as
       * well for an easier to process tree, unless `interestingOnly` is set to
       * `false`.
       *
       * @example
       * An example of dumping the entire accessibility tree:
       *
       * ```ts
       * const snapshot = await page.accessibility.snapshot();
       * console.log(snapshot);
       * ```
       *
       * @example
       * An example of logging the focused node's name:
       *
       * ```ts
       * const snapshot = await page.accessibility.snapshot();
       * const node = findFocusedNode(snapshot);
       * console.log(node && node.name);
       *
       * function findFocusedNode(node) {
       *   if (node.focused) return node;
       *   for (const child of node.children || []) {
       *     const foundNode = findFocusedNode(child);
       *     return foundNode;
       *   }
       *   return null;
       * }
       * ```
       *
       * @returns An AXNode object representing the snapshot.
       */
      async snapshot(options = {}) {
        const { interestingOnly = true, root = null, includeIframes = false } = options;
        const { nodes } = await this.#realm.environment.client.send("Accessibility.getFullAXTree", {
          frameId: this.#frameId
        });
        let backendNodeId;
        if (root) {
          const { node } = await this.#realm.environment.client.send("DOM.describeNode", {
            objectId: root.id
          });
          backendNodeId = node.backendNodeId;
        }
        const defaultRoot = AXNode.createTree(this.#realm, nodes);
        const populateIframes = async (root2) => {
          if (root2.payload.role?.value === "Iframe") {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
              if (!root2.payload.backendDOMNodeId) {
                return;
              }
              const handle = __addDisposableResource9(env_1, await this.#realm.adoptBackendNode(root2.payload.backendDOMNodeId), false);
              if (!handle || !("contentFrame" in handle)) {
                return;
              }
              const frame = await handle.contentFrame();
              if (!frame) {
                return;
              }
              const iframeSnapshot = await frame.accessibility.snapshot(options);
              root2.iframeSnapshot = iframeSnapshot ?? void 0;
            } catch (e_1) {
              env_1.error = e_1;
              env_1.hasError = true;
            } finally {
              __disposeResources9(env_1);
            }
          }
          for (const child of root2.children) {
            await populateIframes(child);
          }
        };
        let needle = defaultRoot;
        if (!defaultRoot) {
          return null;
        }
        if (includeIframes) {
          await populateIframes(defaultRoot);
        }
        if (backendNodeId) {
          needle = defaultRoot.find((node) => {
            return node.payload.backendDOMNodeId === backendNodeId;
          });
        }
        if (!needle) {
          return null;
        }
        if (!interestingOnly) {
          return this.serializeTree(needle)[0] ?? null;
        }
        const interestingNodes = /* @__PURE__ */ new Set();
        this.collectInterestingNodes(interestingNodes, defaultRoot, false);
        if (!interestingNodes.has(needle)) {
          return null;
        }
        return this.serializeTree(needle, interestingNodes)[0] ?? null;
      }
      serializeTree(node, interestingNodes) {
        const children = [];
        for (const child of node.children) {
          children.push(...this.serializeTree(child, interestingNodes));
        }
        if (interestingNodes && !interestingNodes.has(node)) {
          return children;
        }
        const serializedNode = node.serialize();
        if (children.length) {
          serializedNode.children = children;
        }
        if (node.iframeSnapshot) {
          if (!serializedNode.children) {
            serializedNode.children = [];
          }
          serializedNode.children.push(node.iframeSnapshot);
        }
        return [serializedNode];
      }
      collectInterestingNodes(collection, node, insideControl) {
        if (node.isInteresting(insideControl) || node.iframeSnapshot) {
          collection.add(node);
        }
        if (node.isLeafNode()) {
          return;
        }
        insideControl = insideControl || node.isControl();
        for (const child of node.children) {
          this.collectInterestingNodes(collection, child, insideControl);
        }
      }
    };
    AXNode = class {
      payload;
      children = [];
      iframeSnapshot;
      #richlyEditable = false;
      #editable = false;
      #focusable = false;
      #hidden = false;
      #name;
      #role;
      #ignored;
      #cachedHasFocusableChild;
      #realm;
      constructor(realm, payload) {
        this.payload = payload;
        this.#name = this.payload.name ? this.payload.name.value : "";
        this.#role = this.payload.role ? this.payload.role.value : "Unknown";
        this.#ignored = this.payload.ignored;
        this.#realm = realm;
        for (const property of this.payload.properties || []) {
          if (property.name === "editable") {
            this.#richlyEditable = property.value.value === "richtext";
            this.#editable = true;
          }
          if (property.name === "focusable") {
            this.#focusable = property.value.value;
          }
          if (property.name === "hidden") {
            this.#hidden = property.value.value;
          }
        }
      }
      #isPlainTextField() {
        if (this.#richlyEditable) {
          return false;
        }
        if (this.#editable) {
          return true;
        }
        return this.#role === "textbox" || this.#role === "searchbox";
      }
      #isTextOnlyObject() {
        const role = this.#role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
      }
      #hasFocusableChild() {
        if (this.#cachedHasFocusableChild === void 0) {
          this.#cachedHasFocusableChild = false;
          for (const child of this.children) {
            if (child.#focusable || child.#hasFocusableChild()) {
              this.#cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this.#cachedHasFocusableChild;
      }
      find(predicate) {
        if (predicate(this)) {
          return this;
        }
        for (const child of this.children) {
          const result = child.find(predicate);
          if (result) {
            return result;
          }
        }
        return null;
      }
      isLeafNode() {
        if (!this.children.length) {
          return true;
        }
        if (this.#isPlainTextField() || this.#isTextOnlyObject()) {
          return true;
        }
        switch (this.#role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "image":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this.#hasFocusableChild()) {
          return false;
        }
        if (this.#focusable && this.#name) {
          return true;
        }
        if (this.#role === "heading" && this.#name) {
          return true;
        }
        return false;
      }
      isControl() {
        switch (this.#role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
          case "treeitem":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this.#role;
        if (role === "Ignored" || this.#hidden || this.#ignored) {
          return false;
        }
        if (this.#focusable || this.#richlyEditable) {
          return true;
        }
        if (this.isControl()) {
          return true;
        }
        if (insideControl) {
          return false;
        }
        return this.isLeafNode() && !!this.#name;
      }
      serialize() {
        const properties = /* @__PURE__ */ new Map();
        for (const property of this.payload.properties || []) {
          properties.set(property.name.toLowerCase(), property.value.value);
        }
        if (this.payload.name) {
          properties.set("name", this.payload.name.value);
        }
        if (this.payload.value) {
          properties.set("value", this.payload.value.value);
        }
        if (this.payload.description) {
          properties.set("description", this.payload.description.value);
        }
        const node = {
          role: this.#role,
          elementHandle: async () => {
            if (!this.payload.backendDOMNodeId) {
              return null;
            }
            return await this.#realm.adoptBackendNode(this.payload.backendDOMNodeId);
          }
        };
        const userStringProperties = [
          "name",
          "value",
          "description",
          "keyshortcuts",
          "roledescription",
          "valuetext"
        ];
        const getUserStringPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty)) {
            continue;
          }
          node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
        }
        const booleanProperties = [
          "disabled",
          "expanded",
          "focused",
          "modal",
          "multiline",
          "multiselectable",
          "readonly",
          "required",
          "selected"
        ];
        const getBooleanPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && this.#role === "RootWebArea") {
            continue;
          }
          const value = getBooleanPropertyValue(booleanProperty);
          if (!value) {
            continue;
          }
          node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
        }
        const tristateProperties = ["checked", "pressed"];
        for (const tristateProperty of tristateProperties) {
          if (!properties.has(tristateProperty)) {
            continue;
          }
          const value = properties.get(tristateProperty);
          node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
        }
        const numericalProperties = [
          "level",
          "valuemax",
          "valuemin"
        ];
        const getNumericalPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty)) {
            continue;
          }
          node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
        }
        const tokenProperties = [
          "autocomplete",
          "haspopup",
          "invalid",
          "orientation"
        ];
        const getTokenPropertyValue = (key) => {
          return properties.get(key);
        };
        for (const tokenProperty of tokenProperties) {
          const value = getTokenPropertyValue(tokenProperty);
          if (!value || value === "false") {
            continue;
          }
          node[tokenProperty] = getTokenPropertyValue(tokenProperty);
        }
        return node;
      }
      static createTree(realm, payloads) {
        const nodeById = /* @__PURE__ */ new Map();
        for (const payload of payloads) {
          nodeById.set(payload.nodeId, new AXNode(realm, payload));
        }
        for (const node of nodeById.values()) {
          for (const childId of node.payload.childIds || []) {
            const child = nodeById.get(childId);
            if (child) {
              node.children.push(child);
            }
          }
        }
        return nodeById.values().next().value ?? null;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js
var ConsoleMessage;
var init_ConsoleMessage = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js"() {
    ConsoleMessage = class {
      #type;
      #text;
      #args;
      #stackTraceLocations;
      #frame;
      /**
       * @internal
       */
      constructor(type, text, args, stackTraceLocations, frame) {
        this.#type = type;
        this.#text = text;
        this.#args = args;
        this.#stackTraceLocations = stackTraceLocations;
        this.#frame = frame;
      }
      /**
       * The type of the console message.
       */
      type() {
        return this.#type;
      }
      /**
       * The text of the console message.
       */
      text() {
        return this.#text;
      }
      /**
       * An array of arguments passed to the console.
       */
      args() {
        return this.#args;
      }
      /**
       * The location of the console message.
       */
      location() {
        return this.#stackTraceLocations[0] ?? (this.#frame ? { url: this.#frame.url() } : {});
      }
      /**
       * The array of locations on the stack of the console message.
       */
      stackTrace() {
        return this.#stackTraceLocations;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js
var CallbackRegistry, Callback;
var init_CallbackRegistry = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js"() {
    init_Deferred();
    init_ErrorLike();
    init_incremental_id_generator();
    init_Errors();
    init_util();
    CallbackRegistry = class {
      #callbacks = /* @__PURE__ */ new Map();
      #idGenerator = createIncrementalIdGenerator();
      create(label, timeout2, request) {
        const callback = new Callback(this.#idGenerator(), label, timeout2);
        this.#callbacks.set(callback.id, callback);
        try {
          request(callback.id);
        } catch (error) {
          callback.promise.catch(debugError).finally(() => {
            this.#callbacks.delete(callback.id);
          });
          callback.reject(error);
          throw error;
        }
        return callback.promise.finally(() => {
          this.#callbacks.delete(callback.id);
        });
      }
      reject(id, message, originalMessage) {
        const callback = this.#callbacks.get(id);
        if (!callback) {
          return;
        }
        this._reject(callback, message, originalMessage);
      }
      rejectRaw(id, error) {
        const callback = this.#callbacks.get(id);
        if (!callback) {
          return;
        }
        callback.reject(error);
      }
      _reject(callback, errorMessage, originalMessage) {
        let error;
        let message;
        if (errorMessage instanceof ProtocolError) {
          error = errorMessage;
          error.cause = callback.error;
          message = errorMessage.message;
        } else {
          error = callback.error;
          message = errorMessage;
        }
        callback.reject(rewriteError(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
      }
      resolve(id, value) {
        const callback = this.#callbacks.get(id);
        if (!callback) {
          return;
        }
        callback.resolve(value);
      }
      clear() {
        for (const callback of this.#callbacks.values()) {
          this._reject(callback, new TargetCloseError("Target closed"));
        }
        this.#callbacks.clear();
      }
      /**
       * @internal
       */
      getPendingProtocolErrors() {
        const result = [];
        for (const callback of this.#callbacks.values()) {
          result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
        }
        return result;
      }
    };
    Callback = class {
      #id;
      #error = new ProtocolError();
      #deferred = Deferred.create();
      #timer;
      #label;
      constructor(id, label, timeout2) {
        this.#id = id;
        this.#label = label;
        if (timeout2) {
          this.#timer = setTimeout(() => {
            this.#deferred.reject(rewriteError(this.#error, `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
          }, timeout2);
        }
      }
      resolve(value) {
        clearTimeout(this.#timer);
        this.#deferred.resolve(value);
      }
      reject(error) {
        clearTimeout(this.#timer);
        this.#deferred.reject(error);
      }
      get id() {
        return this.#id;
      }
      get promise() {
        return this.#deferred.valueOrThrow();
      }
      get error() {
        return this.#error;
      }
      get label() {
        return this.#label;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js
function convertToDisjointRanges(nestedRanges) {
  const points = [];
  for (const range of nestedRanges) {
    points.push({ offset: range.startOffset, type: 0, range });
    points.push({ offset: range.endOffset, type: 1, range });
  }
  points.sort((a, b) => {
    if (a.offset !== b.offset) {
      return a.offset - b.offset;
    }
    if (a.type !== b.type) {
      return b.type - a.type;
    }
    const aLength = a.range.endOffset - a.range.startOffset;
    const bLength = b.range.endOffset - b.range.startOffset;
    if (a.type === 0) {
      return bLength - aLength;
    }
    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0;
  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results[results.length - 1];
      if (lastResult && lastResult.end === lastOffset) {
        lastResult.end = point.offset;
      } else {
        results.push({ start: lastOffset, end: point.offset });
      }
    }
    lastOffset = point.offset;
    if (point.type === 0) {
      hitCountStack.push(point.range.count);
    } else {
      hitCountStack.pop();
    }
  }
  return results.filter((range) => {
    return range.end - range.start > 0;
  });
}
var Coverage, JSCoverage, CSSCoverage;
var init_Coverage = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js"() {
    init_EventEmitter();
    init_util();
    init_assert();
    init_disposable();
    Coverage = class {
      #jsCoverage;
      #cssCoverage;
      /**
       * @internal
       */
      constructor(client) {
        this.#jsCoverage = new JSCoverage(client);
        this.#cssCoverage = new CSSCoverage(client);
      }
      /**
       * @internal
       */
      updateClient(client) {
        this.#jsCoverage.updateClient(client);
        this.#cssCoverage.updateClient(client);
      }
      /**
       * @param options - Set of configurable options for coverage defaults to
       * `resetOnNavigation : true, reportAnonymousScripts : false,`
       * `includeRawScriptCoverage : false, useBlockCoverage : true`
       * @returns Promise that resolves when coverage is started.
       *
       * @remarks
       * Anonymous scripts are ones that don't have an associated url. These are
       * scripts that are dynamically created on the page using `eval` or
       * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
       * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
       * comment is present, in which case that will the be URL).
       */
      async startJSCoverage(options = {}) {
        return await this.#jsCoverage.start(options);
      }
      /**
       * Promise that resolves to the array of coverage reports for
       * all scripts.
       *
       * @remarks
       * JavaScript Coverage doesn't include anonymous scripts by default.
       * However, scripts with sourceURLs are reported.
       */
      async stopJSCoverage() {
        return await this.#jsCoverage.stop();
      }
      /**
       * @param options - Set of configurable options for coverage, defaults to
       * `resetOnNavigation : true`
       * @returns Promise that resolves when coverage is started.
       */
      async startCSSCoverage(options = {}) {
        return await this.#cssCoverage.start(options);
      }
      /**
       * Promise that resolves to the array of coverage reports
       * for all stylesheets.
       *
       * @remarks
       * CSS Coverage doesn't include dynamically injected style tags
       * without sourceURLs.
       */
      async stopCSSCoverage() {
        return await this.#cssCoverage.stop();
      }
    };
    JSCoverage = class {
      #client;
      #enabled = false;
      #scriptURLs = /* @__PURE__ */ new Map();
      #scriptSources = /* @__PURE__ */ new Map();
      #subscriptions;
      #resetOnNavigation = false;
      #reportAnonymousScripts = false;
      #includeRawScriptCoverage = false;
      /**
       * @internal
       */
      constructor(client) {
        this.#client = client;
      }
      /**
       * @internal
       */
      updateClient(client) {
        this.#client = client;
      }
      async start(options = {}) {
        assert(!this.#enabled, "JSCoverage is already enabled");
        const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
        this.#resetOnNavigation = resetOnNavigation;
        this.#reportAnonymousScripts = reportAnonymousScripts;
        this.#includeRawScriptCoverage = includeRawScriptCoverage;
        this.#enabled = true;
        this.#scriptURLs.clear();
        this.#scriptSources.clear();
        this.#subscriptions = new DisposableStack();
        const clientEmitter = this.#subscriptions.use(new EventEmitter(this.#client));
        clientEmitter.on("Debugger.scriptParsed", this.#onScriptParsed.bind(this));
        clientEmitter.on("Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this));
        await Promise.all([
          this.#client.send("Profiler.enable"),
          this.#client.send("Profiler.startPreciseCoverage", {
            callCount: this.#includeRawScriptCoverage,
            detailed: useBlockCoverage
          }),
          this.#client.send("Debugger.enable"),
          this.#client.send("Debugger.setSkipAllPauses", { skip: true })
        ]);
      }
      #onExecutionContextsCleared() {
        if (!this.#resetOnNavigation) {
          return;
        }
        this.#scriptURLs.clear();
        this.#scriptSources.clear();
      }
      async #onScriptParsed(event) {
        if (PuppeteerURL.isPuppeteerURL(event.url)) {
          return;
        }
        if (!event.url && !this.#reportAnonymousScripts) {
          return;
        }
        try {
          const response = await this.#client.send("Debugger.getScriptSource", {
            scriptId: event.scriptId
          });
          this.#scriptURLs.set(event.scriptId, event.url);
          this.#scriptSources.set(event.scriptId, response.scriptSource);
        } catch (error) {
          debugError(error);
        }
      }
      async stop() {
        assert(this.#enabled, "JSCoverage is not enabled");
        this.#enabled = false;
        const result = await Promise.all([
          this.#client.send("Profiler.takePreciseCoverage"),
          this.#client.send("Profiler.stopPreciseCoverage"),
          this.#client.send("Profiler.disable"),
          this.#client.send("Debugger.disable")
        ]);
        this.#subscriptions?.dispose();
        const coverage = [];
        const profileResponse = result[0];
        for (const entry of profileResponse.result) {
          let url = this.#scriptURLs.get(entry.scriptId);
          if (!url && this.#reportAnonymousScripts) {
            url = "debugger://VM" + entry.scriptId;
          }
          const text = this.#scriptSources.get(entry.scriptId);
          if (text === void 0 || url === void 0) {
            continue;
          }
          const flattenRanges = [];
          for (const func of entry.functions) {
            flattenRanges.push(...func.ranges);
          }
          const ranges = convertToDisjointRanges(flattenRanges);
          if (!this.#includeRawScriptCoverage) {
            coverage.push({ url, ranges, text });
          } else {
            coverage.push({ url, ranges, text, rawScriptCoverage: entry });
          }
        }
        return coverage;
      }
    };
    CSSCoverage = class {
      #client;
      #enabled = false;
      #stylesheetURLs = /* @__PURE__ */ new Map();
      #stylesheetSources = /* @__PURE__ */ new Map();
      #eventListeners;
      #resetOnNavigation = false;
      constructor(client) {
        this.#client = client;
      }
      /**
       * @internal
       */
      updateClient(client) {
        this.#client = client;
      }
      async start(options = {}) {
        assert(!this.#enabled, "CSSCoverage is already enabled");
        const { resetOnNavigation = true } = options;
        this.#resetOnNavigation = resetOnNavigation;
        this.#enabled = true;
        this.#stylesheetURLs.clear();
        this.#stylesheetSources.clear();
        this.#eventListeners = new DisposableStack();
        const clientEmitter = this.#eventListeners.use(new EventEmitter(this.#client));
        clientEmitter.on("CSS.styleSheetAdded", this.#onStyleSheet.bind(this));
        clientEmitter.on("Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this));
        await Promise.all([
          this.#client.send("DOM.enable"),
          this.#client.send("CSS.enable"),
          this.#client.send("CSS.startRuleUsageTracking")
        ]);
      }
      #onExecutionContextsCleared() {
        if (!this.#resetOnNavigation) {
          return;
        }
        this.#stylesheetURLs.clear();
        this.#stylesheetSources.clear();
      }
      async #onStyleSheet(event) {
        const header = event.header;
        if (!header.sourceURL) {
          return;
        }
        try {
          const response = await this.#client.send("CSS.getStyleSheetText", {
            styleSheetId: header.styleSheetId
          });
          this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);
          this.#stylesheetSources.set(header.styleSheetId, response.text);
        } catch (error) {
          debugError(error);
        }
      }
      async stop() {
        assert(this.#enabled, "CSSCoverage is not enabled");
        this.#enabled = false;
        const ruleTrackingResponse = await this.#client.send("CSS.stopRuleUsageTracking");
        await Promise.all([
          this.#client.send("CSS.disable"),
          this.#client.send("DOM.disable")
        ]);
        this.#eventListeners?.dispose();
        const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
          let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
          if (!ranges) {
            ranges = [];
            styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
          }
          ranges.push({
            startOffset: entry.startOffset,
            endOffset: entry.endOffset,
            count: entry.used ? 1 : 0
          });
        }
        const coverage = [];
        for (const styleSheetId of this.#stylesheetURLs.keys()) {
          const url = this.#stylesheetURLs.get(styleSheetId);
          assert(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
          const text = this.#stylesheetSources.get(styleSheetId);
          assert(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
          const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
          coverage.push({ url, ranges, text });
        }
        return coverage;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js
var __runInitializers5, __esDecorate5, __setFunctionName2, EmulatedState, EmulationManager;
var init_EmulationManager = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js"() {
    init_CDPSession();
    init_util();
    init_assert();
    init_decorators();
    init_ErrorLike();
    __runInitializers5 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __setFunctionName2 = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    EmulatedState = class {
      #state;
      #clientProvider;
      #updater;
      constructor(initialState, clientProvider, updater) {
        this.#state = initialState;
        this.#clientProvider = clientProvider;
        this.#updater = updater;
        this.#clientProvider.registerState(this);
      }
      async setState(state) {
        this.#state = state;
        await this.sync();
      }
      get state() {
        return this.#state;
      }
      async sync() {
        await Promise.all(this.#clientProvider.clients().map((client) => {
          return this.#updater(client, this.#state);
        }));
      }
    };
    EmulationManager = (() => {
      let _instanceExtraInitializers = [];
      let _private_applyViewport_decorators;
      let _private_applyViewport_descriptor;
      let _private_emulateIdleState_decorators;
      let _private_emulateIdleState_descriptor;
      let _private_emulateTimezone_decorators;
      let _private_emulateTimezone_descriptor;
      let _private_emulateVisionDeficiency_decorators;
      let _private_emulateVisionDeficiency_descriptor;
      let _private_emulateCpuThrottling_decorators;
      let _private_emulateCpuThrottling_descriptor;
      let _private_emulateMediaFeatures_decorators;
      let _private_emulateMediaFeatures_descriptor;
      let _private_emulateMediaType_decorators;
      let _private_emulateMediaType_descriptor;
      let _private_setGeolocation_decorators;
      let _private_setGeolocation_descriptor;
      let _private_setDefaultBackgroundColor_decorators;
      let _private_setDefaultBackgroundColor_descriptor;
      let _private_setJavaScriptEnabled_decorators;
      let _private_setJavaScriptEnabled_descriptor;
      return class EmulationManager {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
          _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
          _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
          _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
          _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
          _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
          _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
          _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
          _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
          _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
          _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
          __esDecorate5(this, _private_applyViewport_descriptor = { value: __setFunctionName2(async function(client, viewportState) {
            if (!viewportState.viewport) {
              await Promise.all([
                client.send("Emulation.clearDeviceMetricsOverride"),
                client.send("Emulation.setTouchEmulationEnabled", {
                  enabled: false
                })
              ]).catch(debugError);
              return;
            }
            const { viewport } = viewportState;
            const mobile = viewport.isMobile || false;
            const width = viewport.width;
            const height = viewport.height;
            const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
            const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
            const hasTouch = viewport.hasTouch || false;
            await Promise.all([
              client.send("Emulation.setDeviceMetricsOverride", {
                mobile,
                width,
                height,
                deviceScaleFactor,
                screenOrientation
              }).catch((err) => {
                if (err.message.includes("Target does not support metrics override")) {
                  debugError(err);
                  return;
                }
                throw err;
              }),
              client.send("Emulation.setTouchEmulationEnabled", {
                enabled: hasTouch
              })
            ]);
          }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: (obj) => #applyViewport in obj, get: (obj) => obj.#applyViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_emulateIdleState_descriptor = { value: __setFunctionName2(async function(client, idleStateState) {
            if (!idleStateState.active) {
              return;
            }
            if (idleStateState.overrides) {
              await client.send("Emulation.setIdleOverride", {
                isUserActive: idleStateState.overrides.isUserActive,
                isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
              });
            } else {
              await client.send("Emulation.clearIdleOverride");
            }
          }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: (obj) => #emulateIdleState in obj, get: (obj) => obj.#emulateIdleState }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_emulateTimezone_descriptor = { value: __setFunctionName2(async function(client, timezoneState) {
            if (!timezoneState.active) {
              return;
            }
            try {
              await client.send("Emulation.setTimezoneOverride", {
                timezoneId: timezoneState.timezoneId || ""
              });
            } catch (error) {
              if (isErrorLike(error) && error.message.includes("Invalid timezone")) {
                throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
              }
              throw error;
            }
          }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: (obj) => #emulateTimezone in obj, get: (obj) => obj.#emulateTimezone }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName2(async function(client, visionDeficiency) {
            if (!visionDeficiency.active) {
              return;
            }
            await client.send("Emulation.setEmulatedVisionDeficiency", {
              type: visionDeficiency.visionDeficiency || "none"
            });
          }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: (obj) => #emulateVisionDeficiency in obj, get: (obj) => obj.#emulateVisionDeficiency }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName2(async function(client, state) {
            if (!state.active) {
              return;
            }
            await client.send("Emulation.setCPUThrottlingRate", {
              rate: state.factor ?? 1
            });
          }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: (obj) => #emulateCpuThrottling in obj, get: (obj) => obj.#emulateCpuThrottling }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName2(async function(client, state) {
            if (!state.active) {
              return;
            }
            await client.send("Emulation.setEmulatedMedia", {
              features: state.mediaFeatures
            });
          }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: (obj) => #emulateMediaFeatures in obj, get: (obj) => obj.#emulateMediaFeatures }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_emulateMediaType_descriptor = { value: __setFunctionName2(async function(client, state) {
            if (!state.active) {
              return;
            }
            await client.send("Emulation.setEmulatedMedia", {
              media: state.type || ""
            });
          }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: (obj) => #emulateMediaType in obj, get: (obj) => obj.#emulateMediaType }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_setGeolocation_descriptor = { value: __setFunctionName2(async function(client, state) {
            if (!state.active) {
              return;
            }
            await client.send("Emulation.setGeolocationOverride", state.geoLocation ? {
              longitude: state.geoLocation.longitude,
              latitude: state.geoLocation.latitude,
              accuracy: state.geoLocation.accuracy
            } : void 0);
          }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: (obj) => #setGeolocation in obj, get: (obj) => obj.#setGeolocation }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName2(async function(client, state) {
            if (!state.active) {
              return;
            }
            await client.send("Emulation.setDefaultBackgroundColorOverride", {
              color: state.color
            });
          }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: (obj) => #setDefaultBackgroundColor in obj, get: (obj) => obj.#setDefaultBackgroundColor }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate5(this, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName2(async function(client, state) {
            if (!state.active) {
              return;
            }
            await client.send("Emulation.setScriptExecutionDisabled", {
              value: !state.javaScriptEnabled
            });
          }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: (obj) => #setJavaScriptEnabled in obj, get: (obj) => obj.#setJavaScriptEnabled }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #client = __runInitializers5(this, _instanceExtraInitializers);
        #emulatingMobile = false;
        #hasTouch = false;
        #states = [];
        #viewportState = new EmulatedState({
          active: false
        }, this, this.#applyViewport);
        #idleOverridesState = new EmulatedState({
          active: false
        }, this, this.#emulateIdleState);
        #timezoneState = new EmulatedState({
          active: false
        }, this, this.#emulateTimezone);
        #visionDeficiencyState = new EmulatedState({
          active: false
        }, this, this.#emulateVisionDeficiency);
        #cpuThrottlingState = new EmulatedState({
          active: false
        }, this, this.#emulateCpuThrottling);
        #mediaFeaturesState = new EmulatedState({
          active: false
        }, this, this.#emulateMediaFeatures);
        #mediaTypeState = new EmulatedState({
          active: false
        }, this, this.#emulateMediaType);
        #geoLocationState = new EmulatedState({
          active: false
        }, this, this.#setGeolocation);
        #defaultBackgroundColorState = new EmulatedState({
          active: false
        }, this, this.#setDefaultBackgroundColor);
        #javascriptEnabledState = new EmulatedState({
          javaScriptEnabled: true,
          active: false
        }, this, this.#setJavaScriptEnabled);
        #secondaryClients = /* @__PURE__ */ new Set();
        constructor(client) {
          this.#client = client;
        }
        updateClient(client) {
          this.#client = client;
          this.#secondaryClients.delete(client);
        }
        registerState(state) {
          this.#states.push(state);
        }
        clients() {
          return [this.#client, ...Array.from(this.#secondaryClients)];
        }
        async registerSpeculativeSession(client) {
          this.#secondaryClients.add(client);
          client.once(CDPSessionEvent.Disconnected, () => {
            this.#secondaryClients.delete(client);
          });
          void Promise.all(this.#states.map((s) => {
            return s.sync().catch(debugError);
          }));
        }
        get javascriptEnabled() {
          return this.#javascriptEnabledState.state.javaScriptEnabled;
        }
        async emulateViewport(viewport) {
          const currentState = this.#viewportState.state;
          if (!viewport && !currentState.active) {
            return false;
          }
          await this.#viewportState.setState(viewport ? {
            viewport,
            active: true
          } : {
            active: false
          });
          const mobile = viewport?.isMobile || false;
          const hasTouch = viewport?.hasTouch || false;
          const reloadNeeded = this.#emulatingMobile !== mobile || this.#hasTouch !== hasTouch;
          this.#emulatingMobile = mobile;
          this.#hasTouch = hasTouch;
          return reloadNeeded;
        }
        get #applyViewport() {
          return _private_applyViewport_descriptor.value;
        }
        async emulateIdleState(overrides) {
          await this.#idleOverridesState.setState({
            active: true,
            overrides
          });
        }
        get #emulateIdleState() {
          return _private_emulateIdleState_descriptor.value;
        }
        get #emulateTimezone() {
          return _private_emulateTimezone_descriptor.value;
        }
        async emulateTimezone(timezoneId) {
          await this.#timezoneState.setState({
            timezoneId,
            active: true
          });
        }
        get #emulateVisionDeficiency() {
          return _private_emulateVisionDeficiency_descriptor.value;
        }
        async emulateVisionDeficiency(type) {
          const visionDeficiencies = /* @__PURE__ */ new Set([
            "none",
            "achromatopsia",
            "blurredVision",
            "deuteranopia",
            "protanopia",
            "reducedContrast",
            "tritanopia"
          ]);
          assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
          await this.#visionDeficiencyState.setState({
            active: true,
            visionDeficiency: type
          });
        }
        get #emulateCpuThrottling() {
          return _private_emulateCpuThrottling_descriptor.value;
        }
        async emulateCPUThrottling(factor) {
          assert(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
          await this.#cpuThrottlingState.setState({
            active: true,
            factor: factor ?? void 0
          });
        }
        get #emulateMediaFeatures() {
          return _private_emulateMediaFeatures_descriptor.value;
        }
        async emulateMediaFeatures(features) {
          if (Array.isArray(features)) {
            for (const mediaFeature of features) {
              const name = mediaFeature.name;
              assert(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), "Unsupported media feature: " + name);
            }
          }
          await this.#mediaFeaturesState.setState({
            active: true,
            mediaFeatures: features
          });
        }
        get #emulateMediaType() {
          return _private_emulateMediaType_descriptor.value;
        }
        async emulateMediaType(type) {
          assert(type === "screen" || type === "print" || (type ?? void 0) === void 0, "Unsupported media type: " + type);
          await this.#mediaTypeState.setState({
            type,
            active: true
          });
        }
        get #setGeolocation() {
          return _private_setGeolocation_descriptor.value;
        }
        async setGeolocation(options) {
          const { longitude, latitude, accuracy = 0 } = options;
          if (longitude < -180 || longitude > 180) {
            throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
          }
          if (latitude < -90 || latitude > 90) {
            throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
          }
          if (accuracy < 0) {
            throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
          }
          await this.#geoLocationState.setState({
            active: true,
            geoLocation: {
              longitude,
              latitude,
              accuracy
            }
          });
        }
        get #setDefaultBackgroundColor() {
          return _private_setDefaultBackgroundColor_descriptor.value;
        }
        /**
         * Resets default white background
         */
        async resetDefaultBackgroundColor() {
          await this.#defaultBackgroundColorState.setState({
            active: true,
            color: void 0
          });
        }
        /**
         * Hides default white background
         */
        async setTransparentBackgroundColor() {
          await this.#defaultBackgroundColorState.setState({
            active: true,
            color: { r: 0, g: 0, b: 0, a: 0 }
          });
        }
        get #setJavaScriptEnabled() {
          return _private_setJavaScriptEnabled_descriptor.value;
        }
        async setJavaScriptEnabled(enabled) {
          await this.#javascriptEnabledState.setState({
            active: true,
            javaScriptEnabled: enabled
          });
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js
var SecurityDetails;
var init_SecurityDetails = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js"() {
    SecurityDetails = class {
      #subjectName;
      #issuer;
      #validFrom;
      #validTo;
      #protocol;
      #sanList;
      /**
       * @internal
       */
      constructor(securityPayload) {
        this.#subjectName = securityPayload.subjectName;
        this.#issuer = securityPayload.issuer;
        this.#validFrom = securityPayload.validFrom;
        this.#validTo = securityPayload.validTo;
        this.#protocol = securityPayload.protocol;
        this.#sanList = securityPayload.sanList;
      }
      /**
       * The name of the issuer of the certificate.
       */
      issuer() {
        return this.#issuer;
      }
      /**
       * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
       * marking the start of the certificate's validity.
       */
      validFrom() {
        return this.#validFrom;
      }
      /**
       * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
       * marking the end of the certificate's validity.
       */
      validTo() {
        return this.#validTo;
      }
      /**
       * The security protocol being used, e.g. "TLS 1.2".
       */
      protocol() {
        return this.#protocol;
      }
      /**
       * The name of the subject to which the certificate was issued.
       */
      subjectName() {
        return this.#subjectName;
      }
      /**
       * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
       */
      subjectAlternativeNames() {
        return this.#sanList;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js
var Tracing;
var init_Tracing = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js"() {
    init_util();
    init_assert();
    init_Deferred();
    init_ErrorLike();
    Tracing = class {
      #client;
      #recording = false;
      #path;
      /**
       * @internal
       */
      constructor(client) {
        this.#client = client;
      }
      /**
       * @internal
       */
      updateClient(client) {
        this.#client = client;
      }
      /**
       * Starts a trace for the current page.
       * @remarks
       * Only one trace can be active at a time per browser.
       *
       * @param options - Optional `TracingOptions`.
       */
      async start(options = {}) {
        assert(!this.#recording, "Cannot start recording trace while already recording trace.");
        const defaultCategories = [
          "-*",
          "devtools.timeline",
          "v8.execute",
          "disabled-by-default-devtools.timeline",
          "disabled-by-default-devtools.timeline.frame",
          "toplevel",
          "blink.console",
          "blink.user_timing",
          "latencyInfo",
          "disabled-by-default-devtools.timeline.stack",
          "disabled-by-default-v8.cpu_profiler"
        ];
        const { path, screenshots = false, categories = defaultCategories } = options;
        if (screenshots) {
          categories.push("disabled-by-default-devtools.screenshot");
        }
        const excludedCategories = categories.filter((cat) => {
          return cat.startsWith("-");
        }).map((cat) => {
          return cat.slice(1);
        });
        const includedCategories = categories.filter((cat) => {
          return !cat.startsWith("-");
        });
        this.#path = path;
        this.#recording = true;
        await this.#client.send("Tracing.start", {
          transferMode: "ReturnAsStream",
          traceConfig: {
            excludedCategories,
            includedCategories
          }
        });
      }
      /**
       * Stops a trace started with the `start` method.
       * @returns Promise which resolves to buffer with trace data.
       */
      async stop() {
        const contentDeferred = Deferred.create();
        this.#client.once("Tracing.tracingComplete", async (event) => {
          try {
            assert(event.stream, 'Missing "stream"');
            const readable = await getReadableFromProtocolStream(this.#client, event.stream);
            const typedArray = await getReadableAsTypedArray(readable, this.#path);
            contentDeferred.resolve(typedArray ?? void 0);
          } catch (error) {
            if (isErrorLike(error)) {
              contentDeferred.reject(error);
            } else {
              contentDeferred.reject(new Error(`Unknown error: ${error}`));
            }
          }
        });
        await this.#client.send("Tracing.end");
        this.#recording = false;
        return await contentDeferred.valueOrThrow();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js
var BrowserWebSocketTransport_exports = {};
__export(BrowserWebSocketTransport_exports, {
  BrowserWebSocketTransport: () => BrowserWebSocketTransport
});
var BrowserWebSocketTransport;
var init_BrowserWebSocketTransport = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js"() {
    BrowserWebSocketTransport = class {
      static create(url) {
        return new Promise((resolve, reject) => {
          const ws = new WebSocket(url);
          ws.addEventListener("open", () => {
            return resolve(new BrowserWebSocketTransport(ws));
          });
          ws.addEventListener("error", reject);
        });
      }
      #ws;
      onmessage;
      onclose;
      constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener("message", (event) => {
          if (this.onmessage) {
            this.onmessage.call(null, event.data);
          }
        });
        this.#ws.addEventListener("close", () => {
          if (this.onclose) {
            this.onclose.call(null);
          }
        });
        this.#ws.addEventListener("error", () => {
        });
      }
      send(message) {
        this.#ws.send(message);
      }
      close() {
        this.#ws.close();
      }
    };
  }
});

// node_modules/mitt/dist/mitt.mjs
var mitt_exports = {};
__export(mitt_exports, {
  default: () => mitt_default2
});
function mitt_default2(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
var init_mitt2 = __esm({
  "node_modules/mitt/dist/mitt.mjs"() {
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventEmitter = void 0;
    var mitt_1 = __importDefault((init_mitt2(), __toCommonJS(mitt_exports)));
    var EventEmitter3 = class {
      #emitter = (0, mitt_1.default)();
      on(type, handler) {
        this.#emitter.on(type, handler);
        return this;
      }
      /**
       * Like `on` but the listener will only be fired once and then it will be removed.
       * @param event The event you'd like to listen to
       * @param handler The handler function to run when the event occurs
       * @return `this` to enable chaining method calls.
       */
      once(event, handler) {
        const onceHandler = (eventData) => {
          handler(eventData);
          this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
      }
      off(type, handler) {
        this.#emitter.off(type, handler);
        return this;
      }
      /**
       * Emits an event and call any associated listeners.
       *
       * @param event The event to emit.
       * @param eventData Any data to emit with the event.
       * @return `true` if there are any listeners, `false` otherwise.
       */
      emit(event, eventData) {
        this.#emitter.emit(event, eventData);
      }
      /**
       * Removes all listeners. If given an event argument, it will remove only
       * listeners for that event.
       * @param event - the event to remove listeners for.
       * @returns `this` to enable you to chain method calls.
       */
      removeAllListeners(event) {
        if (event) {
          this.#emitter.all.delete(event);
        } else {
          this.#emitter.all.clear();
        }
        return this;
      }
    };
    exports.EventEmitter = EventEmitter3;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/log.js
var require_log = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogType = void 0;
    var LogType;
    (function(LogType2) {
      LogType2["bidi"] = "bidi";
      LogType2["cdp"] = "cdp";
      LogType2["debug"] = "debug";
      LogType2["debugError"] = "debug:error";
      LogType2["debugInfo"] = "debug:info";
      LogType2["debugWarn"] = "debug:warn";
    })(LogType || (exports.LogType = LogType = {}));
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js
var require_ProcessingQueue = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js"(exports) {
    "use strict";
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProcessingQueue = void 0;
    var log_js_1 = require_log();
    var _logger, _processor, _queue, _isProcessing, _processIfNeeded, processIfNeeded_fn;
    var ProcessingQueue = class {
      constructor(processor, logger) {
        __privateAdd(this, _processIfNeeded);
        __privateAdd(this, _logger, void 0);
        __privateAdd(this, _processor, void 0);
        __privateAdd(this, _queue, []);
        // Flag to keep only 1 active processor.
        __privateAdd(this, _isProcessing, false);
        __privateSet(this, _processor, processor);
        __privateSet(this, _logger, logger);
      }
      add(entry, name) {
        __privateGet(this, _queue).push([entry, name]);
        void __privateMethod(this, _processIfNeeded, processIfNeeded_fn).call(this);
      }
    };
    _logger = new WeakMap();
    _processor = new WeakMap();
    _queue = new WeakMap();
    _isProcessing = new WeakMap();
    _processIfNeeded = new WeakSet();
    processIfNeeded_fn = async function() {
      var _a4;
      if (__privateGet(this, _isProcessing)) {
        return;
      }
      __privateSet(this, _isProcessing, true);
      while (__privateGet(this, _queue).length > 0) {
        const arrayEntry = __privateGet(this, _queue).shift();
        if (!arrayEntry) {
          continue;
        }
        const [entryPromise, name] = arrayEntry;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, _a3.LOGGER_PREFIX, "Processing event:", name);
        await entryPromise.then((entry) => {
          var _a5;
          if (entry.kind === "error") {
            (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.debugError, "Event threw before sending:", entry.error.message, entry.error.stack);
            return;
          }
          return __privateGet(this, _processor).call(this, entry.value);
        }).catch((error) => {
          var _a5;
          (_a5 = __privateGet(this, _logger)) == null ? void 0 : _a5.call(this, log_js_1.LogType.debugError, "Event was not processed:", error?.message);
        });
      }
      __privateSet(this, _isProcessing, false);
    };
    __publicField(ProcessingQueue, "LOGGER_PREFIX", `${log_js_1.LogType.debug}:queue`);
    exports.ProcessingQueue = ProcessingQueue;
    _a3 = ProcessingQueue;
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/cdp.js
var require_cdp = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/cdp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js
var require_chromium_bidi = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EVENT_NAMES = exports.Bluetooth = exports.Network = exports.BrowsingContext = exports.Log = exports.Script = exports.BiDiModule = void 0;
    var BiDiModule;
    (function(BiDiModule2) {
      BiDiModule2["Bluetooth"] = "bluetooth";
      BiDiModule2["Browser"] = "browser";
      BiDiModule2["BrowsingContext"] = "browsingContext";
      BiDiModule2["Cdp"] = "goog:cdp";
      BiDiModule2["DeprecatedCdp"] = "cdp";
      BiDiModule2["Input"] = "input";
      BiDiModule2["Log"] = "log";
      BiDiModule2["Network"] = "network";
      BiDiModule2["Script"] = "script";
      BiDiModule2["Session"] = "session";
    })(BiDiModule || (exports.BiDiModule = BiDiModule = {}));
    var Script;
    (function(Script2) {
      let EventNames;
      (function(EventNames2) {
        EventNames2["Message"] = "script.message";
        EventNames2["RealmCreated"] = "script.realmCreated";
        EventNames2["RealmDestroyed"] = "script.realmDestroyed";
      })(EventNames = Script2.EventNames || (Script2.EventNames = {}));
    })(Script || (exports.Script = Script = {}));
    var Log;
    (function(Log2) {
      let EventNames;
      (function(EventNames2) {
        EventNames2["LogEntryAdded"] = "log.entryAdded";
      })(EventNames = Log2.EventNames || (Log2.EventNames = {}));
    })(Log || (exports.Log = Log = {}));
    var BrowsingContext2;
    (function(BrowsingContext3) {
      let EventNames;
      (function(EventNames2) {
        EventNames2["ContextCreated"] = "browsingContext.contextCreated";
        EventNames2["ContextDestroyed"] = "browsingContext.contextDestroyed";
        EventNames2["DomContentLoaded"] = "browsingContext.domContentLoaded";
        EventNames2["DownloadWillBegin"] = "browsingContext.downloadWillBegin";
        EventNames2["FragmentNavigated"] = "browsingContext.fragmentNavigated";
        EventNames2["HistoryUpdated"] = "browsingContext.historyUpdated";
        EventNames2["Load"] = "browsingContext.load";
        EventNames2["NavigationAborted"] = "browsingContext.navigationAborted";
        EventNames2["NavigationCommitted"] = "browsingContext.navigationCommitted";
        EventNames2["NavigationFailed"] = "browsingContext.navigationFailed";
        EventNames2["NavigationStarted"] = "browsingContext.navigationStarted";
        EventNames2["UserPromptClosed"] = "browsingContext.userPromptClosed";
        EventNames2["UserPromptOpened"] = "browsingContext.userPromptOpened";
      })(EventNames = BrowsingContext3.EventNames || (BrowsingContext3.EventNames = {}));
    })(BrowsingContext2 || (exports.BrowsingContext = BrowsingContext2 = {}));
    var Network;
    (function(Network2) {
      let EventNames;
      (function(EventNames2) {
        EventNames2["AuthRequired"] = "network.authRequired";
        EventNames2["BeforeRequestSent"] = "network.beforeRequestSent";
        EventNames2["FetchError"] = "network.fetchError";
        EventNames2["ResponseCompleted"] = "network.responseCompleted";
        EventNames2["ResponseStarted"] = "network.responseStarted";
      })(EventNames = Network2.EventNames || (Network2.EventNames = {}));
    })(Network || (exports.Network = Network = {}));
    var Bluetooth;
    (function(Bluetooth2) {
      let EventNames;
      (function(EventNames2) {
        EventNames2["RequestDevicePromptUpdated"] = "bluetooth.requestDevicePromptUpdated";
      })(EventNames = Bluetooth2.EventNames || (Bluetooth2.EventNames = {}));
    })(Bluetooth || (exports.Bluetooth = Bluetooth = {}));
    exports.EVENT_NAMES = /* @__PURE__ */ new Set([
      // keep-sorted start
      ...Object.values(BiDiModule),
      ...Object.values(Bluetooth.EventNames),
      ...Object.values(BrowsingContext2.EventNames),
      ...Object.values(Log.EventNames),
      ...Object.values(Network.EventNames),
      ...Object.values(Script.EventNames)
      // keep-sorted end
    ]);
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js
var require_webdriver_bidi = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js
var require_ErrorResponse = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoSuchWebExtensionException = exports.InvalidWebExtensionException = exports.UnderspecifiedStoragePartitionException = exports.UnableToSetFileInputException = exports.UnableToSetCookieException = exports.NoSuchStoragePartitionException = exports.UnsupportedOperationException = exports.UnableToCloseBrowserException = exports.UnableToCaptureScreenException = exports.UnknownErrorException = exports.UnknownCommandException = exports.SessionNotCreatedException = exports.NoSuchUserContextException = exports.NoSuchScriptException = exports.NoSuchRequestException = exports.NoSuchNodeException = exports.NoSuchInterceptException = exports.NoSuchHistoryEntryException = exports.NoSuchHandleException = exports.NoSuchFrameException = exports.NoSuchElementException = exports.NoSuchAlertException = exports.MoveTargetOutOfBoundsException = exports.InvalidSessionIdException = exports.InvalidSelectorException = exports.InvalidArgumentException = exports.Exception = void 0;
    var Exception = class extends Error {
      error;
      message;
      stacktrace;
      constructor(error, message, stacktrace) {
        super();
        this.error = error;
        this.message = message;
        this.stacktrace = stacktrace;
      }
      toErrorResponse(commandId) {
        return {
          type: "error",
          id: commandId,
          error: this.error,
          message: this.message,
          stacktrace: this.stacktrace
        };
      }
    };
    exports.Exception = Exception;
    var InvalidArgumentException = class extends Exception {
      constructor(message, stacktrace) {
        super("invalid argument", message, stacktrace);
      }
    };
    exports.InvalidArgumentException = InvalidArgumentException;
    var InvalidSelectorException = class extends Exception {
      constructor(message, stacktrace) {
        super("invalid selector", message, stacktrace);
      }
    };
    exports.InvalidSelectorException = InvalidSelectorException;
    var InvalidSessionIdException = class extends Exception {
      constructor(message, stacktrace) {
        super("invalid session id", message, stacktrace);
      }
    };
    exports.InvalidSessionIdException = InvalidSessionIdException;
    var MoveTargetOutOfBoundsException = class extends Exception {
      constructor(message, stacktrace) {
        super("move target out of bounds", message, stacktrace);
      }
    };
    exports.MoveTargetOutOfBoundsException = MoveTargetOutOfBoundsException;
    var NoSuchAlertException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such alert", message, stacktrace);
      }
    };
    exports.NoSuchAlertException = NoSuchAlertException;
    var NoSuchElementException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such element", message, stacktrace);
      }
    };
    exports.NoSuchElementException = NoSuchElementException;
    var NoSuchFrameException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such frame", message, stacktrace);
      }
    };
    exports.NoSuchFrameException = NoSuchFrameException;
    var NoSuchHandleException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such handle", message, stacktrace);
      }
    };
    exports.NoSuchHandleException = NoSuchHandleException;
    var NoSuchHistoryEntryException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such history entry", message, stacktrace);
      }
    };
    exports.NoSuchHistoryEntryException = NoSuchHistoryEntryException;
    var NoSuchInterceptException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such intercept", message, stacktrace);
      }
    };
    exports.NoSuchInterceptException = NoSuchInterceptException;
    var NoSuchNodeException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such node", message, stacktrace);
      }
    };
    exports.NoSuchNodeException = NoSuchNodeException;
    var NoSuchRequestException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such request", message, stacktrace);
      }
    };
    exports.NoSuchRequestException = NoSuchRequestException;
    var NoSuchScriptException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such script", message, stacktrace);
      }
    };
    exports.NoSuchScriptException = NoSuchScriptException;
    var NoSuchUserContextException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such user context", message, stacktrace);
      }
    };
    exports.NoSuchUserContextException = NoSuchUserContextException;
    var SessionNotCreatedException = class extends Exception {
      constructor(message, stacktrace) {
        super("session not created", message, stacktrace);
      }
    };
    exports.SessionNotCreatedException = SessionNotCreatedException;
    var UnknownCommandException = class extends Exception {
      constructor(message, stacktrace) {
        super("unknown command", message, stacktrace);
      }
    };
    exports.UnknownCommandException = UnknownCommandException;
    var UnknownErrorException = class extends Exception {
      constructor(message, stacktrace = new Error().stack) {
        super("unknown error", message, stacktrace);
      }
    };
    exports.UnknownErrorException = UnknownErrorException;
    var UnableToCaptureScreenException = class extends Exception {
      constructor(message, stacktrace) {
        super("unable to capture screen", message, stacktrace);
      }
    };
    exports.UnableToCaptureScreenException = UnableToCaptureScreenException;
    var UnableToCloseBrowserException = class extends Exception {
      constructor(message, stacktrace) {
        super("unable to close browser", message, stacktrace);
      }
    };
    exports.UnableToCloseBrowserException = UnableToCloseBrowserException;
    var UnsupportedOperationException = class extends Exception {
      constructor(message, stacktrace) {
        super("unsupported operation", message, stacktrace);
      }
    };
    exports.UnsupportedOperationException = UnsupportedOperationException;
    var NoSuchStoragePartitionException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such storage partition", message, stacktrace);
      }
    };
    exports.NoSuchStoragePartitionException = NoSuchStoragePartitionException;
    var UnableToSetCookieException = class extends Exception {
      constructor(message, stacktrace) {
        super("unable to set cookie", message, stacktrace);
      }
    };
    exports.UnableToSetCookieException = UnableToSetCookieException;
    var UnableToSetFileInputException = class extends Exception {
      constructor(message, stacktrace) {
        super("unable to set file input", message, stacktrace);
      }
    };
    exports.UnableToSetFileInputException = UnableToSetFileInputException;
    var UnderspecifiedStoragePartitionException = class extends Exception {
      constructor(message, stacktrace) {
        super("underspecified storage partition", message, stacktrace);
      }
    };
    exports.UnderspecifiedStoragePartitionException = UnderspecifiedStoragePartitionException;
    var InvalidWebExtensionException = class extends Exception {
      constructor(message, stacktrace) {
        super("invalid web extension", message, stacktrace);
      }
    };
    exports.InvalidWebExtensionException = InvalidWebExtensionException;
    var NoSuchWebExtensionException = class extends Exception {
      constructor(message, stacktrace) {
        super("no such web extension", message, stacktrace);
      }
    };
    exports.NoSuchWebExtensionException = NoSuchWebExtensionException;
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js
var require_webdriver_bidi_permissions = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-bluetooth.js
var require_webdriver_bidi_bluetooth = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-bluetooth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/chromium-bidi/lib/cjs/protocol/protocol.js
var require_protocol = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/protocol/protocol.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChromiumBidi = exports.Cdp = void 0;
    exports.Cdp = __importStar(require_cdp());
    exports.ChromiumBidi = __importStar(require_chromium_bidi());
    __exportStar(require_webdriver_bidi(), exports);
    __exportStar(require_ErrorResponse(), exports);
    __exportStar(require_webdriver_bidi_permissions(), exports);
    __exportStar(require_webdriver_bidi_bluetooth(), exports);
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js
var require_BidiNoOpParser = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BidiNoOpParser = void 0;
    var BidiNoOpParser = class {
      // Bluetooth module
      // keep-sorted start block=yes
      parseHandleRequestDevicePromptParams(params) {
        return params;
      }
      parseSimulateAdapterParameters(params) {
        return params;
      }
      parseSimulateAdvertisementParameters(params) {
        return params;
      }
      parseSimulatePreconnectedPeripheralParameters(params) {
        return params;
      }
      // keep-sorted end
      // Browser module
      // keep-sorted start block=yes
      parseRemoveUserContextParams(params) {
        return params;
      }
      // keep-sorted end
      // Browsing Context module
      // keep-sorted start block=yes
      parseActivateParams(params) {
        return params;
      }
      parseCaptureScreenshotParams(params) {
        return params;
      }
      parseCloseParams(params) {
        return params;
      }
      parseCreateParams(params) {
        return params;
      }
      parseGetTreeParams(params) {
        return params;
      }
      parseHandleUserPromptParams(params) {
        return params;
      }
      parseLocateNodesParams(params) {
        return params;
      }
      parseNavigateParams(params) {
        return params;
      }
      parsePrintParams(params) {
        return params;
      }
      parseReloadParams(params) {
        return params;
      }
      parseSetViewportParams(params) {
        return params;
      }
      parseTraverseHistoryParams(params) {
        return params;
      }
      // keep-sorted end
      // CDP module
      // keep-sorted start block=yes
      parseGetSessionParams(params) {
        return params;
      }
      parseResolveRealmParams(params) {
        return params;
      }
      parseSendCommandParams(params) {
        return params;
      }
      // keep-sorted end
      // Script module
      // keep-sorted start block=yes
      parseAddPreloadScriptParams(params) {
        return params;
      }
      parseCallFunctionParams(params) {
        return params;
      }
      parseDisownParams(params) {
        return params;
      }
      parseEvaluateParams(params) {
        return params;
      }
      parseGetRealmsParams(params) {
        return params;
      }
      parseRemovePreloadScriptParams(params) {
        return params;
      }
      // keep-sorted end
      // Input module
      // keep-sorted start block=yes
      parsePerformActionsParams(params) {
        return params;
      }
      parseReleaseActionsParams(params) {
        return params;
      }
      parseSetFilesParams(params) {
        return params;
      }
      // keep-sorted end
      // Network module
      // keep-sorted start block=yes
      parseAddInterceptParams(params) {
        return params;
      }
      parseContinueRequestParams(params) {
        return params;
      }
      parseContinueResponseParams(params) {
        return params;
      }
      parseContinueWithAuthParams(params) {
        return params;
      }
      parseFailRequestParams(params) {
        return params;
      }
      parseProvideResponseParams(params) {
        return params;
      }
      parseRemoveInterceptParams(params) {
        return params;
      }
      parseSetCacheBehavior(params) {
        return params;
      }
      // keep-sorted end
      // Permissions module
      // keep-sorted start block=yes
      parseSetPermissionsParams(params) {
        return params;
      }
      // keep-sorted end
      // Session module
      // keep-sorted start block=yes
      parseSubscribeParams(params) {
        return params;
      }
      parseUnsubscribeParams(params) {
        return params;
      }
      // keep-sorted end
      // Storage module
      // keep-sorted start block=yes
      parseDeleteCookiesParams(params) {
        return params;
      }
      parseGetCookiesParams(params) {
        return params;
      }
      parseSetCookieParams(params) {
        return params;
      }
      // keep-sorted end
      // WebExtenstion module
      // keep-sorted start block=yes
      parseInstallParams(params) {
        return params;
      }
      parseUninstallParams(params) {
        return params;
      }
    };
    exports.BidiNoOpParser = BidiNoOpParser;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js
var require_BrowserProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var BrowserProcessor = class {
      #browserCdpClient;
      #browsingContextStorage;
      #userContextStorage;
      constructor(browserCdpClient, browsingContextStorage, userContextStorage) {
        this.#browserCdpClient = browserCdpClient;
        this.#browsingContextStorage = browsingContextStorage;
        this.#userContextStorage = userContextStorage;
      }
      close() {
        setTimeout(() => this.#browserCdpClient.sendCommand("Browser.close"), 0);
        return {};
      }
      async createUserContext(params) {
        const request = {
          proxyServer: params["goog:proxyServer"] ?? void 0
        };
        const proxyBypassList = params["goog:proxyBypassList"] ?? void 0;
        if (proxyBypassList) {
          request.proxyBypassList = proxyBypassList.join(",");
        }
        const context2 = await this.#browserCdpClient.sendCommand("Target.createBrowserContext", request);
        return {
          userContext: context2.browserContextId
        };
      }
      async removeUserContext(params) {
        const userContext = params.userContext;
        if (userContext === "default") {
          throw new protocol_js_1.InvalidArgumentException("`default` user context cannot be removed");
        }
        try {
          await this.#browserCdpClient.sendCommand("Target.disposeBrowserContext", {
            browserContextId: userContext
          });
        } catch (err) {
          if (err.message.startsWith("Failed to find context with id")) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          throw err;
        }
        return {};
      }
      async getUserContexts() {
        return {
          userContexts: await this.#userContextStorage.getUserContexts()
        };
      }
      async #getWindowInfo(targetId) {
        const windowInfo = await this.#browserCdpClient.sendCommand("Browser.getWindowForTarget", { targetId });
        return {
          // `active` is not supported in CDP yet.
          active: false,
          clientWindow: `${windowInfo.windowId}`,
          state: windowInfo.bounds.windowState ?? "normal",
          height: windowInfo.bounds.height ?? 0,
          width: windowInfo.bounds.width ?? 0,
          x: windowInfo.bounds.left ?? 0,
          y: windowInfo.bounds.top ?? 0
        };
      }
      async getClientWindows() {
        const topLevelTargetIds = this.#browsingContextStorage.getTopLevelContexts().map((b) => b.cdpTarget.id);
        const clientWindows = await Promise.all(topLevelTargetIds.map(async (targetId) => await this.#getWindowInfo(targetId)));
        const uniqueClientWindowIds = /* @__PURE__ */ new Set();
        const uniqueClientWindows = new Array();
        for (const window2 of clientWindows) {
          if (!uniqueClientWindowIds.has(window2.clientWindow)) {
            uniqueClientWindowIds.add(window2.clientWindow);
            uniqueClientWindows.push(window2);
          }
        }
        return { clientWindows: uniqueClientWindows };
      }
    };
    exports.BrowserProcessor = BrowserProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js
var require_CdpProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CdpProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var CdpProcessor = class {
      #browsingContextStorage;
      #realmStorage;
      #cdpConnection;
      #browserCdpClient;
      constructor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#cdpConnection = cdpConnection;
        this.#browserCdpClient = browserCdpClient;
      }
      getSession(params) {
        const context2 = params.context;
        const sessionId = this.#browsingContextStorage.getContext(context2).cdpTarget.cdpSessionId;
        if (sessionId === void 0) {
          return {};
        }
        return { session: sessionId };
      }
      resolveRealm(params) {
        const context2 = params.realm;
        const realm = this.#realmStorage.getRealm({ realmId: context2 });
        if (realm === void 0) {
          throw new protocol_js_1.UnknownErrorException(`Could not find realm ${params.realm}`);
        }
        return { executionContextId: realm.executionContextId };
      }
      async sendCommand(params) {
        const client = params.session ? this.#cdpConnection.getCdpClient(params.session) : this.#browserCdpClient;
        const result = await client.sendCommand(params.method, params.params);
        return {
          result,
          session: params.session
        };
      }
    };
    exports.CdpProcessor = CdpProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js
var require_BrowsingContextProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowsingContextProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var BrowsingContextProcessor = class {
      #browserCdpClient;
      #browsingContextStorage;
      #eventManager;
      constructor(browserCdpClient, browsingContextStorage, eventManager) {
        this.#browserCdpClient = browserCdpClient;
        this.#browsingContextStorage = browsingContextStorage;
        this.#eventManager = eventManager;
        this.#eventManager.addSubscribeHook(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated, this.#onContextCreatedSubscribeHook.bind(this));
      }
      getTree(params) {
        const resultContexts = params.root === void 0 ? this.#browsingContextStorage.getTopLevelContexts() : [this.#browsingContextStorage.getContext(params.root)];
        return {
          contexts: resultContexts.map((c) => c.serializeToBidiValue(params.maxDepth ?? Number.MAX_VALUE))
        };
      }
      async create(params) {
        let referenceContext;
        let userContext = "default";
        if (params.referenceContext !== void 0) {
          referenceContext = this.#browsingContextStorage.getContext(params.referenceContext);
          if (!referenceContext.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException(`referenceContext should be a top-level context`);
          }
          userContext = referenceContext.userContext;
        }
        if (params.userContext !== void 0) {
          userContext = params.userContext;
        }
        const existingContexts = this.#browsingContextStorage.getAllContexts().filter((context3) => context3.userContext === userContext);
        let newWindow = false;
        switch (params.type) {
          case "tab":
            newWindow = false;
            break;
          case "window":
            newWindow = true;
            break;
        }
        if (!existingContexts.length) {
          newWindow = true;
        }
        let result;
        try {
          result = await this.#browserCdpClient.sendCommand("Target.createTarget", {
            url: "about:blank",
            newWindow,
            browserContextId: userContext === "default" ? void 0 : userContext,
            background: params.background === true
          });
        } catch (err) {
          if (
            // See https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/protocol/target_handler.cc;l=90;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
            err.message.startsWith("Failed to find browser context with id") || // See https://source.chromium.org/chromium/chromium/src/+/main:headless/lib/browser/protocol/target_handler.cc;l=49;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
            err.message === "browserContextId"
          ) {
            throw new protocol_js_1.NoSuchUserContextException(`The context ${userContext} was not found`);
          }
          throw err;
        }
        const context2 = await this.#browsingContextStorage.waitForContext(result.targetId);
        await context2.lifecycleLoaded();
        return { context: context2.id };
      }
      navigate(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        return context2.navigate(
          params.url,
          params.wait ?? "none"
          /* BrowsingContext.ReadinessState.None */
        );
      }
      reload(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        return context2.reload(
          params.ignoreCache ?? false,
          params.wait ?? "none"
          /* BrowsingContext.ReadinessState.None */
        );
      }
      async activate(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        if (!context2.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException("Activation is only supported on the top-level context");
        }
        await context2.activate();
        return {};
      }
      async captureScreenshot(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        return await context2.captureScreenshot(params);
      }
      async print(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        return await context2.print(params);
      }
      async setViewport(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        if (!context2.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException("Emulating viewport is only supported on the top-level context");
        }
        await context2.setViewport(params.viewport, params.devicePixelRatio);
        return {};
      }
      async traverseHistory(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        if (!context2) {
          throw new protocol_js_1.InvalidArgumentException(`No browsing context with id ${params.context}`);
        }
        if (!context2.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException("Traversing history is only supported on the top-level context");
        }
        await context2.traverseHistory(params.delta);
        return {};
      }
      async handleUserPrompt(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        try {
          await context2.handleUserPrompt(params.accept, params.userText);
        } catch (error) {
          if (error.message?.includes("No dialog is showing")) {
            throw new protocol_js_1.NoSuchAlertException("No dialog is showing");
          }
          throw error;
        }
        return {};
      }
      async close(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        if (!context2.isTopLevelContext()) {
          throw new protocol_js_1.InvalidArgumentException(`Non top-level browsing context ${context2.id} cannot be closed.`);
        }
        const parentCdpClient = context2.cdpTarget.parentCdpClient;
        try {
          const detachedFromTargetPromise = new Promise((resolve) => {
            const onContextDestroyed = (event) => {
              if (event.targetId === params.context) {
                parentCdpClient.off("Target.detachedFromTarget", onContextDestroyed);
                resolve();
              }
            };
            parentCdpClient.on("Target.detachedFromTarget", onContextDestroyed);
          });
          try {
            if (params.promptUnload) {
              await context2.close();
            } else {
              await parentCdpClient.sendCommand("Target.closeTarget", {
                targetId: params.context
              });
            }
          } catch (error) {
            if (!parentCdpClient.isCloseError(error)) {
              throw error;
            }
          }
          await detachedFromTargetPromise;
        } catch (error) {
          if (!(error.code === -32e3 && error.message === "Not attached to an active page")) {
            throw error;
          }
        }
        return {};
      }
      async locateNodes(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        return await context2.locateNodes(params);
      }
      #onContextCreatedSubscribeHook(contextId) {
        const context2 = this.#browsingContextStorage.getContext(contextId);
        const contextsToReport = [
          context2,
          ...this.#browsingContextStorage.getContext(contextId).allChildren
        ];
        contextsToReport.forEach((context3) => {
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
            params: context3.serializeToBidiValue()
          }, context3.id);
        });
        return Promise.resolve();
      }
    };
    exports.BrowsingContextProcessor = BrowsingContextProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/assert.js
var require_assert = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assert = assert2;
    function assert2(predicate, message) {
      if (!predicate) {
        throw new Error(message ?? "Internal assertion failed.");
      }
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/graphemeTools.js
var require_graphemeTools = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/graphemeTools.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSingleComplexGrapheme = isSingleComplexGrapheme;
    exports.isSingleGrapheme = isSingleGrapheme;
    function isSingleComplexGrapheme(value) {
      return isSingleGrapheme(value) && value.length > 1;
    }
    function isSingleGrapheme(value) {
      const segmenter = new Intl.Segmenter("en", { granularity: "grapheme" });
      return [...segmenter.segment(value)].length === 1;
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js
var require_InputSource = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js"(exports) {
    "use strict";
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WheelSource = exports.PointerSource = exports.KeySource = exports.NoneSource = void 0;
    var NoneSource = class {
      type = "none";
    };
    exports.NoneSource = NoneSource;
    var KeySource = class {
      type = "key";
      pressed = /* @__PURE__ */ new Set();
      // This is a bitfield that matches the modifiers parameter of
      // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent
      #modifiers = 0;
      get modifiers() {
        return this.#modifiers;
      }
      get alt() {
        return (this.#modifiers & 1) === 1;
      }
      set alt(value) {
        this.#setModifier(value, 1);
      }
      get ctrl() {
        return (this.#modifiers & 2) === 2;
      }
      set ctrl(value) {
        this.#setModifier(value, 2);
      }
      get meta() {
        return (this.#modifiers & 4) === 4;
      }
      set meta(value) {
        this.#setModifier(value, 4);
      }
      get shift() {
        return (this.#modifiers & 8) === 8;
      }
      set shift(value) {
        this.#setModifier(value, 8);
      }
      #setModifier(value, bit) {
        if (value) {
          this.#modifiers |= bit;
        } else {
          this.#modifiers &= ~bit;
        }
      }
    };
    exports.KeySource = KeySource;
    var _clickContexts;
    var PointerSource = class {
      constructor(id, subtype) {
        __publicField(this, "type", "pointer");
        __publicField(this, "subtype");
        __publicField(this, "pointerId");
        __publicField(this, "pressed", /* @__PURE__ */ new Set());
        __publicField(this, "x", 0);
        __publicField(this, "y", 0);
        __publicField(this, "radiusX");
        __publicField(this, "radiusY");
        __publicField(this, "force");
        __privateAdd(this, _clickContexts, /* @__PURE__ */ new Map());
        this.pointerId = id;
        this.subtype = subtype;
      }
      // This is a bitfield that matches the buttons parameter of
      // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent
      get buttons() {
        let buttons = 0;
        for (const button of this.pressed) {
          switch (button) {
            case 0:
              buttons |= 1;
              break;
            case 1:
              buttons |= 4;
              break;
            case 2:
              buttons |= 2;
              break;
            case 3:
              buttons |= 8;
              break;
            case 4:
              buttons |= 16;
              break;
          }
        }
        return buttons;
      }
      setClickCount(button, context2) {
        let storedContext = __privateGet(this, _clickContexts).get(button);
        if (!storedContext || storedContext.compare(context2)) {
          storedContext = context2;
        }
        ++storedContext.count;
        __privateGet(this, _clickContexts).set(button, storedContext);
        return storedContext.count;
      }
      getClickCount(button) {
        return __privateGet(this, _clickContexts).get(button)?.count ?? 0;
      }
      /**
       * Resets click count. Resets consequent click counter. Prevents grouping clicks in
       * different `performActions` calls, so that they are not grouped as double, triple etc
       * clicks. Required for https://github.com/GoogleChromeLabs/chromium-bidi/issues/3043.
       */
      resetClickCount() {
        __privateSet(this, _clickContexts, /* @__PURE__ */ new Map());
      }
    };
    _clickContexts = new WeakMap();
    // --- Platform-specific code starts here ---
    // Input.dispatchMouseEvent doesn't know the concept of double click, so we
    // need to create the logic, similar to how it's done for OSes:
    // https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:ui/events/event.cc;l=479
    __publicField(PointerSource, "ClickContext", class ClickContext {
      static #DOUBLE_CLICK_TIME_MS = 500;
      static #MAX_DOUBLE_CLICK_RADIUS = 2;
      count = 0;
      #x;
      #y;
      #time;
      constructor(x, y, time) {
        this.#x = x;
        this.#y = y;
        this.#time = time;
      }
      compare(context2) {
        return (
          // The click needs to be within a certain amount of ms.
          context2.#time - this.#time > ClickContext.#DOUBLE_CLICK_TIME_MS || // The click needs to be within a certain square radius.
          Math.abs(context2.#x - this.#x) > ClickContext.#MAX_DOUBLE_CLICK_RADIUS || Math.abs(context2.#y - this.#y) > ClickContext.#MAX_DOUBLE_CLICK_RADIUS
        );
      }
    });
    exports.PointerSource = PointerSource;
    _a3 = PointerSource;
    var WheelSource = class {
      type = "wheel";
    };
    exports.WheelSource = WheelSource;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js
var require_keyUtils = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNormalizedKey = getNormalizedKey;
    exports.getKeyCode = getKeyCode;
    exports.getKeyLocation = getKeyLocation;
    function getNormalizedKey(value) {
      switch (value) {
        case "\uE000":
          return "Unidentified";
        case "\uE001":
          return "Cancel";
        case "\uE002":
          return "Help";
        case "\uE003":
          return "Backspace";
        case "\uE004":
          return "Tab";
        case "\uE005":
          return "Clear";
        case "\uE006":
        case "\uE007":
          return "Enter";
        case "\uE008":
          return "Shift";
        case "\uE009":
          return "Control";
        case "\uE00A":
          return "Alt";
        case "\uE00B":
          return "Pause";
        case "\uE00C":
          return "Escape";
        case "\uE00D":
          return " ";
        case "\uE00E":
          return "PageUp";
        case "\uE00F":
          return "PageDown";
        case "\uE010":
          return "End";
        case "\uE011":
          return "Home";
        case "\uE012":
          return "ArrowLeft";
        case "\uE013":
          return "ArrowUp";
        case "\uE014":
          return "ArrowRight";
        case "\uE015":
          return "ArrowDown";
        case "\uE016":
          return "Insert";
        case "\uE017":
          return "Delete";
        case "\uE018":
          return ";";
        case "\uE019":
          return "=";
        case "\uE01A":
          return "0";
        case "\uE01B":
          return "1";
        case "\uE01C":
          return "2";
        case "\uE01D":
          return "3";
        case "\uE01E":
          return "4";
        case "\uE01F":
          return "5";
        case "\uE020":
          return "6";
        case "\uE021":
          return "7";
        case "\uE022":
          return "8";
        case "\uE023":
          return "9";
        case "\uE024":
          return "*";
        case "\uE025":
          return "+";
        case "\uE026":
          return ",";
        case "\uE027":
          return "-";
        case "\uE028":
          return ".";
        case "\uE029":
          return "/";
        case "\uE031":
          return "F1";
        case "\uE032":
          return "F2";
        case "\uE033":
          return "F3";
        case "\uE034":
          return "F4";
        case "\uE035":
          return "F5";
        case "\uE036":
          return "F6";
        case "\uE037":
          return "F7";
        case "\uE038":
          return "F8";
        case "\uE039":
          return "F9";
        case "\uE03A":
          return "F10";
        case "\uE03B":
          return "F11";
        case "\uE03C":
          return "F12";
        case "\uE03D":
          return "Meta";
        case "\uE040":
          return "ZenkakuHankaku";
        case "\uE050":
          return "Shift";
        case "\uE051":
          return "Control";
        case "\uE052":
          return "Alt";
        case "\uE053":
          return "Meta";
        case "\uE054":
          return "PageUp";
        case "\uE055":
          return "PageDown";
        case "\uE056":
          return "End";
        case "\uE057":
          return "Home";
        case "\uE058":
          return "ArrowLeft";
        case "\uE059":
          return "ArrowUp";
        case "\uE05A":
          return "ArrowRight";
        case "\uE05B":
          return "ArrowDown";
        case "\uE05C":
          return "Insert";
        case "\uE05D":
          return "Delete";
        default:
          return value;
      }
    }
    function getKeyCode(key) {
      switch (key) {
        case "`":
        case "~":
          return "Backquote";
        case "\\":
        case "|":
          return "Backslash";
        case "\uE003":
          return "Backspace";
        case "[":
        case "{":
          return "BracketLeft";
        case "]":
        case "}":
          return "BracketRight";
        case ",":
        case "<":
          return "Comma";
        case "0":
        case ")":
          return "Digit0";
        case "1":
        case "!":
          return "Digit1";
        case "2":
        case "@":
          return "Digit2";
        case "3":
        case "#":
          return "Digit3";
        case "4":
        case "$":
          return "Digit4";
        case "5":
        case "%":
          return "Digit5";
        case "6":
        case "^":
          return "Digit6";
        case "7":
        case "&":
          return "Digit7";
        case "8":
        case "*":
          return "Digit8";
        case "9":
        case "(":
          return "Digit9";
        case "=":
        case "+":
          return "Equal";
        case ">":
          return "IntlBackslash";
        case "a":
        case "A":
          return "KeyA";
        case "b":
        case "B":
          return "KeyB";
        case "c":
        case "C":
          return "KeyC";
        case "d":
        case "D":
          return "KeyD";
        case "e":
        case "E":
          return "KeyE";
        case "f":
        case "F":
          return "KeyF";
        case "g":
        case "G":
          return "KeyG";
        case "h":
        case "H":
          return "KeyH";
        case "i":
        case "I":
          return "KeyI";
        case "j":
        case "J":
          return "KeyJ";
        case "k":
        case "K":
          return "KeyK";
        case "l":
        case "L":
          return "KeyL";
        case "m":
        case "M":
          return "KeyM";
        case "n":
        case "N":
          return "KeyN";
        case "o":
        case "O":
          return "KeyO";
        case "p":
        case "P":
          return "KeyP";
        case "q":
        case "Q":
          return "KeyQ";
        case "r":
        case "R":
          return "KeyR";
        case "s":
        case "S":
          return "KeyS";
        case "t":
        case "T":
          return "KeyT";
        case "u":
        case "U":
          return "KeyU";
        case "v":
        case "V":
          return "KeyV";
        case "w":
        case "W":
          return "KeyW";
        case "x":
        case "X":
          return "KeyX";
        case "y":
        case "Y":
          return "KeyY";
        case "z":
        case "Z":
          return "KeyZ";
        case "-":
        case "_":
          return "Minus";
        case ".":
          return "Period";
        case "'":
        case '"':
          return "Quote";
        case ";":
        case ":":
          return "Semicolon";
        case "/":
        case "?":
          return "Slash";
        case "\uE00A":
          return "AltLeft";
        case "\uE052":
          return "AltRight";
        case "\uE009":
          return "ControlLeft";
        case "\uE051":
          return "ControlRight";
        case "\uE006":
          return "Enter";
        case "\uE00B":
          return "Pause";
        case "\uE03D":
          return "MetaLeft";
        case "\uE053":
          return "MetaRight";
        case "\uE008":
          return "ShiftLeft";
        case "\uE050":
          return "ShiftRight";
        case " ":
        case "\uE00D":
          return "Space";
        case "\uE004":
          return "Tab";
        case "\uE017":
          return "Delete";
        case "\uE010":
          return "End";
        case "\uE002":
          return "Help";
        case "\uE011":
          return "Home";
        case "\uE016":
          return "Insert";
        case "\uE00F":
          return "PageDown";
        case "\uE00E":
          return "PageUp";
        case "\uE015":
          return "ArrowDown";
        case "\uE012":
          return "ArrowLeft";
        case "\uE014":
          return "ArrowRight";
        case "\uE013":
          return "ArrowUp";
        case "\uE00C":
          return "Escape";
        case "\uE031":
          return "F1";
        case "\uE032":
          return "F2";
        case "\uE033":
          return "F3";
        case "\uE034":
          return "F4";
        case "\uE035":
          return "F5";
        case "\uE036":
          return "F6";
        case "\uE037":
          return "F7";
        case "\uE038":
          return "F8";
        case "\uE039":
          return "F9";
        case "\uE03A":
          return "F10";
        case "\uE03B":
          return "F11";
        case "\uE03C":
          return "F12";
        case "\uE019":
          return "NumpadEqual";
        case "\uE01A":
        case "\uE05C":
          return "Numpad0";
        case "\uE01B":
        case "\uE056":
          return "Numpad1";
        case "\uE01C":
        case "\uE05B":
          return "Numpad2";
        case "\uE01D":
        case "\uE055":
          return "Numpad3";
        case "\uE01E":
        case "\uE058":
          return "Numpad4";
        case "\uE01F":
          return "Numpad5";
        case "\uE020":
        case "\uE05A":
          return "Numpad6";
        case "\uE021":
        case "\uE057":
          return "Numpad7";
        case "\uE022":
        case "\uE059":
          return "Numpad8";
        case "\uE023":
        case "\uE054":
          return "Numpad9";
        case "\uE025":
          return "NumpadAdd";
        case "\uE026":
          return "NumpadComma";
        case "\uE028":
        case "\uE05D":
          return "NumpadDecimal";
        case "\uE029":
          return "NumpadDivide";
        case "\uE007":
          return "NumpadEnter";
        case "\uE024":
          return "NumpadMultiply";
        case "\uE027":
          return "NumpadSubtract";
        default:
          return;
      }
    }
    function getKeyLocation(key) {
      switch (key) {
        case "\uE007":
        case "\uE008":
        case "\uE009":
        case "\uE00A":
        case "\uE03D":
          return 1;
        case "\uE019":
        case "\uE01A":
        case "\uE01B":
        case "\uE01C":
        case "\uE01D":
        case "\uE01E":
        case "\uE01F":
        case "\uE020":
        case "\uE021":
        case "\uE022":
        case "\uE023":
        case "\uE024":
        case "\uE025":
        case "\uE026":
        case "\uE027":
        case "\uE028":
        case "\uE029":
        case "\uE054":
        case "\uE055":
        case "\uE056":
        case "\uE057":
        case "\uE058":
        case "\uE059":
        case "\uE05A":
        case "\uE05B":
        case "\uE05C":
        case "\uE05D":
          return 3;
        case "\uE050":
        case "\uE051":
        case "\uE052":
        case "\uE053":
          return 2;
        default:
          return 0;
      }
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js
var require_USKeyboardLayout = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyToKeyCode = void 0;
    exports.KeyToKeyCode = {
      "0": 48,
      "1": 49,
      "2": 50,
      "3": 51,
      "4": 52,
      "5": 53,
      "6": 54,
      "7": 55,
      "8": 56,
      "9": 57,
      Abort: 3,
      Help: 6,
      Backspace: 8,
      Tab: 9,
      Numpad5: 12,
      NumpadEnter: 13,
      Enter: 13,
      "\\r": 13,
      "\\n": 13,
      ShiftLeft: 16,
      ShiftRight: 16,
      ControlLeft: 17,
      ControlRight: 17,
      AltLeft: 18,
      AltRight: 18,
      Pause: 19,
      CapsLock: 20,
      Escape: 27,
      Convert: 28,
      NonConvert: 29,
      Space: 32,
      Numpad9: 33,
      PageUp: 33,
      Numpad3: 34,
      PageDown: 34,
      End: 35,
      Numpad1: 35,
      Home: 36,
      Numpad7: 36,
      ArrowLeft: 37,
      Numpad4: 37,
      Numpad8: 38,
      ArrowUp: 38,
      ArrowRight: 39,
      Numpad6: 39,
      Numpad2: 40,
      ArrowDown: 40,
      Select: 41,
      Open: 43,
      PrintScreen: 44,
      Insert: 45,
      Numpad0: 45,
      Delete: 46,
      NumpadDecimal: 46,
      Digit0: 48,
      Digit1: 49,
      Digit2: 50,
      Digit3: 51,
      Digit4: 52,
      Digit5: 53,
      Digit6: 54,
      Digit7: 55,
      Digit8: 56,
      Digit9: 57,
      KeyA: 65,
      KeyB: 66,
      KeyC: 67,
      KeyD: 68,
      KeyE: 69,
      KeyF: 70,
      KeyG: 71,
      KeyH: 72,
      KeyI: 73,
      KeyJ: 74,
      KeyK: 75,
      KeyL: 76,
      KeyM: 77,
      KeyN: 78,
      KeyO: 79,
      KeyP: 80,
      KeyQ: 81,
      KeyR: 82,
      KeyS: 83,
      KeyT: 84,
      KeyU: 85,
      KeyV: 86,
      KeyW: 87,
      KeyX: 88,
      KeyY: 89,
      KeyZ: 90,
      MetaLeft: 91,
      MetaRight: 92,
      ContextMenu: 93,
      NumpadMultiply: 106,
      NumpadAdd: 107,
      NumpadSubtract: 109,
      NumpadDivide: 111,
      F1: 112,
      F2: 113,
      F3: 114,
      F4: 115,
      F5: 116,
      F6: 117,
      F7: 118,
      F8: 119,
      F9: 120,
      F10: 121,
      F11: 122,
      F12: 123,
      F13: 124,
      F14: 125,
      F15: 126,
      F16: 127,
      F17: 128,
      F18: 129,
      F19: 130,
      F20: 131,
      F21: 132,
      F22: 133,
      F23: 134,
      F24: 135,
      NumLock: 144,
      ScrollLock: 145,
      AudioVolumeMute: 173,
      AudioVolumeDown: 174,
      AudioVolumeUp: 175,
      MediaTrackNext: 176,
      MediaTrackPrevious: 177,
      MediaStop: 178,
      MediaPlayPause: 179,
      Semicolon: 186,
      Equal: 187,
      NumpadEqual: 187,
      Comma: 188,
      Minus: 189,
      Period: 190,
      Slash: 191,
      Backquote: 192,
      BracketLeft: 219,
      Backslash: 220,
      BracketRight: 221,
      Quote: 222,
      AltGraph: 225,
      Props: 247,
      Cancel: 3,
      Clear: 12,
      Shift: 16,
      Control: 17,
      Alt: 18,
      Accept: 30,
      ModeChange: 31,
      " ": 32,
      Print: 42,
      Execute: 43,
      "\\u0000": 46,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      Meta: 91,
      "*": 106,
      "+": 107,
      "-": 109,
      "/": 111,
      ";": 186,
      "=": 187,
      ",": 188,
      ".": 190,
      "`": 192,
      "[": 219,
      "\\\\": 220,
      "]": 221,
      "'": 222,
      Attn: 246,
      CrSel: 247,
      ExSel: 248,
      EraseEof: 249,
      Play: 250,
      ZoomOut: 251,
      ")": 48,
      "!": 49,
      "@": 50,
      "#": 51,
      $: 52,
      "%": 53,
      "^": 54,
      "&": 55,
      "(": 57,
      A: 65,
      B: 66,
      C: 67,
      D: 68,
      E: 69,
      F: 70,
      G: 71,
      H: 72,
      I: 73,
      J: 74,
      K: 75,
      L: 76,
      M: 77,
      N: 78,
      O: 79,
      P: 80,
      Q: 81,
      R: 82,
      S: 83,
      T: 84,
      U: 85,
      V: 86,
      W: 87,
      X: 88,
      Y: 89,
      Z: 90,
      ":": 186,
      "<": 188,
      _: 189,
      ">": 190,
      "?": 191,
      "~": 192,
      "{": 219,
      "|": 220,
      "}": 221,
      '"': 222,
      Camera: 44,
      EndCall: 95,
      VolumeDown: 182,
      VolumeUp: 183
    };
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js
var require_ActionDispatcher = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionDispatcher = void 0;
    var protocol_js_1 = require_protocol();
    var assert_js_1 = require_assert();
    var graphemeTools_js_1 = require_graphemeTools();
    var InputSource_js_1 = require_InputSource();
    var keyUtils_js_1 = require_keyUtils();
    var USKeyboardLayout_js_1 = require_USKeyboardLayout();
    var CALCULATE_IN_VIEW_CENTER_PT_DECL = ((i) => {
      const t = i.getClientRects()[0], e = Math.max(0, Math.min(t.x, t.x + t.width)), n = Math.min(window.innerWidth, Math.max(t.x, t.x + t.width)), h = Math.max(0, Math.min(t.y, t.y + t.height)), m = Math.min(window.innerHeight, Math.max(t.y, t.y + t.height));
      return [e + (n - e >> 1), h + (m - h >> 1)];
    }).toString();
    var IS_MAC_DECL = (() => {
      return navigator.platform.toLowerCase().includes("mac");
    }).toString();
    async function getElementCenter(context2, element) {
      const sandbox = await context2.getOrCreateSandbox(void 0);
      const result = await sandbox.callFunction(CALCULATE_IN_VIEW_CENTER_PT_DECL, false, { type: "undefined" }, [element]);
      if (result.type === "exception") {
        throw new protocol_js_1.NoSuchElementException(`Origin element ${element.sharedId} was not found`);
      }
      (0, assert_js_1.assert)(result.result.type === "array");
      (0, assert_js_1.assert)(result.result.value?.[0]?.type === "number");
      (0, assert_js_1.assert)(result.result.value?.[1]?.type === "number");
      const { result: { value: [{ value: x }, { value: y }] } } = result;
      return { x, y };
    }
    var _browsingContextStorage, _tickStart, _tickDuration, _inputState, _contextId, _isMacOS, _context, context_get, _dispatchAction, dispatchAction_fn, _dispatchPointerDownAction, dispatchPointerDownAction_fn, _dispatchPointerUpAction, dispatchPointerUpAction_fn, _dispatchPointerMoveAction, dispatchPointerMoveAction_fn, _getFrameOffset, getFrameOffset_fn, _getCoordinateFromOrigin, getCoordinateFromOrigin_fn, _dispatchScrollAction, dispatchScrollAction_fn, _dispatchKeyDownAction, dispatchKeyDownAction_fn, _dispatchKeyUpAction, dispatchKeyUpAction_fn;
    var ActionDispatcher = class {
      constructor(inputState, browsingContextStorage, contextId, isMacOS) {
        /**
         * The context can be disposed between action ticks, so need to get it each time.
         */
        __privateAdd(this, _context);
        __privateAdd(this, _dispatchAction);
        __privateAdd(this, _dispatchPointerDownAction);
        __privateAdd(this, _dispatchPointerUpAction);
        __privateAdd(this, _dispatchPointerMoveAction);
        __privateAdd(this, _getFrameOffset);
        __privateAdd(this, _getCoordinateFromOrigin);
        __privateAdd(this, _dispatchScrollAction);
        __privateAdd(this, _dispatchKeyDownAction);
        __privateAdd(this, _dispatchKeyUpAction);
        __privateAdd(this, _browsingContextStorage, void 0);
        __privateAdd(this, _tickStart, 0);
        __privateAdd(this, _tickDuration, 0);
        __privateAdd(this, _inputState, void 0);
        __privateAdd(this, _contextId, void 0);
        __privateAdd(this, _isMacOS, void 0);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _inputState, inputState);
        __privateSet(this, _contextId, contextId);
        __privateSet(this, _isMacOS, isMacOS);
      }
      async dispatchActions(optionsByTick) {
        await __privateGet(this, _inputState).queue.run(async () => {
          for (const options of optionsByTick) {
            await this.dispatchTickActions(options);
          }
        });
      }
      async dispatchTickActions(options) {
        __privateSet(this, _tickStart, performance.now());
        __privateSet(this, _tickDuration, 0);
        for (const { action } of options) {
          if ("duration" in action && action.duration !== void 0) {
            __privateSet(this, _tickDuration, Math.max(__privateGet(this, _tickDuration), action.duration));
          }
        }
        const promises = [
          new Promise((resolve) => setTimeout(resolve, __privateGet(this, _tickDuration)))
        ];
        for (const option of options) {
          promises.push(__privateMethod(this, _dispatchAction, dispatchAction_fn).call(this, option));
        }
        await Promise.all(promises);
      }
    };
    _browsingContextStorage = new WeakMap();
    _tickStart = new WeakMap();
    _tickDuration = new WeakMap();
    _inputState = new WeakMap();
    _contextId = new WeakMap();
    _isMacOS = new WeakMap();
    _context = new WeakSet();
    context_get = function() {
      return __privateGet(this, _browsingContextStorage).getContext(__privateGet(this, _contextId));
    };
    _dispatchAction = new WeakSet();
    dispatchAction_fn = async function({ id, action }) {
      const source2 = __privateGet(this, _inputState).get(id);
      const keyState = __privateGet(this, _inputState).getGlobalKeyState();
      switch (action.type) {
        case "keyDown": {
          await __privateMethod(this, _dispatchKeyDownAction, dispatchKeyDownAction_fn).call(this, source2, action);
          __privateGet(this, _inputState).cancelList.push({
            id,
            action: {
              ...action,
              type: "keyUp"
            }
          });
          break;
        }
        case "keyUp": {
          await __privateMethod(this, _dispatchKeyUpAction, dispatchKeyUpAction_fn).call(this, source2, action);
          break;
        }
        case "pause": {
          break;
        }
        case "pointerDown": {
          await __privateMethod(this, _dispatchPointerDownAction, dispatchPointerDownAction_fn).call(this, source2, keyState, action);
          __privateGet(this, _inputState).cancelList.push({
            id,
            action: {
              ...action,
              type: "pointerUp"
            }
          });
          break;
        }
        case "pointerMove": {
          await __privateMethod(this, _dispatchPointerMoveAction, dispatchPointerMoveAction_fn).call(this, source2, keyState, action);
          break;
        }
        case "pointerUp": {
          await __privateMethod(this, _dispatchPointerUpAction, dispatchPointerUpAction_fn).call(this, source2, keyState, action);
          break;
        }
        case "scroll": {
          await __privateMethod(this, _dispatchScrollAction, dispatchScrollAction_fn).call(this, source2, keyState, action);
          break;
        }
      }
    };
    _dispatchPointerDownAction = new WeakSet();
    dispatchPointerDownAction_fn = async function(source2, keyState, action) {
      const { button } = action;
      if (source2.pressed.has(button)) {
        return;
      }
      source2.pressed.add(button);
      const { x, y, subtype: pointerType } = source2;
      const { width, height, pressure, twist, tangentialPressure } = action;
      const { tiltX, tiltY } = getTilt(action);
      const { modifiers } = keyState;
      const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
      switch (pointerType) {
        case "mouse":
        case "pen":
          await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
            type: "mousePressed",
            x,
            y,
            modifiers,
            button: getCdpButton(button),
            buttons: source2.buttons,
            clickCount: source2.setClickCount(button, new InputSource_js_1.PointerSource.ClickContext(x, y, performance.now())),
            pointerType,
            tangentialPressure,
            tiltX,
            tiltY,
            twist,
            force: pressure
          });
          break;
        case "touch":
          await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
            type: "touchStart",
            touchPoints: [
              {
                x,
                y,
                radiusX,
                radiusY,
                tangentialPressure,
                tiltX,
                tiltY,
                twist,
                force: pressure,
                id: source2.pointerId
              }
            ],
            modifiers
          });
          break;
      }
      source2.radiusX = radiusX;
      source2.radiusY = radiusY;
      source2.force = pressure;
    };
    _dispatchPointerUpAction = new WeakSet();
    dispatchPointerUpAction_fn = function(source2, keyState, action) {
      const { button } = action;
      if (!source2.pressed.has(button)) {
        return;
      }
      source2.pressed.delete(button);
      const { x, y, force, radiusX, radiusY, subtype: pointerType } = source2;
      const { modifiers } = keyState;
      switch (pointerType) {
        case "mouse":
        case "pen":
          return __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            x,
            y,
            modifiers,
            button: getCdpButton(button),
            buttons: source2.buttons,
            clickCount: source2.getClickCount(button),
            pointerType
          });
        case "touch":
          return __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
            type: "touchEnd",
            touchPoints: [
              {
                x,
                y,
                id: source2.pointerId,
                force,
                radiusX,
                radiusY
              }
            ],
            modifiers
          });
      }
    };
    _dispatchPointerMoveAction = new WeakSet();
    dispatchPointerMoveAction_fn = async function(source2, keyState, action) {
      const { x: startX, y: startY, subtype: pointerType } = source2;
      const { width, height, pressure, twist, tangentialPressure, x: offsetX, y: offsetY, origin = "viewport", duration = __privateGet(this, _tickDuration) } = action;
      const { tiltX, tiltY } = getTilt(action);
      const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
      const { targetX, targetY } = await __privateMethod(this, _getCoordinateFromOrigin, getCoordinateFromOrigin_fn).call(this, origin, offsetX, offsetY, startX, startY);
      if (targetX < 0 || targetY < 0) {
        throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
      }
      let last2;
      do {
        const ratio = duration > 0 ? (performance.now() - __privateGet(this, _tickStart)) / duration : 1;
        last2 = ratio >= 1;
        let x;
        let y;
        if (last2) {
          x = targetX;
          y = targetY;
        } else {
          x = Math.round(ratio * (targetX - startX) + startX);
          y = Math.round(ratio * (targetY - startY) + startY);
        }
        if (source2.x !== x || source2.y !== y) {
          const { modifiers } = keyState;
          switch (pointerType) {
            case "mouse":
              await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                type: "mouseMoved",
                x,
                y,
                modifiers,
                clickCount: 0,
                button: getCdpButton(source2.pressed.values().next().value ?? 5),
                buttons: source2.buttons,
                pointerType,
                tangentialPressure,
                tiltX,
                tiltY,
                twist,
                force: pressure
              });
              break;
            case "pen":
              if (source2.pressed.size !== 0) {
                await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                  type: "mouseMoved",
                  x,
                  y,
                  modifiers,
                  clickCount: 0,
                  button: getCdpButton(source2.pressed.values().next().value ?? 5),
                  buttons: source2.buttons,
                  pointerType,
                  tangentialPressure,
                  tiltX,
                  tiltY,
                  twist,
                  force: pressure ?? 0.5
                });
              }
              break;
            case "touch":
              if (source2.pressed.size !== 0) {
                await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                  type: "touchMove",
                  touchPoints: [
                    {
                      x,
                      y,
                      radiusX,
                      radiusY,
                      tangentialPressure,
                      tiltX,
                      tiltY,
                      twist,
                      force: pressure,
                      id: source2.pointerId
                    }
                  ],
                  modifiers
                });
              }
              break;
          }
          source2.x = x;
          source2.y = y;
          source2.radiusX = radiusX;
          source2.radiusY = radiusY;
          source2.force = pressure;
        }
      } while (!last2);
    };
    _getFrameOffset = new WeakSet();
    getFrameOffset_fn = async function() {
      if (__privateGet(this, _context, context_get).id === __privateGet(this, _context, context_get).cdpTarget.id) {
        return { x: 0, y: 0 };
      }
      const { backendNodeId } = await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("DOM.getFrameOwner", { frameId: __privateGet(this, _context, context_get).id });
      const { model: frameBoxModel } = await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("DOM.getBoxModel", {
        backendNodeId
      });
      return { x: frameBoxModel.content[0], y: frameBoxModel.content[1] };
    };
    _getCoordinateFromOrigin = new WeakSet();
    getCoordinateFromOrigin_fn = async function(origin, offsetX, offsetY, startX, startY) {
      let targetX;
      let targetY;
      const frameOffset = await __privateMethod(this, _getFrameOffset, getFrameOffset_fn).call(this);
      switch (origin) {
        case "viewport":
          targetX = offsetX + frameOffset.x;
          targetY = offsetY + frameOffset.y;
          break;
        case "pointer":
          targetX = startX + offsetX + frameOffset.x;
          targetY = startY + offsetY + frameOffset.y;
          break;
        default: {
          const { x: posX, y: posY } = await getElementCenter(__privateGet(this, _context, context_get), origin.element);
          targetX = posX + offsetX + frameOffset.x;
          targetY = posY + offsetY + frameOffset.y;
          break;
        }
      }
      return { targetX, targetY };
    };
    _dispatchScrollAction = new WeakSet();
    dispatchScrollAction_fn = async function(_source, keyState, action) {
      const { deltaX: targetDeltaX, deltaY: targetDeltaY, x: offsetX, y: offsetY, origin = "viewport", duration = __privateGet(this, _tickDuration) } = action;
      if (origin === "pointer") {
        throw new protocol_js_1.InvalidArgumentException('"pointer" origin is invalid for scrolling.');
      }
      const { targetX, targetY } = await __privateMethod(this, _getCoordinateFromOrigin, getCoordinateFromOrigin_fn).call(this, origin, offsetX, offsetY, 0, 0);
      if (targetX < 0 || targetY < 0) {
        throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
      }
      let currentDeltaX = 0;
      let currentDeltaY = 0;
      let last2;
      do {
        const ratio = duration > 0 ? (performance.now() - __privateGet(this, _tickStart)) / duration : 1;
        last2 = ratio >= 1;
        let deltaX;
        let deltaY;
        if (last2) {
          deltaX = targetDeltaX - currentDeltaX;
          deltaY = targetDeltaY - currentDeltaY;
        } else {
          deltaX = Math.round(ratio * targetDeltaX - currentDeltaX);
          deltaY = Math.round(ratio * targetDeltaY - currentDeltaY);
        }
        if (deltaX !== 0 || deltaY !== 0) {
          const { modifiers } = keyState;
          await __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
            type: "mouseWheel",
            deltaX,
            deltaY,
            x: targetX,
            y: targetY,
            modifiers
          });
          currentDeltaX += deltaX;
          currentDeltaY += deltaY;
        }
      } while (!last2);
    };
    _dispatchKeyDownAction = new WeakSet();
    dispatchKeyDownAction_fn = async function(source2, action) {
      const rawKey = action.value;
      if (!(0, graphemeTools_js_1.isSingleGrapheme)(rawKey)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
      }
      const isGrapheme = (0, graphemeTools_js_1.isSingleComplexGrapheme)(rawKey);
      const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
      const repeat = source2.pressed.has(key);
      const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
      const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
      switch (key) {
        case "Alt":
          source2.alt = true;
          break;
        case "Shift":
          source2.shift = true;
          break;
        case "Control":
          source2.ctrl = true;
          break;
        case "Meta":
          source2.meta = true;
          break;
      }
      source2.pressed.add(key);
      const { modifiers } = source2;
      const unmodifiedText = getKeyEventUnmodifiedText(key, source2, isGrapheme);
      const text = getKeyEventText(code ?? "", source2) ?? unmodifiedText;
      let command;
      if (__privateGet(this, _isMacOS) && source2.meta) {
        switch (code) {
          case "KeyA":
            command = "SelectAll";
            break;
          case "KeyC":
            command = "Copy";
            break;
          case "KeyV":
            command = source2.shift ? "PasteAndMatchStyle" : "Paste";
            break;
          case "KeyX":
            command = "Cut";
            break;
          case "KeyZ":
            command = source2.shift ? "Redo" : "Undo";
            break;
          default:
        }
      }
      const promises = [
        __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
          type: text ? "keyDown" : "rawKeyDown",
          windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
          key,
          code,
          text,
          unmodifiedText,
          autoRepeat: repeat,
          isSystemKey: source2.alt || void 0,
          location: location < 3 ? location : void 0,
          isKeypad: location === 3,
          modifiers,
          commands: command ? [command] : void 0
        })
      ];
      if (key === "Escape") {
        if (!source2.alt && (__privateGet(this, _isMacOS) && !source2.ctrl && !source2.meta || !__privateGet(this, _isMacOS))) {
          promises.push(__privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.cancelDragging"));
        }
      }
      await Promise.all(promises);
    };
    _dispatchKeyUpAction = new WeakSet();
    dispatchKeyUpAction_fn = function(source2, action) {
      const rawKey = action.value;
      if (!(0, graphemeTools_js_1.isSingleGrapheme)(rawKey)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
      }
      const isGrapheme = (0, graphemeTools_js_1.isSingleComplexGrapheme)(rawKey);
      const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
      if (!source2.pressed.has(key)) {
        return;
      }
      const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
      const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
      switch (key) {
        case "Alt":
          source2.alt = false;
          break;
        case "Shift":
          source2.shift = false;
          break;
        case "Control":
          source2.ctrl = false;
          break;
        case "Meta":
          source2.meta = false;
          break;
      }
      source2.pressed.delete(key);
      const { modifiers } = source2;
      const unmodifiedText = getKeyEventUnmodifiedText(key, source2, isGrapheme);
      const text = getKeyEventText(code ?? "", source2) ?? unmodifiedText;
      return __privateGet(this, _context, context_get).cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
        type: "keyUp",
        windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
        key,
        code,
        text,
        unmodifiedText,
        location: location < 3 ? location : void 0,
        isSystemKey: source2.alt || void 0,
        isKeypad: location === 3,
        modifiers
      });
    };
    __publicField(ActionDispatcher, "isMacOS", async (context2) => {
      const result = await (await context2.getOrCreateSandbox(void 0)).callFunction(IS_MAC_DECL, false);
      (0, assert_js_1.assert)(result.type !== "exception");
      (0, assert_js_1.assert)(result.result.type === "boolean");
      return result.result.value;
    });
    exports.ActionDispatcher = ActionDispatcher;
    var getKeyEventUnmodifiedText = (key, source2, isGrapheme) => {
      if (isGrapheme) {
        return key;
      }
      if (key === "Enter") {
        return "\r";
      }
      return [...key].length === 1 ? source2.shift ? key.toLocaleUpperCase("en-US") : key : void 0;
    };
    var getKeyEventText = (code, source2) => {
      if (source2.ctrl) {
        switch (code) {
          case "Digit2":
            if (source2.shift) {
              return "\0";
            }
            break;
          case "KeyA":
            return "";
          case "KeyB":
            return "";
          case "KeyC":
            return "";
          case "KeyD":
            return "";
          case "KeyE":
            return "";
          case "KeyF":
            return "";
          case "KeyG":
            return "\x07";
          case "KeyH":
            return "\b";
          case "KeyI":
            return "	";
          case "KeyJ":
            return "\n";
          case "KeyK":
            return "\v";
          case "KeyL":
            return "\f";
          case "KeyM":
            return "\r";
          case "KeyN":
            return "";
          case "KeyO":
            return "";
          case "KeyP":
            return "";
          case "KeyQ":
            return "";
          case "KeyR":
            return "";
          case "KeyS":
            return "";
          case "KeyT":
            return "";
          case "KeyU":
            return "";
          case "KeyV":
            return "";
          case "KeyW":
            return "";
          case "KeyX":
            return "";
          case "KeyY":
            return "";
          case "KeyZ":
            return "";
          case "BracketLeft":
            return "\x1B";
          case "Backslash":
            return "";
          case "BracketRight":
            return "";
          case "Digit6":
            if (source2.shift) {
              return "";
            }
            break;
          case "Minus":
            return "";
        }
        return "";
      }
      if (source2.alt) {
        return "";
      }
      return;
    };
    function getCdpButton(button) {
      switch (button) {
        case 0:
          return "left";
        case 1:
          return "middle";
        case 2:
          return "right";
        case 3:
          return "back";
        case 4:
          return "forward";
        default:
          return "none";
      }
    }
    function getTilt(action) {
      const altitudeAngle = action.altitudeAngle ?? Math.PI / 2;
      const azimuthAngle = action.azimuthAngle ?? 0;
      let tiltXRadians = 0;
      let tiltYRadians = 0;
      if (altitudeAngle === 0) {
        if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {
          tiltXRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI / 2) {
          tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI) {
          tiltXRadians = -Math.PI / 2;
        }
        if (azimuthAngle === 3 * Math.PI / 2) {
          tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {
          tiltXRadians = Math.PI / 2;
          tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {
          tiltXRadians = -Math.PI / 2;
          tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI && azimuthAngle < 3 * Math.PI / 2) {
          tiltXRadians = -Math.PI / 2;
          tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > 3 * Math.PI / 2 && azimuthAngle < 2 * Math.PI) {
          tiltXRadians = Math.PI / 2;
          tiltYRadians = -Math.PI / 2;
        }
      }
      if (altitudeAngle !== 0) {
        const tanAlt = Math.tan(altitudeAngle);
        tiltXRadians = Math.atan(Math.cos(azimuthAngle) / tanAlt);
        tiltYRadians = Math.atan(Math.sin(azimuthAngle) / tanAlt);
      }
      const factor = 180 / Math.PI;
      return {
        tiltX: Math.round(tiltXRadians * factor),
        tiltY: Math.round(tiltYRadians * factor)
      };
    }
    function getRadii(width, height) {
      return {
        radiusX: width ? width / 2 : 0.5,
        radiusY: height ? height / 2 : 0.5
      };
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/Mutex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mutex = void 0;
    var Mutex2 = class {
      #locked = false;
      #acquirers = [];
      // This is FIFO.
      acquire() {
        const state = { resolved: false };
        if (this.#locked) {
          return new Promise((resolve) => {
            this.#acquirers.push(() => resolve(this.#release.bind(this, state)));
          });
        }
        this.#locked = true;
        return Promise.resolve(this.#release.bind(this, state));
      }
      #release(state) {
        if (state.resolved) {
          throw new Error("Cannot release more than once.");
        }
        state.resolved = true;
        const resolve = this.#acquirers.shift();
        if (!resolve) {
          this.#locked = false;
          return;
        }
        resolve();
      }
      async run(action) {
        const release = await this.acquire();
        try {
          const result = await action();
          return result;
        } finally {
          release();
        }
      }
    };
    exports.Mutex = Mutex2;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js
var require_InputState = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputState = void 0;
    var protocol_js_1 = require_protocol();
    var Mutex_js_1 = require_Mutex();
    var InputSource_js_1 = require_InputSource();
    var InputState = class {
      cancelList = [];
      #sources = /* @__PURE__ */ new Map();
      #mutex = new Mutex_js_1.Mutex();
      getOrCreate(id, type, subtype) {
        let source2 = this.#sources.get(id);
        if (!source2) {
          switch (type) {
            case "none":
              source2 = new InputSource_js_1.NoneSource();
              break;
            case "key":
              source2 = new InputSource_js_1.KeySource();
              break;
            case "pointer": {
              let pointerId = subtype === "mouse" ? 0 : 2;
              const pointerIds = /* @__PURE__ */ new Set();
              for (const [, source3] of this.#sources) {
                if (source3.type === "pointer") {
                  pointerIds.add(source3.pointerId);
                }
              }
              while (pointerIds.has(pointerId)) {
                ++pointerId;
              }
              source2 = new InputSource_js_1.PointerSource(pointerId, subtype);
              break;
            }
            case "wheel":
              source2 = new InputSource_js_1.WheelSource();
              break;
            default:
              throw new protocol_js_1.InvalidArgumentException(`Expected "${"none"}", "${"key"}", "${"pointer"}", or "${"wheel"}". Found unknown source type ${type}.`);
          }
          this.#sources.set(id, source2);
          return source2;
        }
        if (source2.type !== type) {
          throw new protocol_js_1.InvalidArgumentException(`Input source type of ${id} is ${source2.type}, but received ${type}.`);
        }
        return source2;
      }
      get(id) {
        const source2 = this.#sources.get(id);
        if (!source2) {
          throw new protocol_js_1.UnknownErrorException(`Internal error.`);
        }
        return source2;
      }
      getGlobalKeyState() {
        const state = new InputSource_js_1.KeySource();
        for (const [, source2] of this.#sources) {
          if (source2.type !== "key") {
            continue;
          }
          for (const pressed of source2.pressed) {
            state.pressed.add(pressed);
          }
          state.alt ||= source2.alt;
          state.ctrl ||= source2.ctrl;
          state.meta ||= source2.meta;
          state.shift ||= source2.shift;
        }
        return state;
      }
      get queue() {
        return this.#mutex;
      }
    };
    exports.InputState = InputState;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js
var require_InputStateManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputStateManager = void 0;
    var assert_js_1 = require_assert();
    var InputState_js_1 = require_InputState();
    var InputStateManager = class extends WeakMap {
      get(context2) {
        (0, assert_js_1.assert)(context2.isTopLevelContext());
        if (!this.has(context2)) {
          this.set(context2, new InputState_js_1.InputState());
        }
        return super.get(context2);
      }
    };
    exports.InputStateManager = InputStateManager;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js
var require_InputProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var assert_js_1 = require_assert();
    var ActionDispatcher_js_1 = require_ActionDispatcher();
    var InputStateManager_js_1 = require_InputStateManager();
    var InputProcessor = class {
      #browsingContextStorage;
      #inputStateManager = new InputStateManager_js_1.InputStateManager();
      constructor(browsingContextStorage) {
        this.#browsingContextStorage = browsingContextStorage;
      }
      async performActions(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        const inputState = this.#inputStateManager.get(context2.top);
        const actionsByTick = this.#getActionsByTick(params, inputState);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, this.#browsingContextStorage, params.context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context2).catch(() => false));
        await dispatcher.dispatchActions(actionsByTick);
        return {};
      }
      async releaseActions(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        const topContext = context2.top;
        const inputState = this.#inputStateManager.get(topContext);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, this.#browsingContextStorage, params.context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context2).catch(() => false));
        await dispatcher.dispatchTickActions(inputState.cancelList.reverse());
        this.#inputStateManager.delete(topContext);
        return {};
      }
      async setFiles(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        const realm = await context2.getOrCreateSandbox(void 0);
        let result;
        try {
          result = await realm.callFunction(String(function getFiles(fileListLength) {
            if (!(this instanceof HTMLInputElement)) {
              if (this instanceof Element) {
                return 1;
              }
              return 0;
            }
            if (this.type !== "file") {
              return 2;
            }
            if (this.disabled) {
              return 3;
            }
            if (fileListLength > 1 && !this.multiple) {
              return 4;
            }
            return;
          }), false, params.element, [{ type: "number", value: params.files.length }]);
        } catch {
          throw new protocol_js_1.NoSuchNodeException(`Could not find element ${params.element.sharedId}`);
        }
        (0, assert_js_1.assert)(result.type === "success");
        if (result.result.type === "number") {
          switch (result.result.value) {
            case 0: {
              throw new protocol_js_1.NoSuchElementException(`Could not find element ${params.element.sharedId}`);
            }
            case 1: {
              throw new protocol_js_1.UnableToSetFileInputException(`Element ${params.element.sharedId} is not a input`);
            }
            case 2: {
              throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is not a file type`);
            }
            case 3: {
              throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is disabled`);
            }
            case 4: {
              throw new protocol_js_1.UnableToSetFileInputException(`Cannot set multiple files on a non-multiple input element`);
            }
          }
        }
        if (params.files.length === 0) {
          await realm.callFunction(String(function dispatchEvent() {
            if (this.files?.length === 0) {
              this.dispatchEvent(new Event("cancel", {
                bubbles: true
              }));
              return;
            }
            this.files = new DataTransfer().files;
            this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
            this.dispatchEvent(new Event("change", { bubbles: true }));
          }), false, params.element);
          return {};
        }
        const paths = [];
        for (let i = 0; i < params.files.length; ++i) {
          const result2 = await realm.callFunction(
            String(function getFiles(index) {
              return this.files?.item(index);
            }),
            false,
            params.element,
            [{ type: "number", value: 0 }],
            "root"
            /* Script.ResultOwnership.Root */
          );
          (0, assert_js_1.assert)(result2.type === "success");
          if (result2.result.type !== "object") {
            break;
          }
          const { handle } = result2.result;
          (0, assert_js_1.assert)(handle !== void 0);
          const { path } = await realm.cdpClient.sendCommand("DOM.getFileInfo", {
            objectId: handle
          });
          paths.push(path);
          void realm.disown(handle).catch(void 0);
        }
        paths.sort();
        const sortedFiles = [...params.files].sort();
        if (paths.length !== params.files.length || sortedFiles.some((path, index) => {
          return paths[index] !== path;
        })) {
          const { objectId } = await realm.deserializeForCdp(params.element);
          (0, assert_js_1.assert)(objectId !== void 0);
          await realm.cdpClient.sendCommand("DOM.setFileInputFiles", {
            files: params.files,
            objectId
          });
        } else {
          await realm.callFunction(String(function dispatchEvent() {
            this.dispatchEvent(new Event("cancel", {
              bubbles: true
            }));
          }), false, params.element);
        }
        return {};
      }
      #getActionsByTick(params, inputState) {
        const actionsByTick = [];
        for (const action of params.actions) {
          switch (action.type) {
            case "pointer": {
              action.parameters ??= {
                pointerType: "mouse"
                /* Input.PointerType.Mouse */
              };
              action.parameters.pointerType ??= "mouse";
              const source2 = inputState.getOrCreate(action.id, "pointer", action.parameters.pointerType);
              if (source2.subtype !== action.parameters.pointerType) {
                throw new protocol_js_1.InvalidArgumentException(`Expected input source ${action.id} to be ${source2.subtype}; got ${action.parameters.pointerType}.`);
              }
              source2.resetClickCount();
              break;
            }
            default:
              inputState.getOrCreate(action.id, action.type);
          }
          const actions = action.actions.map((item) => ({
            id: action.id,
            action: item
          }));
          for (let i = 0; i < actions.length; i++) {
            if (actionsByTick.length === i) {
              actionsByTick.push([]);
            }
            actionsByTick[i].push(actions[i]);
          }
        }
        return actionsByTick;
      }
    };
    exports.InputProcessor = InputProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/base64.js
var require_base64 = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base64ToString = base64ToString;
    function base64ToString(base64Str) {
      if ("atob" in globalThis) {
        return globalThis.atob(base64Str);
      }
      return Buffer.from(base64Str, "base64").toString("ascii");
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js
var require_NetworkUtils = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeHeadersSize = computeHeadersSize;
    exports.stringToBase64 = stringToBase642;
    exports.bidiNetworkHeadersFromCdpNetworkHeaders = bidiNetworkHeadersFromCdpNetworkHeaders;
    exports.bidiNetworkHeadersFromCdpNetworkHeadersEntries = bidiNetworkHeadersFromCdpNetworkHeadersEntries;
    exports.cdpNetworkHeadersFromBidiNetworkHeaders = cdpNetworkHeadersFromBidiNetworkHeaders;
    exports.bidiNetworkHeadersFromCdpFetchHeaders = bidiNetworkHeadersFromCdpFetchHeaders;
    exports.cdpFetchHeadersFromBidiNetworkHeaders = cdpFetchHeadersFromBidiNetworkHeaders;
    exports.networkHeaderFromCookieHeaders = networkHeaderFromCookieHeaders;
    exports.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction = cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction;
    exports.cdpToBiDiCookie = cdpToBiDiCookie;
    exports.deserializeByteValue = deserializeByteValue;
    exports.bidiToCdpCookie = bidiToCdpCookie;
    exports.sameSiteBiDiToCdp = sameSiteBiDiToCdp;
    exports.isSpecialScheme = isSpecialScheme;
    exports.matchUrlPattern = matchUrlPattern;
    exports.bidiBodySizeFromCdpPostDataEntries = bidiBodySizeFromCdpPostDataEntries;
    exports.getTiming = getTiming;
    var ErrorResponse_js_1 = require_ErrorResponse();
    var base64_js_1 = require_base64();
    function computeHeadersSize(headers) {
      const requestHeaders = headers.reduce((acc, header) => {
        return `${acc}${header.name}: ${header.value.value}\r
`;
      }, "");
      return new TextEncoder().encode(requestHeaders).length;
    }
    function stringToBase642(str) {
      return typedArrayToBase642(new TextEncoder().encode(str));
    }
    function typedArrayToBase642(typedArray) {
      const chunkSize = 65534;
      const chunks = [];
      for (let i = 0; i < typedArray.length; i += chunkSize) {
        const chunk = typedArray.subarray(i, i + chunkSize);
        chunks.push(String.fromCodePoint.apply(null, chunk));
      }
      const binaryString = chunks.join("");
      return btoa(binaryString);
    }
    function bidiNetworkHeadersFromCdpNetworkHeaders(headers) {
      if (!headers) {
        return [];
      }
      return Object.entries(headers).map(([name, value]) => ({
        name,
        value: {
          type: "string",
          value
        }
      }));
    }
    function bidiNetworkHeadersFromCdpNetworkHeadersEntries(headers) {
      if (!headers) {
        return [];
      }
      return headers.map(({ name, value }) => ({
        name,
        value: {
          type: "string",
          value
        }
      }));
    }
    function cdpNetworkHeadersFromBidiNetworkHeaders(headers) {
      if (headers === void 0) {
        return void 0;
      }
      return headers.reduce((result, header) => {
        result[header.name] = header.value.value;
        return result;
      }, {});
    }
    function bidiNetworkHeadersFromCdpFetchHeaders(headers) {
      if (!headers) {
        return [];
      }
      return headers.map(({ name, value }) => ({
        name,
        value: {
          type: "string",
          value
        }
      }));
    }
    function cdpFetchHeadersFromBidiNetworkHeaders(headers) {
      if (headers === void 0) {
        return void 0;
      }
      return headers.map(({ name, value }) => ({
        name,
        value: value.value
      }));
    }
    function networkHeaderFromCookieHeaders(headers) {
      if (headers === void 0) {
        return void 0;
      }
      const value = headers.reduce((acc, value2, index) => {
        if (index > 0) {
          acc += ";";
        }
        const cookieValue = value2.value.type === "base64" ? btoa(value2.value.value) : value2.value.value;
        acc += `${value2.name}=${cookieValue}`;
        return acc;
      }, "");
      return {
        name: "Cookie",
        value: {
          type: "string",
          value
        }
      };
    }
    function cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction(action) {
      switch (action) {
        case "default":
          return "Default";
        case "cancel":
          return "CancelAuth";
        case "provideCredentials":
          return "ProvideCredentials";
      }
    }
    function cdpToBiDiCookie(cookie) {
      const result = {
        name: cookie.name,
        value: { type: "string", value: cookie.value },
        domain: cookie.domain,
        path: cookie.path,
        size: cookie.size,
        httpOnly: cookie.httpOnly,
        secure: cookie.secure,
        sameSite: cookie.sameSite === void 0 ? "none" : sameSiteCdpToBiDi(cookie.sameSite),
        ...cookie.expires >= 0 ? { expiry: cookie.expires } : void 0
      };
      result[`goog:session`] = cookie.session;
      result[`goog:priority`] = cookie.priority;
      result[`goog:sameParty`] = cookie.sameParty;
      result[`goog:sourceScheme`] = cookie.sourceScheme;
      result[`goog:sourcePort`] = cookie.sourcePort;
      if (cookie.partitionKey !== void 0) {
        result[`goog:partitionKey`] = cookie.partitionKey;
      }
      if (cookie.partitionKeyOpaque !== void 0) {
        result[`goog:partitionKeyOpaque`] = cookie.partitionKeyOpaque;
      }
      return result;
    }
    function deserializeByteValue(value) {
      if (value.type === "base64") {
        return (0, base64_js_1.base64ToString)(value.value);
      }
      return value.value;
    }
    function bidiToCdpCookie(params, partitionKey) {
      const deserializedValue = deserializeByteValue(params.cookie.value);
      const result = {
        name: params.cookie.name,
        value: deserializedValue,
        domain: params.cookie.domain,
        path: params.cookie.path ?? "/",
        secure: params.cookie.secure ?? false,
        httpOnly: params.cookie.httpOnly ?? false,
        ...partitionKey.sourceOrigin !== void 0 && {
          partitionKey: {
            hasCrossSiteAncestor: false,
            // CDP's `partitionKey.topLevelSite` is the BiDi's `partition.sourceOrigin`.
            topLevelSite: partitionKey.sourceOrigin
          }
        },
        ...params.cookie.expiry !== void 0 && {
          expires: params.cookie.expiry
        },
        ...params.cookie.sameSite !== void 0 && {
          sameSite: sameSiteBiDiToCdp(params.cookie.sameSite)
        }
      };
      if (params.cookie[`goog:url`] !== void 0) {
        result.url = params.cookie[`goog:url`];
      }
      if (params.cookie[`goog:priority`] !== void 0) {
        result.priority = params.cookie[`goog:priority`];
      }
      if (params.cookie[`goog:sameParty`] !== void 0) {
        result.sameParty = params.cookie[`goog:sameParty`];
      }
      if (params.cookie[`goog:sourceScheme`] !== void 0) {
        result.sourceScheme = params.cookie[`goog:sourceScheme`];
      }
      if (params.cookie[`goog:sourcePort`] !== void 0) {
        result.sourcePort = params.cookie[`goog:sourcePort`];
      }
      return result;
    }
    function sameSiteCdpToBiDi(sameSite) {
      switch (sameSite) {
        case "Strict":
          return "strict";
        case "None":
          return "none";
        case "Lax":
          return "lax";
        default:
          return "lax";
      }
    }
    function sameSiteBiDiToCdp(sameSite) {
      switch (sameSite) {
        case "strict":
          return "Strict";
        case "lax":
          return "Lax";
        case "none":
          return "None";
      }
      throw new ErrorResponse_js_1.InvalidArgumentException(`Unknown 'sameSite' value ${sameSite}`);
    }
    function isSpecialScheme(protocol) {
      return ["ftp", "file", "http", "https", "ws", "wss"].includes(protocol.replace(/:$/, ""));
    }
    function getScheme(url) {
      return url.protocol.replace(/:$/, "");
    }
    function matchUrlPattern(pattern, url) {
      const parsedUrl = new URL(url);
      if (pattern.protocol !== void 0 && pattern.protocol !== getScheme(parsedUrl)) {
        return false;
      }
      if (pattern.hostname !== void 0 && pattern.hostname !== parsedUrl.hostname) {
        return false;
      }
      if (pattern.port !== void 0 && pattern.port !== parsedUrl.port) {
        return false;
      }
      if (pattern.pathname !== void 0 && pattern.pathname !== parsedUrl.pathname) {
        return false;
      }
      if (pattern.search !== void 0 && pattern.search !== parsedUrl.search) {
        return false;
      }
      return true;
    }
    function bidiBodySizeFromCdpPostDataEntries(entries) {
      let size = 0;
      for (const entry of entries) {
        size += atob(entry.bytes ?? "").length;
      }
      return size;
    }
    function getTiming(timing, offset = 0) {
      if (!timing) {
        return 0;
      }
      if (timing <= 0 || timing + offset <= 0) {
        return 0;
      }
      return timing + offset;
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js
var require_NetworkProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var NetworkUtils_js_1 = require_NetworkUtils();
    var NetworkProcessor = class {
      #browsingContextStorage;
      #networkStorage;
      constructor(browsingContextStorage, networkStorage) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#networkStorage = networkStorage;
      }
      async addIntercept(params) {
        this.#browsingContextStorage.verifyTopLevelContextsList(params.contexts);
        const urlPatterns = params.urlPatterns ?? [];
        const parsedUrlPatterns = NetworkProcessor.parseUrlPatterns(urlPatterns);
        const intercept = this.#networkStorage.addIntercept({
          urlPatterns: parsedUrlPatterns,
          phases: params.phases,
          contexts: params.contexts
        });
        await Promise.all(this.#browsingContextStorage.getAllContexts().map((context2) => {
          return context2.cdpTarget.toggleNetwork();
        }));
        return {
          intercept
        };
      }
      async continueRequest(params) {
        if (params.url !== void 0) {
          NetworkProcessor.parseUrlString(params.url);
        }
        if (params.method !== void 0) {
          if (!NetworkProcessor.isMethodValid(params.method)) {
            throw new protocol_js_1.InvalidArgumentException(`Method '${params.method}' is invalid.`);
          }
        }
        if (params.headers) {
          NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
          "beforeRequestSent"
        ]);
        try {
          await request.continueRequest(params);
        } catch (error) {
          throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
      }
      async continueResponse(params) {
        if (params.headers) {
          NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
          "authRequired",
          "responseStarted"
        ]);
        try {
          await request.continueResponse(params);
        } catch (error) {
          throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
      }
      async continueWithAuth(params) {
        const networkId = params.request;
        const request = this.#getBlockedRequestOrFail(networkId, [
          "authRequired"
        ]);
        await request.continueWithAuth(params);
        return {};
      }
      async failRequest({ request: networkId }) {
        const request = this.#getRequestOrFail(networkId);
        if (request.interceptPhase === "authRequired") {
          throw new protocol_js_1.InvalidArgumentException(`Request '${networkId}' in 'authRequired' phase cannot be failed`);
        }
        if (!request.interceptPhase) {
          throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${networkId}'`);
        }
        await request.failRequest("Failed");
        return {};
      }
      async provideResponse(params) {
        if (params.headers) {
          NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
          "beforeRequestSent",
          "responseStarted",
          "authRequired"
        ]);
        try {
          await request.provideResponse(params);
        } catch (error) {
          throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
      }
      async removeIntercept(params) {
        this.#networkStorage.removeIntercept(params.intercept);
        await Promise.all(this.#browsingContextStorage.getAllContexts().map((context2) => {
          return context2.cdpTarget.toggleNetwork();
        }));
        return {};
      }
      async setCacheBehavior(params) {
        const contexts = this.#browsingContextStorage.verifyTopLevelContextsList(params.contexts);
        if (contexts.size === 0) {
          this.#networkStorage.defaultCacheBehavior = params.cacheBehavior;
          await Promise.all(this.#browsingContextStorage.getAllContexts().map((context2) => {
            return context2.cdpTarget.toggleSetCacheDisabled();
          }));
          return {};
        }
        const cacheDisabled = params.cacheBehavior === "bypass";
        await Promise.all([...contexts.values()].map((context2) => {
          return context2.cdpTarget.toggleSetCacheDisabled(cacheDisabled);
        }));
        return {};
      }
      #getRequestOrFail(id) {
        const request = this.#networkStorage.getRequestById(id);
        if (!request) {
          throw new protocol_js_1.NoSuchRequestException(`Network request with ID '${id}' doesn't exist`);
        }
        return request;
      }
      #getBlockedRequestOrFail(id, phases) {
        const request = this.#getRequestOrFail(id);
        if (!request.interceptPhase) {
          throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${id}'`);
        }
        if (request.interceptPhase && !phases.includes(request.interceptPhase)) {
          throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${id}' is in '${request.interceptPhase}' phase`);
        }
        return request;
      }
      /**
       * Validate https://fetch.spec.whatwg.org/#header-value
       */
      static validateHeaders(headers) {
        for (const header of headers) {
          let headerValue;
          if (header.value.type === "string") {
            headerValue = header.value.value;
          } else {
            headerValue = atob(header.value.value);
          }
          if (headerValue !== headerValue.trim() || headerValue.includes("\n") || headerValue.includes("\0")) {
            throw new protocol_js_1.InvalidArgumentException(`Header value '${headerValue}' is not acceptable value`);
          }
        }
      }
      static isMethodValid(method) {
        return /^[!#$%&'*+\-.^_`|~a-zA-Z\d]+$/.test(method);
      }
      /**
       * Attempts to parse the given url.
       * Throws an InvalidArgumentException if the url is invalid.
       */
      static parseUrlString(url) {
        try {
          return new URL(url);
        } catch (error) {
          throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${url}': ${error}`);
        }
      }
      static parseUrlPatterns(urlPatterns) {
        return urlPatterns.map((urlPattern) => {
          let patternUrl = "";
          let hasProtocol = true;
          let hasHostname = true;
          let hasPort = true;
          let hasPathname = true;
          let hasSearch = true;
          switch (urlPattern.type) {
            case "string": {
              patternUrl = unescapeURLPattern(urlPattern.pattern);
              break;
            }
            case "pattern": {
              if (urlPattern.protocol === void 0) {
                hasProtocol = false;
                patternUrl += "http";
              } else {
                if (urlPattern.protocol === "") {
                  throw new protocol_js_1.InvalidArgumentException("URL pattern must specify a protocol");
                }
                urlPattern.protocol = unescapeURLPattern(urlPattern.protocol);
                if (!urlPattern.protocol.match(/^[a-zA-Z+-.]+$/)) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.protocol;
              }
              const scheme = patternUrl.toLocaleLowerCase();
              patternUrl += ":";
              if ((0, NetworkUtils_js_1.isSpecialScheme)(scheme)) {
                patternUrl += "//";
              }
              if (urlPattern.hostname === void 0) {
                if (scheme !== "file") {
                  patternUrl += "placeholder";
                }
                hasHostname = false;
              } else {
                if (urlPattern.hostname === "") {
                  throw new protocol_js_1.InvalidArgumentException("URL pattern must specify a hostname");
                }
                if (urlPattern.protocol === "file") {
                  throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                }
                urlPattern.hostname = unescapeURLPattern(urlPattern.hostname);
                let insideBrackets = false;
                for (const c of urlPattern.hostname) {
                  if (c === "/" || c === "?" || c === "#") {
                    throw new protocol_js_1.InvalidArgumentException(`'/', '?', '#' are forbidden in hostname`);
                  }
                  if (!insideBrackets && c === ":") {
                    throw new protocol_js_1.InvalidArgumentException(`':' is only allowed inside brackets in hostname`);
                  }
                  if (c === "[") {
                    insideBrackets = true;
                  }
                  if (c === "]") {
                    insideBrackets = false;
                  }
                }
                patternUrl += urlPattern.hostname;
              }
              if (urlPattern.port === void 0) {
                hasPort = false;
              } else {
                if (urlPattern.port === "") {
                  throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                }
                urlPattern.port = unescapeURLPattern(urlPattern.port);
                patternUrl += ":";
                if (!urlPattern.port.match(/^\d+$/)) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.port;
              }
              if (urlPattern.pathname === void 0) {
                hasPathname = false;
              } else {
                urlPattern.pathname = unescapeURLPattern(urlPattern.pathname);
                if (urlPattern.pathname[0] !== "/") {
                  patternUrl += "/";
                }
                if (urlPattern.pathname.includes("#") || urlPattern.pathname.includes("?")) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.pathname;
              }
              if (urlPattern.search === void 0) {
                hasSearch = false;
              } else {
                urlPattern.search = unescapeURLPattern(urlPattern.search);
                if (urlPattern.search[0] !== "?") {
                  patternUrl += "?";
                }
                if (urlPattern.search.includes("#")) {
                  throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
                }
                patternUrl += urlPattern.search;
              }
              break;
            }
          }
          const serializePort = (url) => {
            const defaultPorts = {
              "ftp:": 21,
              "file:": null,
              "http:": 80,
              "https:": 443,
              "ws:": 80,
              "wss:": 443
            };
            if ((0, NetworkUtils_js_1.isSpecialScheme)(url.protocol) && defaultPorts[url.protocol] !== null && (!url.port || String(defaultPorts[url.protocol]) === url.port)) {
              return "";
            } else if (url.port) {
              return url.port;
            }
            return void 0;
          };
          try {
            const url = new URL(patternUrl);
            return {
              protocol: hasProtocol ? url.protocol.replace(/:$/, "") : void 0,
              hostname: hasHostname ? url.hostname : void 0,
              port: hasPort ? serializePort(url) : void 0,
              pathname: hasPathname && url.pathname ? url.pathname : void 0,
              search: hasSearch ? url.search : void 0
            };
          } catch (err) {
            throw new protocol_js_1.InvalidArgumentException(`${err.message} '${patternUrl}'`);
          }
        });
      }
      static wrapInterceptionError(error) {
        if (error?.message.includes("Invalid header") || error?.message.includes("Unsafe header")) {
          return new protocol_js_1.InvalidArgumentException(error.message);
        }
        return error;
      }
    };
    exports.NetworkProcessor = NetworkProcessor;
    function unescapeURLPattern(pattern) {
      const forbidden = /* @__PURE__ */ new Set(["(", ")", "*", "{", "}"]);
      let result = "";
      let isEscaped = false;
      for (const c of pattern) {
        if (!isEscaped) {
          if (forbidden.has(c)) {
            throw new protocol_js_1.InvalidArgumentException("Forbidden characters");
          }
          if (c === "\\") {
            isEscaped = true;
            continue;
          }
        }
        result += c;
        isEscaped = false;
      }
      return result;
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js
var require_PermissionsProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PermissionsProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var PermissionsProcessor = class {
      #browserCdpClient;
      constructor(browserCdpClient) {
        this.#browserCdpClient = browserCdpClient;
      }
      async setPermissions(params) {
        try {
          const userContextId = params["goog:userContext"] || params.userContext;
          await this.#browserCdpClient.sendCommand("Browser.setPermission", {
            origin: params.origin,
            browserContextId: userContextId && userContextId !== "default" ? userContextId : void 0,
            permission: {
              name: params.descriptor.name
            },
            setting: params.state
          });
        } catch (err) {
          if (err.message === `Permission can't be granted to opaque origins.`) {
            return {};
          }
          throw new protocol_js_1.InvalidArgumentException(err.message);
        }
        return {};
      }
    };
    exports.PermissionsProcessor = PermissionsProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uuidv4 = uuidv4;
    function bytesToHex(bytes) {
      return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    }
    function uuidv4() {
      if ("crypto" in globalThis && "randomUUID" in globalThis.crypto) {
        return globalThis.crypto.randomUUID();
      }
      const randomValues = new Uint8Array(16);
      if ("crypto" in globalThis && "getRandomValues" in globalThis.crypto) {
        globalThis.crypto.getRandomValues(randomValues);
      } else {
        __require("crypto").webcrypto.getRandomValues(randomValues);
      }
      randomValues[6] = randomValues[6] & 15 | 64;
      randomValues[8] = randomValues[8] & 63 | 128;
      return [
        bytesToHex(randomValues.subarray(0, 4)),
        bytesToHex(randomValues.subarray(4, 6)),
        bytesToHex(randomValues.subarray(6, 8)),
        bytesToHex(randomValues.subarray(8, 10)),
        bytesToHex(randomValues.subarray(10, 16))
      ].join("-");
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js
var require_ChannelProxy = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChannelProxy = void 0;
    var protocol_js_1 = require_protocol();
    var log_js_1 = require_log();
    var uuid_js_1 = require_uuid();
    var _properties, _id, _logger, _createChannelProxyEvalStr, createChannelProxyEvalStr_fn, _createAndGetHandleInRealm, createAndGetHandleInRealm_fn, _createSendMessageHandle, createSendMessageHandle_fn, _startListener, startListener_fn, _getHandleFromWindow, getHandleFromWindow_fn;
    var _ChannelProxy = class {
      constructor(channel, logger) {
        /** Starts listening for the channel events of the provided ChannelProxy. */
        __privateAdd(this, _startListener);
        /**
         * Returns a handle of ChannelProxy from window's property which was set there
         * by `getEvalInWindowStr`. If window property is not set yet, sets a promise
         * resolver to the window property, so that `getEvalInWindowStr` can resolve
         * the promise later on with the channel.
         * This is needed because `getEvalInWindowStr` can be called before or
         * after this method.
         */
        __privateAdd(this, _getHandleFromWindow);
        __privateAdd(this, _properties, void 0);
        __privateAdd(this, _id, (0, uuid_js_1.uuidv4)());
        __privateAdd(this, _logger, void 0);
        __privateSet(this, _properties, channel);
        __privateSet(this, _logger, logger);
      }
      /**
       * Creates a channel proxy in the given realm, initialises listener and
       * returns a handle to `sendMessage` delegate.
       */
      async init(realm, eventManager) {
        var _a3, _b;
        const channelHandle = await __privateMethod(_a3 = _ChannelProxy, _createAndGetHandleInRealm, createAndGetHandleInRealm_fn).call(_a3, realm);
        const sendMessageHandle = await __privateMethod(_b = _ChannelProxy, _createSendMessageHandle, createSendMessageHandle_fn).call(_b, realm, channelHandle);
        void __privateMethod(this, _startListener, startListener_fn).call(this, realm, channelHandle, eventManager);
        return sendMessageHandle;
      }
      /** Gets a ChannelProxy from window and returns its handle. */
      async startListenerFromWindow(realm, eventManager) {
        var _a3;
        try {
          const channelHandle = await __privateMethod(this, _getHandleFromWindow, getHandleFromWindow_fn).call(this, realm);
          void __privateMethod(this, _startListener, startListener_fn).call(this, realm, channelHandle, eventManager);
        } catch (error) {
          (_a3 = __privateGet(this, _logger)) == null ? void 0 : _a3.call(this, log_js_1.LogType.debugError, error);
        }
      }
      /**
       * String to be evaluated to create a ProxyChannel and put it to window.
       * Returns the delegate `sendMessage`. Used to provide an argument for preload
       * script. Does the following:
       * 1. Creates a ChannelProxy.
       * 2. Puts the ChannelProxy to window['${this.#id}'] or resolves the promise
       *    by calling delegate stored in window['${this.#id}'].
       *    This is needed because `#getHandleFromWindow` can be called before or
       *    after this method.
       * 3. Returns the delegate `sendMessage` of the created ChannelProxy.
       */
      getEvalInWindowStr() {
        var _a3;
        const delegate = String((id, channelProxy) => {
          const w = window;
          if (w[id] === void 0) {
            w[id] = channelProxy;
          } else {
            w[id](channelProxy);
            delete w[id];
          }
          return channelProxy.sendMessage;
        });
        const channelProxyEval = __privateMethod(_a3 = _ChannelProxy, _createChannelProxyEvalStr, createChannelProxyEvalStr_fn).call(_a3);
        return `(${delegate})('${__privateGet(this, _id)}',${channelProxyEval})`;
      }
    };
    var ChannelProxy = _ChannelProxy;
    _properties = new WeakMap();
    _id = new WeakMap();
    _logger = new WeakMap();
    _createChannelProxyEvalStr = new WeakSet();
    createChannelProxyEvalStr_fn = function() {
      const functionStr = String(() => {
        const queue = [];
        let queueNonEmptyResolver = null;
        return {
          /**
           * Gets a promise, which is resolved as soon as a message occurs
           * in the queue.
           */
          async getMessage() {
            const onMessage = queue.length > 0 ? Promise.resolve() : new Promise((resolve) => {
              queueNonEmptyResolver = resolve;
            });
            await onMessage;
            return queue.shift();
          },
          /**
           * Adds a message to the queue.
           * Resolves the pending promise if needed.
           */
          sendMessage(message) {
            queue.push(message);
            if (queueNonEmptyResolver !== null) {
              queueNonEmptyResolver();
              queueNonEmptyResolver = null;
            }
          }
        };
      });
      return `(${functionStr})()`;
    };
    _createAndGetHandleInRealm = new WeakSet();
    createAndGetHandleInRealm_fn = async function(realm) {
      const createChannelHandleResult = await realm.cdpClient.sendCommand("Runtime.evaluate", {
        expression: __privateMethod(this, _createChannelProxyEvalStr, createChannelProxyEvalStr_fn).call(this),
        contextId: realm.executionContextId,
        serializationOptions: {
          serialization: "idOnly"
        }
      });
      if (createChannelHandleResult.exceptionDetails || createChannelHandleResult.result.objectId === void 0) {
        throw new Error(`Cannot create channel`);
      }
      return createChannelHandleResult.result.objectId;
    };
    _createSendMessageHandle = new WeakSet();
    createSendMessageHandle_fn = async function(realm, channelHandle) {
      const sendMessageArgResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
        functionDeclaration: String((channelHandle2) => {
          return channelHandle2.sendMessage;
        }),
        arguments: [{ objectId: channelHandle }],
        executionContextId: realm.executionContextId,
        serializationOptions: {
          serialization: "idOnly"
        }
      });
      return sendMessageArgResult.result.objectId;
    };
    _startListener = new WeakSet();
    startListener_fn = async function(realm, channelHandle, eventManager) {
      var _a3;
      for (; ; ) {
        try {
          const message = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String(async (channelHandle2) => await channelHandle2.getMessage()),
            arguments: [
              {
                objectId: channelHandle
              }
            ],
            awaitPromise: true,
            executionContextId: realm.executionContextId,
            serializationOptions: {
              serialization: "deep",
              maxDepth: __privateGet(this, _properties).serializationOptions?.maxObjectDepth ?? void 0
            }
          });
          if (message.exceptionDetails) {
            throw new Error("Runtime.callFunctionOn in ChannelProxy", {
              cause: message.exceptionDetails
            });
          }
          for (const browsingContext of realm.associatedBrowsingContexts) {
            eventManager.registerEvent({
              type: "event",
              method: protocol_js_1.ChromiumBidi.Script.EventNames.Message,
              params: {
                channel: __privateGet(this, _properties).channel,
                data: realm.cdpToBidiValue(
                  message,
                  __privateGet(this, _properties).ownership ?? "none"
                  /* Script.ResultOwnership.None */
                ),
                source: realm.source
              }
            }, browsingContext.id);
          }
        } catch (error) {
          (_a3 = __privateGet(this, _logger)) == null ? void 0 : _a3.call(this, log_js_1.LogType.debugError, error);
          break;
        }
      }
    };
    _getHandleFromWindow = new WeakSet();
    getHandleFromWindow_fn = async function(realm) {
      const channelHandleResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
        functionDeclaration: String((id) => {
          const w = window;
          if (w[id] === void 0) {
            return new Promise((resolve) => w[id] = resolve);
          }
          const channelProxy = w[id];
          delete w[id];
          return channelProxy;
        }),
        arguments: [{ value: __privateGet(this, _id) }],
        executionContextId: realm.executionContextId,
        awaitPromise: true,
        serializationOptions: {
          serialization: "idOnly"
        }
      });
      if (channelHandleResult.exceptionDetails !== void 0 || channelHandleResult.result.objectId === void 0) {
        throw new Error(`ChannelHandle not found in window["${__privateGet(this, _id)}"]`);
      }
      return channelHandleResult.result.objectId;
    };
    /**
     * Evaluation string which creates a ChannelProxy object on the client side.
     */
    __privateAdd(ChannelProxy, _createChannelProxyEvalStr);
    /** Creates a ChannelProxy in the given realm. */
    __privateAdd(ChannelProxy, _createAndGetHandleInRealm);
    /** Gets a handle to `sendMessage` delegate from the ChannelProxy handle. */
    __privateAdd(ChannelProxy, _createSendMessageHandle);
    exports.ChannelProxy = ChannelProxy;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js
var require_PreloadScript = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PreloadScript = void 0;
    var uuid_js_1 = require_uuid();
    var ChannelProxy_js_1 = require_ChannelProxy();
    var PreloadScript = class {
      /** BiDi ID, an automatically generated UUID. */
      #id = (0, uuid_js_1.uuidv4)();
      /** CDP preload scripts. */
      #cdpPreloadScripts = [];
      /** The script itself, in a format expected by the spec i.e. a function. */
      #functionDeclaration;
      /** Targets, in which the preload script is initialized. */
      #targetIds = /* @__PURE__ */ new Set();
      /** Channels to be added as arguments to functionDeclaration. */
      #channels;
      /** The script sandbox / world name. */
      #sandbox;
      /** The browsing contexts to execute the preload scripts in, if any. */
      #contexts;
      /** The browsing contexts to execute the preload scripts in, if any. */
      #userContexts;
      get id() {
        return this.#id;
      }
      get targetIds() {
        return this.#targetIds;
      }
      constructor(params, logger) {
        this.#channels = params.arguments?.map((a) => new ChannelProxy_js_1.ChannelProxy(a.value, logger)) ?? [];
        this.#functionDeclaration = params.functionDeclaration;
        this.#sandbox = params.sandbox;
        this.#contexts = params.contexts;
        this.#userContexts = params.userContexts;
      }
      /** Channels of the preload script. */
      get channels() {
        return this.#channels;
      }
      /** Contexts of the preload script, if any */
      get contexts() {
        return this.#contexts;
      }
      /** UserContexts of the preload script, if any */
      get userContexts() {
        return this.#userContexts;
      }
      /**
       * String to be evaluated. Wraps user-provided function so that the following
       * steps are run:
       * 1. Create channels.
       * 2. Store the created channels in window.
       * 3. Call the user-provided function with channels as arguments.
       */
      #getEvaluateString() {
        const channelsArgStr = `[${this.channels.map((c) => c.getEvalInWindowStr()).join(", ")}]`;
        return `(()=>{(${this.#functionDeclaration})(...${channelsArgStr})})()`;
      }
      /**
       * Adds the script to the given CDP targets by calling the
       * `Page.addScriptToEvaluateOnNewDocument` command.
       */
      async initInTargets(cdpTargets, runImmediately) {
        await Promise.all(Array.from(cdpTargets).map((cdpTarget) => this.initInTarget(cdpTarget, runImmediately)));
      }
      /**
       * Adds the script to the given CDP target by calling the
       * `Page.addScriptToEvaluateOnNewDocument` command.
       */
      async initInTarget(cdpTarget, runImmediately) {
        const addCdpPreloadScriptResult = await cdpTarget.cdpClient.sendCommand("Page.addScriptToEvaluateOnNewDocument", {
          source: this.#getEvaluateString(),
          worldName: this.#sandbox,
          runImmediately
        });
        this.#cdpPreloadScripts.push({
          target: cdpTarget,
          preloadScriptId: addCdpPreloadScriptResult.identifier
        });
        this.#targetIds.add(cdpTarget.id);
      }
      /**
       * Removes this script from all CDP targets.
       */
      async remove() {
        await Promise.all([
          this.#cdpPreloadScripts.map(async (cdpPreloadScript) => {
            const cdpTarget = cdpPreloadScript.target;
            const cdpPreloadScriptId = cdpPreloadScript.preloadScriptId;
            return await cdpTarget.cdpClient.sendCommand("Page.removeScriptToEvaluateOnNewDocument", {
              identifier: cdpPreloadScriptId
            });
          })
        ]);
      }
      /** Removes the provided cdp target from the list of cdp preload scripts. */
      dispose(cdpTargetId) {
        this.#cdpPreloadScripts = this.#cdpPreloadScripts.filter((cdpPreloadScript) => cdpPreloadScript.target?.id !== cdpTargetId);
        this.#targetIds.delete(cdpTargetId);
      }
    };
    exports.PreloadScript = PreloadScript;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js
var require_ScriptProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScriptProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var PreloadScript_js_1 = require_PreloadScript();
    var ScriptProcessor = class {
      #eventManager;
      #browsingContextStorage;
      #realmStorage;
      #preloadScriptStorage;
      #userContextStorage;
      #logger;
      constructor(eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, userContextStorage, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#userContextStorage = userContextStorage;
        this.#logger = logger;
        this.#eventManager = eventManager;
        this.#eventManager.addSubscribeHook(protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated, this.#onRealmCreatedSubscribeHook.bind(this));
      }
      #onRealmCreatedSubscribeHook(contextId) {
        const context2 = this.#browsingContextStorage.getContext(contextId);
        const contextsToReport = [
          context2,
          ...this.#browsingContextStorage.getContext(contextId).allChildren
        ];
        const realms = /* @__PURE__ */ new Set();
        for (const reportContext of contextsToReport) {
          const realmsForContext = this.#realmStorage.findRealms({
            browsingContextId: reportContext.id
          });
          for (const realm of realmsForContext) {
            realms.add(realm);
          }
        }
        for (const realm of realms) {
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
            params: realm.realmInfo
          }, context2.id);
        }
        return Promise.resolve();
      }
      async addPreloadScript(params) {
        if (params.userContexts?.length && params.contexts?.length) {
          throw new protocol_js_1.InvalidArgumentException("Both userContexts and contexts cannot be specified.");
        }
        const userContexts = await this.#userContextStorage.verifyUserContextIdList(params.userContexts ?? []);
        const browsingContexts = this.#browsingContextStorage.verifyTopLevelContextsList(params.contexts);
        const preloadScript = new PreloadScript_js_1.PreloadScript(params, this.#logger);
        this.#preloadScriptStorage.add(preloadScript);
        let contextsToRunIn = [];
        if (userContexts.size) {
          contextsToRunIn = this.#browsingContextStorage.getTopLevelContexts().filter((context2) => {
            return userContexts.has(context2.userContext);
          });
        } else if (browsingContexts.size) {
          contextsToRunIn = [...browsingContexts.values()];
        } else {
          contextsToRunIn = this.#browsingContextStorage.getTopLevelContexts();
        }
        const cdpTargets = new Set(contextsToRunIn.map((context2) => context2.cdpTarget));
        await preloadScript.initInTargets(cdpTargets, false);
        return {
          script: preloadScript.id
        };
      }
      async removePreloadScript(params) {
        const { script: id } = params;
        const script = this.#preloadScriptStorage.getPreloadScript(id);
        await script.remove();
        this.#preloadScriptStorage.remove(id);
        return {};
      }
      async callFunction(params) {
        const realm = await this.#getRealm(params.target);
        return await realm.callFunction(params.functionDeclaration, params.awaitPromise, params.this, params.arguments, params.resultOwnership, params.serializationOptions, params.userActivation);
      }
      async evaluate(params) {
        const realm = await this.#getRealm(params.target);
        return await realm.evaluate(params.expression, params.awaitPromise, params.resultOwnership, params.serializationOptions, params.userActivation);
      }
      async disown(params) {
        const realm = await this.#getRealm(params.target);
        await Promise.all(params.handles.map(async (handle) => await realm.disown(handle)));
        return {};
      }
      getRealms(params) {
        if (params.context !== void 0) {
          this.#browsingContextStorage.getContext(params.context);
        }
        const realms = this.#realmStorage.findRealms({
          browsingContextId: params.context,
          type: params.type
        }).map((realm) => realm.realmInfo);
        return { realms };
      }
      async #getRealm(target) {
        if ("context" in target) {
          const context2 = this.#browsingContextStorage.getContext(target.context);
          return await context2.getOrCreateSandbox(target.sandbox);
        }
        return this.#realmStorage.getRealm({
          realmId: target.realm
        });
      }
    };
    exports.ScriptProcessor = ScriptProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js
var require_SessionProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SessionProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var SessionProcessor = class {
      #eventManager;
      #browserCdpClient;
      #initConnection;
      #created = false;
      constructor(eventManager, browserCdpClient, initConnection) {
        this.#eventManager = eventManager;
        this.#browserCdpClient = browserCdpClient;
        this.#initConnection = initConnection;
      }
      status() {
        return { ready: false, message: "already connected" };
      }
      #mergeCapabilities(capabilitiesRequest) {
        const mergedCapabilities = [];
        for (const first2 of capabilitiesRequest.firstMatch ?? [{}]) {
          const result = {
            ...capabilitiesRequest.alwaysMatch
          };
          for (const key of Object.keys(first2)) {
            if (result[key] !== void 0) {
              throw new protocol_js_1.InvalidArgumentException(`Capability ${key} in firstMatch is already defined in alwaysMatch`);
            }
            result[key] = first2[key];
          }
          mergedCapabilities.push(result);
        }
        const match = mergedCapabilities.find((c) => c.browserName === "chrome") ?? mergedCapabilities[0] ?? {};
        match.unhandledPromptBehavior = this.#getUnhandledPromptBehavior(match.unhandledPromptBehavior);
        return match;
      }
      #getUnhandledPromptBehavior(capabilityValue) {
        if (capabilityValue === void 0) {
          return void 0;
        }
        if (typeof capabilityValue === "object") {
          return capabilityValue;
        }
        if (typeof capabilityValue !== "string") {
          throw new protocol_js_1.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' type: ${typeof capabilityValue}`);
        }
        switch (capabilityValue) {
          case "accept":
          case "accept and notify":
            return {
              default: "accept"
              /* Session.UserPromptHandlerType.Accept */
            };
          case "dismiss":
          case "dismiss and notify":
            return {
              default: "dismiss"
              /* Session.UserPromptHandlerType.Dismiss */
            };
          case "ignore":
            return {
              default: "ignore"
              /* Session.UserPromptHandlerType.Ignore */
            };
          default:
            throw new protocol_js_1.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' value: ${capabilityValue}`);
        }
      }
      async new(params) {
        if (this.#created) {
          throw new Error("Session has been already created.");
        }
        this.#created = true;
        const matchedCapabitlites = this.#mergeCapabilities(params.capabilities);
        await this.#initConnection(matchedCapabitlites);
        const version = await this.#browserCdpClient.sendCommand("Browser.getVersion");
        return {
          sessionId: "unknown",
          capabilities: {
            ...matchedCapabitlites,
            acceptInsecureCerts: matchedCapabitlites.acceptInsecureCerts ?? false,
            browserName: version.product,
            browserVersion: version.revision,
            platformName: "",
            setWindowRect: false,
            webSocketUrl: "",
            userAgent: version.userAgent
          }
        };
      }
      async subscribe(params, channel = {}) {
        const subscription = await this.#eventManager.subscribe(params.events, params.contexts ?? [], params.userContexts ?? [], channel);
        return {
          subscription
        };
      }
      async unsubscribe(params, channel = {}) {
        if ("subscriptions" in params) {
          await this.#eventManager.unsubscribeByIds(params.subscriptions);
          return {};
        }
        await this.#eventManager.unsubscribe(params.events, params.contexts ?? [], channel);
        return {};
      }
    };
    exports.SessionProcessor = SessionProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js
var require_StorageProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var assert_js_1 = require_assert();
    var log_js_1 = require_log();
    var NetworkProcessor_js_1 = require_NetworkProcessor();
    var NetworkUtils_js_1 = require_NetworkUtils();
    var StorageProcessor = class {
      #browserCdpClient;
      #browsingContextStorage;
      #logger;
      constructor(browserCdpClient, browsingContextStorage, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#browserCdpClient = browserCdpClient;
        this.#logger = logger;
      }
      async deleteCookies(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        let cdpResponse;
        try {
          cdpResponse = await this.#browserCdpClient.sendCommand("Storage.getCookies", {
            browserContextId: this.#getCdpBrowserContextId(partitionKey)
          });
        } catch (err) {
          if (this.#isNoSuchUserContextError(err)) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          throw err;
        }
        const cdpCookiesToDelete = cdpResponse.cookies.filter(
          // CDP's partition key is the source origin. If the request specifies the
          // `sourceOrigin` partition key, only cookies with the requested source origin
          // are returned.
          (c) => partitionKey.sourceOrigin === void 0 || c.partitionKey?.topLevelSite === partitionKey.sourceOrigin
        ).filter((cdpCookie) => {
          const bidiCookie = (0, NetworkUtils_js_1.cdpToBiDiCookie)(cdpCookie);
          return this.#matchCookie(bidiCookie, params.filter);
        }).map((cookie) => ({
          ...cookie,
          // Set expiry to pass date to delete the cookie.
          expires: 1
        }));
        await this.#browserCdpClient.sendCommand("Storage.setCookies", {
          cookies: cdpCookiesToDelete,
          browserContextId: this.#getCdpBrowserContextId(partitionKey)
        });
        return {
          partitionKey
        };
      }
      async getCookies(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        let cdpResponse;
        try {
          cdpResponse = await this.#browserCdpClient.sendCommand("Storage.getCookies", {
            browserContextId: this.#getCdpBrowserContextId(partitionKey)
          });
        } catch (err) {
          if (this.#isNoSuchUserContextError(err)) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          throw err;
        }
        const filteredBiDiCookies = cdpResponse.cookies.filter(
          // CDP's partition key is the source origin. If the request specifies the
          // `sourceOrigin` partition key, only cookies with the requested source origin
          // are returned.
          (c) => partitionKey.sourceOrigin === void 0 || c.partitionKey?.topLevelSite === partitionKey.sourceOrigin
        ).map((c) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(c)).filter((c) => this.#matchCookie(c, params.filter));
        return {
          cookies: filteredBiDiCookies,
          partitionKey
        };
      }
      async setCookie(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        const cdpCookie = (0, NetworkUtils_js_1.bidiToCdpCookie)(params, partitionKey);
        try {
          await this.#browserCdpClient.sendCommand("Storage.setCookies", {
            cookies: [cdpCookie],
            browserContextId: this.#getCdpBrowserContextId(partitionKey)
          });
        } catch (err) {
          if (this.#isNoSuchUserContextError(err)) {
            throw new protocol_js_1.NoSuchUserContextException(err.message);
          }
          this.#logger?.(log_js_1.LogType.debugError, err);
          throw new protocol_js_1.UnableToSetCookieException(err.toString());
        }
        return {
          partitionKey
        };
      }
      #isNoSuchUserContextError(err) {
        return err.message?.startsWith("Failed to find browser context for id");
      }
      #getCdpBrowserContextId(partitionKey) {
        return partitionKey.userContext === "default" ? void 0 : partitionKey.userContext;
      }
      #expandStoragePartitionSpecByBrowsingContext(descriptor) {
        const browsingContextId = descriptor.context;
        const browsingContext = this.#browsingContextStorage.getContext(browsingContextId);
        return {
          userContext: browsingContext.userContext
        };
      }
      #expandStoragePartitionSpecByStorageKey(descriptor) {
        const unsupportedPartitionKeys = /* @__PURE__ */ new Map();
        let sourceOrigin = descriptor.sourceOrigin;
        if (sourceOrigin !== void 0) {
          const url = NetworkProcessor_js_1.NetworkProcessor.parseUrlString(sourceOrigin);
          if (url.origin === "null") {
            sourceOrigin = url.origin;
          } else {
            sourceOrigin = `${url.protocol}//${url.hostname}`;
          }
        }
        for (const [key, value] of Object.entries(descriptor)) {
          if (key !== void 0 && value !== void 0 && !["type", "sourceOrigin", "userContext"].includes(key)) {
            unsupportedPartitionKeys.set(key, value);
          }
        }
        if (unsupportedPartitionKeys.size > 0) {
          this.#logger?.(log_js_1.LogType.debugInfo, `Unsupported partition keys: ${JSON.stringify(Object.fromEntries(unsupportedPartitionKeys))}`);
        }
        const userContext = descriptor.userContext ?? "default";
        return {
          userContext,
          ...sourceOrigin === void 0 ? {} : { sourceOrigin }
        };
      }
      #expandStoragePartitionSpec(partitionSpec) {
        if (partitionSpec === void 0) {
          return { userContext: "default" };
        }
        if (partitionSpec.type === "context") {
          return this.#expandStoragePartitionSpecByBrowsingContext(partitionSpec);
        }
        (0, assert_js_1.assert)(partitionSpec.type === "storageKey", "Unknown partition type");
        return this.#expandStoragePartitionSpecByStorageKey(partitionSpec);
      }
      #matchCookie(cookie, filter2) {
        if (filter2 === void 0) {
          return true;
        }
        return (filter2.domain === void 0 || filter2.domain === cookie.domain) && (filter2.name === void 0 || filter2.name === cookie.name) && // `value` contains fields `type` and `value`.
        (filter2.value === void 0 || (0, NetworkUtils_js_1.deserializeByteValue)(filter2.value) === (0, NetworkUtils_js_1.deserializeByteValue)(cookie.value)) && (filter2.path === void 0 || filter2.path === cookie.path) && (filter2.size === void 0 || filter2.size === cookie.size) && (filter2.httpOnly === void 0 || filter2.httpOnly === cookie.httpOnly) && (filter2.secure === void 0 || filter2.secure === cookie.secure) && (filter2.sameSite === void 0 || filter2.sameSite === cookie.sameSite) && (filter2.expiry === void 0 || filter2.expiry === cookie.expiry);
      }
    };
    exports.StorageProcessor = StorageProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/webExtension/WebExtensionProcessor.js
var require_WebExtensionProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/webExtension/WebExtensionProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebExtensionProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var WebExtensionProcessor = class {
      #browserCdpClient;
      constructor(browserCdpClient) {
        this.#browserCdpClient = browserCdpClient;
      }
      async install(params) {
        switch (params.extensionData.type) {
          case "archivePath":
          case "base64":
            throw new protocol_js_1.UnsupportedOperationException("Archived and Base64 extensions are not supported");
          case "path":
            break;
        }
        try {
          const response = await this.#browserCdpClient.sendCommand("Extensions.loadUnpacked", {
            path: params.extensionData.path
          });
          return {
            extension: response.id
          };
        } catch (err) {
          if (err.message.startsWith("invalid web extension")) {
            throw new protocol_js_1.InvalidWebExtensionException(err.message);
          }
          throw err;
        }
      }
      async uninstall(params) {
        try {
          await this.#browserCdpClient.sendCommand("Extensions.uninstall", {
            id: params.extension
          });
          return {};
        } catch (err) {
          if (err.message === "Uninstall failed. Reason: could not find extension.") {
            throw new protocol_js_1.NoSuchWebExtensionException("no such web extension");
          }
          throw err;
        }
      }
    };
    exports.WebExtensionProcessor = WebExtensionProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js
var require_OutgoingMessage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutgoingMessage = void 0;
    var OutgoingMessage = class {
      #message;
      #channel;
      constructor(message, channel) {
        this.#message = message;
        this.#channel = channel;
      }
      static createFromPromise(messagePromise, channel) {
        return messagePromise.then((message) => {
          if (message.kind === "success") {
            return {
              kind: "success",
              value: new OutgoingMessage(message.value, channel)
            };
          }
          return message;
        });
      }
      static createResolved(message, channel) {
        return Promise.resolve({
          kind: "success",
          value: new OutgoingMessage(message, channel)
        });
      }
      get message() {
        return this.#message;
      }
      get channel() {
        return this.#channel;
      }
    };
    exports.OutgoingMessage = OutgoingMessage;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js
var require_CommandProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommandProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var EventEmitter_js_1 = require_EventEmitter();
    var log_js_1 = require_log();
    var BidiNoOpParser_js_1 = require_BidiNoOpParser();
    var BrowserProcessor_js_1 = require_BrowserProcessor();
    var CdpProcessor_js_1 = require_CdpProcessor();
    var BrowsingContextProcessor_js_1 = require_BrowsingContextProcessor();
    var InputProcessor_js_1 = require_InputProcessor();
    var NetworkProcessor_js_1 = require_NetworkProcessor();
    var PermissionsProcessor_js_1 = require_PermissionsProcessor();
    var ScriptProcessor_js_1 = require_ScriptProcessor();
    var SessionProcessor_js_1 = require_SessionProcessor();
    var StorageProcessor_js_1 = require_StorageProcessor();
    var WebExtensionProcessor_js_1 = require_WebExtensionProcessor();
    var OutgoingMessage_js_1 = require_OutgoingMessage();
    var CommandProcessor = class extends EventEmitter_js_1.EventEmitter {
      // keep-sorted start
      #bluetoothProcessor;
      #browserProcessor;
      #browsingContextProcessor;
      #cdpProcessor;
      #inputProcessor;
      #networkProcessor;
      #permissionsProcessor;
      #scriptProcessor;
      #sessionProcessor;
      #storageProcessor;
      #webExtensionProcessor;
      // keep-sorted end
      #parser;
      #logger;
      constructor(cdpConnection, browserCdpClient, eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, networkStorage, bluetoothProcessor, userContextStorage, parser = new BidiNoOpParser_js_1.BidiNoOpParser(), initConnection, logger) {
        super();
        this.#parser = parser;
        this.#logger = logger;
        this.#bluetoothProcessor = bluetoothProcessor;
        this.#browserProcessor = new BrowserProcessor_js_1.BrowserProcessor(browserCdpClient, browsingContextStorage, userContextStorage);
        this.#browsingContextProcessor = new BrowsingContextProcessor_js_1.BrowsingContextProcessor(browserCdpClient, browsingContextStorage, eventManager);
        this.#cdpProcessor = new CdpProcessor_js_1.CdpProcessor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient);
        this.#inputProcessor = new InputProcessor_js_1.InputProcessor(browsingContextStorage);
        this.#networkProcessor = new NetworkProcessor_js_1.NetworkProcessor(browsingContextStorage, networkStorage);
        this.#permissionsProcessor = new PermissionsProcessor_js_1.PermissionsProcessor(browserCdpClient);
        this.#scriptProcessor = new ScriptProcessor_js_1.ScriptProcessor(eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, userContextStorage, logger);
        this.#sessionProcessor = new SessionProcessor_js_1.SessionProcessor(eventManager, browserCdpClient, initConnection);
        this.#storageProcessor = new StorageProcessor_js_1.StorageProcessor(browserCdpClient, browsingContextStorage, logger);
        this.#webExtensionProcessor = new WebExtensionProcessor_js_1.WebExtensionProcessor(browserCdpClient);
      }
      async #processCommand(command) {
        switch (command.method) {
          case "bluetooth.handleRequestDevicePrompt":
            return await this.#bluetoothProcessor.handleRequestDevicePrompt(this.#parser.parseHandleRequestDevicePromptParams(command.params));
          case "bluetooth.simulateAdapter":
            return await this.#bluetoothProcessor.simulateAdapter(this.#parser.parseSimulateAdapterParameters(command.params));
          case "bluetooth.simulateAdvertisement":
            return await this.#bluetoothProcessor.simulateAdvertisement(this.#parser.parseSimulateAdvertisementParameters(command.params));
          case "bluetooth.simulatePreconnectedPeripheral":
            return await this.#bluetoothProcessor.simulatePreconnectedPeripheral(this.#parser.parseSimulatePreconnectedPeripheralParameters(command.params));
          case "browser.close":
            return this.#browserProcessor.close();
          case "browser.createUserContext":
            return await this.#browserProcessor.createUserContext(command.params);
          case "browser.getClientWindows":
            return await this.#browserProcessor.getClientWindows();
          case "browser.getUserContexts":
            return await this.#browserProcessor.getUserContexts();
          case "browser.removeUserContext":
            return await this.#browserProcessor.removeUserContext(this.#parser.parseRemoveUserContextParams(command.params));
          case "browser.setClientWindowState":
            throw new protocol_js_1.UnknownErrorException(`Method ${command.method} is not implemented.`);
          case "browsingContext.activate":
            return await this.#browsingContextProcessor.activate(this.#parser.parseActivateParams(command.params));
          case "browsingContext.captureScreenshot":
            return await this.#browsingContextProcessor.captureScreenshot(this.#parser.parseCaptureScreenshotParams(command.params));
          case "browsingContext.close":
            return await this.#browsingContextProcessor.close(this.#parser.parseCloseParams(command.params));
          case "browsingContext.create":
            return await this.#browsingContextProcessor.create(this.#parser.parseCreateParams(command.params));
          case "browsingContext.getTree":
            return this.#browsingContextProcessor.getTree(this.#parser.parseGetTreeParams(command.params));
          case "browsingContext.handleUserPrompt":
            return await this.#browsingContextProcessor.handleUserPrompt(this.#parser.parseHandleUserPromptParams(command.params));
          case "browsingContext.locateNodes":
            return await this.#browsingContextProcessor.locateNodes(this.#parser.parseLocateNodesParams(command.params));
          case "browsingContext.navigate":
            return await this.#browsingContextProcessor.navigate(this.#parser.parseNavigateParams(command.params));
          case "browsingContext.print":
            return await this.#browsingContextProcessor.print(this.#parser.parsePrintParams(command.params));
          case "browsingContext.reload":
            return await this.#browsingContextProcessor.reload(this.#parser.parseReloadParams(command.params));
          case "browsingContext.setViewport":
            return await this.#browsingContextProcessor.setViewport(this.#parser.parseSetViewportParams(command.params));
          case "browsingContext.traverseHistory":
            return await this.#browsingContextProcessor.traverseHistory(this.#parser.parseTraverseHistoryParams(command.params));
          case "goog:cdp.getSession":
            return this.#cdpProcessor.getSession(this.#parser.parseGetSessionParams(command.params));
          case "goog:cdp.resolveRealm":
            return this.#cdpProcessor.resolveRealm(this.#parser.parseResolveRealmParams(command.params));
          case "goog:cdp.sendCommand":
            return await this.#cdpProcessor.sendCommand(this.#parser.parseSendCommandParams(command.params));
          case "cdp.getSession":
            this.#logger?.(log_js_1.LogType.debugWarn, `Legacy '${command.method}' command is deprecated and will not supported soon. Use 'goog:${command.method}' instead.`);
            return this.#cdpProcessor.getSession(this.#parser.parseGetSessionParams(command.params));
          case "cdp.resolveRealm":
            this.#logger?.(log_js_1.LogType.debugWarn, `Legacy '${command.method}' command is deprecated and will not supported soon. Use 'goog:${command.method}' instead.`);
            return this.#cdpProcessor.resolveRealm(this.#parser.parseResolveRealmParams(command.params));
          case "cdp.sendCommand":
            this.#logger?.(log_js_1.LogType.debugWarn, `Legacy '${command.method}' command is deprecated and will not supported soon. Use 'goog:${command.method}' instead.`);
            return await this.#cdpProcessor.sendCommand(this.#parser.parseSendCommandParams(command.params));
          case "input.performActions":
            return await this.#inputProcessor.performActions(this.#parser.parsePerformActionsParams(command.params));
          case "input.releaseActions":
            return await this.#inputProcessor.releaseActions(this.#parser.parseReleaseActionsParams(command.params));
          case "input.setFiles":
            return await this.#inputProcessor.setFiles(this.#parser.parseSetFilesParams(command.params));
          case "network.addIntercept":
            return await this.#networkProcessor.addIntercept(this.#parser.parseAddInterceptParams(command.params));
          case "network.continueRequest":
            return await this.#networkProcessor.continueRequest(this.#parser.parseContinueRequestParams(command.params));
          case "network.continueResponse":
            return await this.#networkProcessor.continueResponse(this.#parser.parseContinueResponseParams(command.params));
          case "network.continueWithAuth":
            return await this.#networkProcessor.continueWithAuth(this.#parser.parseContinueWithAuthParams(command.params));
          case "network.failRequest":
            return await this.#networkProcessor.failRequest(this.#parser.parseFailRequestParams(command.params));
          case "network.provideResponse":
            return await this.#networkProcessor.provideResponse(this.#parser.parseProvideResponseParams(command.params));
          case "network.removeIntercept":
            return await this.#networkProcessor.removeIntercept(this.#parser.parseRemoveInterceptParams(command.params));
          case "network.setCacheBehavior":
            return await this.#networkProcessor.setCacheBehavior(this.#parser.parseSetCacheBehavior(command.params));
          case "permissions.setPermission":
            return await this.#permissionsProcessor.setPermissions(this.#parser.parseSetPermissionsParams(command.params));
          case "script.addPreloadScript":
            return await this.#scriptProcessor.addPreloadScript(this.#parser.parseAddPreloadScriptParams(command.params));
          case "script.callFunction":
            return await this.#scriptProcessor.callFunction(this.#parser.parseCallFunctionParams(this.#processTargetParams(command.params)));
          case "script.disown":
            return await this.#scriptProcessor.disown(this.#parser.parseDisownParams(this.#processTargetParams(command.params)));
          case "script.evaluate":
            return await this.#scriptProcessor.evaluate(this.#parser.parseEvaluateParams(this.#processTargetParams(command.params)));
          case "script.getRealms":
            return this.#scriptProcessor.getRealms(this.#parser.parseGetRealmsParams(command.params));
          case "script.removePreloadScript":
            return await this.#scriptProcessor.removePreloadScript(this.#parser.parseRemovePreloadScriptParams(command.params));
          case "session.end":
            throw new protocol_js_1.UnknownErrorException(`Method ${command.method} is not implemented.`);
          case "session.new":
            return await this.#sessionProcessor.new(command.params);
          case "session.status":
            return this.#sessionProcessor.status();
          case "session.subscribe":
            return await this.#sessionProcessor.subscribe(this.#parser.parseSubscribeParams(command.params), command.channel);
          case "session.unsubscribe":
            return await this.#sessionProcessor.unsubscribe(this.#parser.parseUnsubscribeParams(command.params), command.channel);
          case "storage.deleteCookies":
            return await this.#storageProcessor.deleteCookies(this.#parser.parseDeleteCookiesParams(command.params));
          case "storage.getCookies":
            return await this.#storageProcessor.getCookies(this.#parser.parseGetCookiesParams(command.params));
          case "storage.setCookie":
            return await this.#storageProcessor.setCookie(this.#parser.parseSetCookieParams(command.params));
          case "webExtension.install":
            return await this.#webExtensionProcessor.install(this.#parser.parseInstallParams(command.params));
          case "webExtension.uninstall":
            return await this.#webExtensionProcessor.uninstall(this.#parser.parseUninstallParams(command.params));
        }
        throw new protocol_js_1.UnknownCommandException(`Unknown command '${command?.method}'.`);
      }
      // Workaround for as zod.union always take the first schema
      // https://github.com/w3c/webdriver-bidi/issues/635
      #processTargetParams(params) {
        if (typeof params === "object" && params && "target" in params && typeof params.target === "object" && params.target && "context" in params.target) {
          delete params.target["realm"];
        }
        return params;
      }
      async processCommand(command) {
        try {
          const result = await this.#processCommand(command);
          const response = {
            type: "success",
            id: command.id,
            result
          };
          this.emit("response", {
            message: OutgoingMessage_js_1.OutgoingMessage.createResolved(response, command.channel),
            event: command.method
          });
        } catch (e) {
          if (e instanceof protocol_js_1.Exception) {
            this.emit("response", {
              message: OutgoingMessage_js_1.OutgoingMessage.createResolved(e.toErrorResponse(command.id), command.channel),
              event: command.method
            });
          } else {
            const error = e;
            this.#logger?.(log_js_1.LogType.bidi, error);
            this.emit("response", {
              message: OutgoingMessage_js_1.OutgoingMessage.createResolved(new protocol_js_1.UnknownErrorException(error.message, error.stack).toErrorResponse(command.id), command.channel),
              event: command.method
            });
          }
        }
      }
    };
    exports.CommandProcessor = CommandProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/bluetooth/BluetoothProcessor.js
var require_BluetoothProcessor = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/bluetooth/BluetoothProcessor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BluetoothProcessor = void 0;
    var protocol_js_1 = require_protocol();
    var BluetoothProcessor = class {
      #eventManager;
      #browsingContextStorage;
      constructor(eventManager, browsingContextStorage) {
        this.#eventManager = eventManager;
        this.#browsingContextStorage = browsingContextStorage;
      }
      async simulateAdapter(params) {
        if (params.type !== "create") {
          throw new protocol_js_1.UnsupportedOperationException(`Simulate type "${params.type}" is not supported. Only create type is supported`);
        }
        if (params.state === void 0) {
          throw new protocol_js_1.InvalidArgumentException(`Parameter "state" is required for creating a Bluetooth adapter`);
        }
        const context2 = this.#browsingContextStorage.getContext(params.context);
        await context2.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.disable");
        await context2.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.enable", {
          state: params.state
        });
        return {};
      }
      async simulatePreconnectedPeripheral(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        await context2.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.simulatePreconnectedPeripheral", {
          address: params.address,
          name: params.name,
          knownServiceUuids: params.knownServiceUuids,
          manufacturerData: params.manufacturerData
        });
        return {};
      }
      async simulateAdvertisement(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        await context2.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.simulateAdvertisement", {
          entry: params.scanEntry
        });
        return {};
      }
      onCdpTargetCreated(cdpTarget) {
        cdpTarget.cdpClient.on("DeviceAccess.deviceRequestPrompted", (event) => {
          this.#eventManager.registerEvent({
            type: "event",
            method: "bluetooth.requestDevicePromptUpdated",
            params: {
              context: cdpTarget.id,
              prompt: event.id,
              devices: event.devices
            }
          }, cdpTarget.id);
        });
      }
      async handleRequestDevicePrompt(params) {
        const context2 = this.#browsingContextStorage.getContext(params.context);
        if (params.accept) {
          await context2.cdpTarget.cdpClient.sendCommand("DeviceAccess.selectPrompt", {
            id: params.prompt,
            deviceId: params.device
          });
        } else {
          await context2.cdpTarget.cdpClient.sendCommand("DeviceAccess.cancelPrompt", {
            id: params.prompt
          });
        }
        return {};
      }
    };
    exports.BluetoothProcessor = BluetoothProcessor;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/UserContextStorage.js
var require_UserContextStorage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/UserContextStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserContextStorage = void 0;
    var protocol_js_1 = require_protocol();
    var UserContextStorage = class {
      #browserClient;
      constructor(browserClient) {
        this.#browserClient = browserClient;
      }
      async getUserContexts() {
        const result = await this.#browserClient.sendCommand("Target.getBrowserContexts");
        return [
          {
            userContext: "default"
          },
          ...result.browserContextIds.map((id) => {
            return {
              userContext: id
            };
          })
        ];
      }
      async verifyUserContextIdList(userContextIds) {
        const foundContexts = /* @__PURE__ */ new Set();
        if (!userContextIds.length) {
          return foundContexts;
        }
        const userContexts = await this.getUserContexts();
        const knownUserContextIds = new Set(userContexts.map((userContext) => userContext.userContext));
        for (const userContextId of userContextIds) {
          if (!knownUserContextIds.has(userContextId)) {
            throw new protocol_js_1.NoSuchUserContextException(`User context ${userContextId} not found`);
          }
          foundContexts.add(userContextId);
        }
        return foundContexts;
      }
    };
    exports.UserContextStorage = UserContextStorage;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/Deferred.js
var require_Deferred = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/Deferred.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred2 = class {
      #isFinished = false;
      #promise;
      #result;
      #resolve;
      #reject;
      get isFinished() {
        return this.#isFinished;
      }
      get result() {
        if (!this.#isFinished) {
          throw new Error("Deferred is not finished yet");
        }
        return this.#result;
      }
      constructor() {
        this.#promise = new Promise((resolve, reject) => {
          this.#resolve = resolve;
          this.#reject = reject;
        });
        this.#promise.catch((_error) => {
        });
      }
      then(onFulfilled, onRejected) {
        return this.#promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.#promise.catch(onRejected);
      }
      resolve(value) {
        this.#result = value;
        if (!this.#isFinished) {
          this.#isFinished = true;
          this.#resolve(value);
        }
      }
      reject(reason) {
        if (!this.#isFinished) {
          this.#isFinished = true;
          this.#reject(reason);
        }
      }
      finally(onFinally) {
        return this.#promise.finally(onFinally);
      }
      [Symbol.toStringTag] = "Promise";
    };
    exports.Deferred = Deferred2;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/time.js
var require_time = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTimestamp = getTimestamp;
    function getTimestamp() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js
var require_unitConversions = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inchesFromCm = inchesFromCm;
    function inchesFromCm(cm) {
      return cm / 2.54;
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js
var require_Realm = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Realm = void 0;
    var protocol_js_1 = require_protocol();
    var log_js_1 = require_log();
    var uuid_js_1 = require_uuid();
    var ChannelProxy_js_1 = require_ChannelProxy();
    var _cdpClient, _eventManager, _executionContextId, _logger, _origin, _realmId, _realmStorage, _registerEvent, registerEvent_fn, _cdpRemoteObjectToCallArgument, cdpRemoteObjectToCallArgument_fn, _flattenKeyValuePairs, flattenKeyValuePairs_fn, _flattenValueList, flattenValueList_fn, _serializeCdpExceptionDetails, serializeCdpExceptionDetails_fn, _getExceptionResult, getExceptionResult_fn, _getSerializationOptions, getSerializationOptions_fn, _getAdditionalSerializationParameters, getAdditionalSerializationParameters_fn, _getMaxObjectDepth, getMaxObjectDepth_fn, _releaseObject, releaseObject_fn;
    var _Realm = class {
      constructor(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage) {
        __privateAdd(this, _registerEvent);
        __privateAdd(this, _flattenKeyValuePairs);
        __privateAdd(this, _flattenValueList);
        __privateAdd(this, _serializeCdpExceptionDetails);
        __privateAdd(this, _getExceptionResult);
        __privateAdd(this, _releaseObject);
        __privateAdd(this, _cdpClient, void 0);
        __privateAdd(this, _eventManager, void 0);
        __privateAdd(this, _executionContextId, void 0);
        __privateAdd(this, _logger, void 0);
        __privateAdd(this, _origin, void 0);
        __privateAdd(this, _realmId, void 0);
        __privateAdd(this, _realmStorage, void 0);
        __privateSet(this, _cdpClient, cdpClient);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _executionContextId, executionContextId);
        __privateSet(this, _logger, logger);
        __privateSet(this, _origin, origin);
        __privateSet(this, _realmId, realmId);
        __privateSet(this, _realmStorage, realmStorage);
        __privateGet(this, _realmStorage).addRealm(this);
      }
      cdpToBidiValue(cdpValue, resultOwnership) {
        const bidiValue = this.serializeForBiDi(cdpValue.result.deepSerializedValue, /* @__PURE__ */ new Map());
        if (cdpValue.result.objectId) {
          const objectId = cdpValue.result.objectId;
          if (resultOwnership === "root") {
            bidiValue.handle = objectId;
            __privateGet(this, _realmStorage).knownHandlesToRealmMap.set(objectId, this.realmId);
          } else {
            void __privateMethod(this, _releaseObject, releaseObject_fn).call(this, objectId).catch((error) => {
              var _a3;
              return (_a3 = __privateGet(this, _logger)) == null ? void 0 : _a3.call(this, log_js_1.LogType.debugError, error);
            });
          }
        }
        return bidiValue;
      }
      /**
       * Relies on the CDP to implement proper BiDi serialization, except:
       * * CDP integer property `backendNodeId` is replaced with `sharedId` of
       * `{documentId}_element_{backendNodeId}`;
       * * CDP integer property `weakLocalObjectReference` is replaced with UUID `internalId`
       * using unique-per serialization `internalIdMap`.
       * * CDP type `platformobject` is replaced with `object`.
       * @param deepSerializedValue - CDP value to be converted to BiDi.
       * @param internalIdMap - Map from CDP integer `weakLocalObjectReference` to BiDi UUID
       * `internalId`.
       */
      serializeForBiDi(deepSerializedValue, internalIdMap) {
        if (Object.hasOwn(deepSerializedValue, "weakLocalObjectReference")) {
          const weakLocalObjectReference = deepSerializedValue.weakLocalObjectReference;
          if (!internalIdMap.has(weakLocalObjectReference)) {
            internalIdMap.set(weakLocalObjectReference, (0, uuid_js_1.uuidv4)());
          }
          deepSerializedValue.internalId = internalIdMap.get(weakLocalObjectReference);
          delete deepSerializedValue["weakLocalObjectReference"];
        }
        if (deepSerializedValue.type === "node" && deepSerializedValue.value && Object.hasOwn(deepSerializedValue.value, "frameId")) {
          delete deepSerializedValue.value["frameId"];
        }
        if (deepSerializedValue.type === "platformobject") {
          return { type: "object" };
        }
        const bidiValue = deepSerializedValue.value;
        if (bidiValue === void 0) {
          return deepSerializedValue;
        }
        if (["array", "set", "htmlcollection", "nodelist"].includes(deepSerializedValue.type)) {
          for (const i in bidiValue) {
            bidiValue[i] = this.serializeForBiDi(bidiValue[i], internalIdMap);
          }
        }
        if (["object", "map"].includes(deepSerializedValue.type)) {
          for (const i in bidiValue) {
            bidiValue[i] = [
              this.serializeForBiDi(bidiValue[i][0], internalIdMap),
              this.serializeForBiDi(bidiValue[i][1], internalIdMap)
            ];
          }
        }
        return deepSerializedValue;
      }
      get realmId() {
        return __privateGet(this, _realmId);
      }
      get executionContextId() {
        return __privateGet(this, _executionContextId);
      }
      get origin() {
        return __privateGet(this, _origin);
      }
      get source() {
        return {
          realm: this.realmId
        };
      }
      get cdpClient() {
        return __privateGet(this, _cdpClient);
      }
      get baseInfo() {
        return {
          realm: this.realmId,
          origin: this.origin
        };
      }
      async evaluate(expression, awaitPromise, resultOwnership = "none", serializationOptions = {}, userActivation = false, includeCommandLineApi = false) {
        var _a3;
        const cdpEvaluateResult = await this.cdpClient.sendCommand("Runtime.evaluate", {
          contextId: this.executionContextId,
          expression,
          awaitPromise,
          serializationOptions: __privateMethod(_a3 = _Realm, _getSerializationOptions, getSerializationOptions_fn).call(_a3, "deep", serializationOptions),
          userGesture: userActivation,
          includeCommandLineAPI: includeCommandLineApi
        });
        if (cdpEvaluateResult.exceptionDetails) {
          return await __privateMethod(this, _getExceptionResult, getExceptionResult_fn).call(this, cdpEvaluateResult.exceptionDetails, 0, resultOwnership);
        }
        return {
          realm: this.realmId,
          result: this.cdpToBidiValue(cdpEvaluateResult, resultOwnership),
          type: "success"
        };
      }
      initialize() {
        __privateMethod(this, _registerEvent, registerEvent_fn).call(this, {
          type: "event",
          method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
          params: this.realmInfo
        });
      }
      /**
       * Serializes a given CDP object into BiDi, keeping references in the
       * target's `globalThis`.
       */
      async serializeCdpObject(cdpRemoteObject, resultOwnership) {
        var _a3;
        const argument = __privateMethod(_a3 = _Realm, _cdpRemoteObjectToCallArgument, cdpRemoteObjectToCallArgument_fn).call(_a3, cdpRemoteObject);
        const cdpValue = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
          functionDeclaration: String((remoteObject) => remoteObject),
          awaitPromise: false,
          arguments: [argument],
          serializationOptions: {
            serialization: "deep"
          },
          executionContextId: this.executionContextId
        });
        return this.cdpToBidiValue(cdpValue, resultOwnership);
      }
      /**
       * Gets the string representation of an object. This is equivalent to
       * calling `toString()` on the object value.
       */
      async stringifyObject(cdpRemoteObject) {
        const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
          functionDeclaration: String(
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            (remoteObject) => String(remoteObject)
          ),
          awaitPromise: false,
          arguments: [cdpRemoteObject],
          returnByValue: true,
          executionContextId: this.executionContextId
        });
        return result.value;
      }
      async callFunction(functionDeclaration, awaitPromise, thisLocalValue = {
        type: "undefined"
      }, argumentsLocalValues = [], resultOwnership = "none", serializationOptions = {}, userActivation = false) {
        var _a3;
        const callFunctionAndSerializeScript = `(...args) => {
      function callFunction(f, args) {
        const deserializedThis = args.shift();
        const deserializedArgs = args;
        return f.apply(deserializedThis, deserializedArgs);
      }
      return callFunction((
        ${functionDeclaration}
      ), args);
    }`;
        const thisAndArgumentsList = [
          await this.deserializeForCdp(thisLocalValue),
          ...await Promise.all(argumentsLocalValues.map(async (argumentLocalValue) => await this.deserializeForCdp(argumentLocalValue)))
        ];
        let cdpCallFunctionResult;
        try {
          cdpCallFunctionResult = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: callFunctionAndSerializeScript,
            awaitPromise,
            arguments: thisAndArgumentsList,
            serializationOptions: __privateMethod(_a3 = _Realm, _getSerializationOptions, getSerializationOptions_fn).call(_a3, "deep", serializationOptions),
            executionContextId: this.executionContextId,
            userGesture: userActivation
          });
        } catch (error) {
          if (error.code === -32e3 && [
            "Could not find object with given id",
            "Argument should belong to the same JavaScript world as target object",
            "Invalid remote object id"
          ].includes(error.message)) {
            throw new protocol_js_1.NoSuchHandleException("Handle was not found.");
          }
          throw error;
        }
        if (cdpCallFunctionResult.exceptionDetails) {
          return await __privateMethod(this, _getExceptionResult, getExceptionResult_fn).call(this, cdpCallFunctionResult.exceptionDetails, 1, resultOwnership);
        }
        return {
          type: "success",
          result: this.cdpToBidiValue(cdpCallFunctionResult, resultOwnership),
          realm: this.realmId
        };
      }
      async deserializeForCdp(localValue) {
        if ("handle" in localValue && localValue.handle) {
          return { objectId: localValue.handle };
        } else if ("handle" in localValue || "sharedId" in localValue) {
          throw new protocol_js_1.NoSuchHandleException("Handle was not found.");
        }
        switch (localValue.type) {
          case "undefined":
            return { unserializableValue: "undefined" };
          case "null":
            return { unserializableValue: "null" };
          case "string":
            return { value: localValue.value };
          case "number":
            if (localValue.value === "NaN") {
              return { unserializableValue: "NaN" };
            } else if (localValue.value === "-0") {
              return { unserializableValue: "-0" };
            } else if (localValue.value === "Infinity") {
              return { unserializableValue: "Infinity" };
            } else if (localValue.value === "-Infinity") {
              return { unserializableValue: "-Infinity" };
            }
            return {
              value: localValue.value
            };
          case "boolean":
            return { value: Boolean(localValue.value) };
          case "bigint":
            return {
              unserializableValue: `BigInt(${JSON.stringify(localValue.value)})`
            };
          case "date":
            return {
              unserializableValue: `new Date(Date.parse(${JSON.stringify(localValue.value)}))`
            };
          case "regexp":
            return {
              unserializableValue: `new RegExp(${JSON.stringify(localValue.value.pattern)}, ${JSON.stringify(localValue.value.flags)})`
            };
          case "map": {
            const keyValueArray = await __privateMethod(this, _flattenKeyValuePairs, flattenKeyValuePairs_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args) => {
                const result2 = /* @__PURE__ */ new Map();
                for (let i = 0; i < args.length; i += 2) {
                  result2.set(args[i], args[i + 1]);
                }
                return result2;
              }),
              awaitPromise: false,
              arguments: keyValueArray,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "object": {
            const keyValueArray = await __privateMethod(this, _flattenKeyValuePairs, flattenKeyValuePairs_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args) => {
                const result2 = {};
                for (let i = 0; i < args.length; i += 2) {
                  const key = args[i];
                  result2[key] = args[i + 1];
                }
                return result2;
              }),
              awaitPromise: false,
              arguments: keyValueArray,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "array": {
            const args = await __privateMethod(this, _flattenValueList, flattenValueList_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args2) => args2),
              awaitPromise: false,
              arguments: args,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "set": {
            const args = await __privateMethod(this, _flattenValueList, flattenValueList_fn).call(this, localValue.value);
            const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: String((...args2) => new Set(args2)),
              awaitPromise: false,
              arguments: args,
              returnByValue: false,
              executionContextId: this.executionContextId
            });
            return { objectId: result.objectId };
          }
          case "channel": {
            const channelProxy = new ChannelProxy_js_1.ChannelProxy(localValue.value, __privateGet(this, _logger));
            const channelProxySendMessageHandle = await channelProxy.init(this, __privateGet(this, _eventManager));
            return { objectId: channelProxySendMessageHandle };
          }
        }
        throw new Error(`Value ${JSON.stringify(localValue)} is not deserializable.`);
      }
      async disown(handle) {
        if (__privateGet(this, _realmStorage).knownHandlesToRealmMap.get(handle) !== this.realmId) {
          return;
        }
        await __privateMethod(this, _releaseObject, releaseObject_fn).call(this, handle);
        __privateGet(this, _realmStorage).knownHandlesToRealmMap.delete(handle);
      }
      dispose() {
        __privateMethod(this, _registerEvent, registerEvent_fn).call(this, {
          type: "event",
          method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmDestroyed,
          params: {
            realm: this.realmId
          }
        });
      }
    };
    var Realm3 = _Realm;
    _cdpClient = new WeakMap();
    _eventManager = new WeakMap();
    _executionContextId = new WeakMap();
    _logger = new WeakMap();
    _origin = new WeakMap();
    _realmId = new WeakMap();
    _realmStorage = new WeakMap();
    _registerEvent = new WeakSet();
    registerEvent_fn = function(event) {
      if (this.associatedBrowsingContexts.length === 0) {
        __privateGet(this, _eventManager).registerGlobalEvent(event);
      } else {
        for (const browsingContext of this.associatedBrowsingContexts) {
          __privateGet(this, _eventManager).registerEvent(event, browsingContext.id);
        }
      }
    };
    _cdpRemoteObjectToCallArgument = new WeakSet();
    cdpRemoteObjectToCallArgument_fn = function(cdpRemoteObject) {
      if (cdpRemoteObject.objectId !== void 0) {
        return { objectId: cdpRemoteObject.objectId };
      }
      if (cdpRemoteObject.unserializableValue !== void 0) {
        return { unserializableValue: cdpRemoteObject.unserializableValue };
      }
      return { value: cdpRemoteObject.value };
    };
    _flattenKeyValuePairs = new WeakSet();
    flattenKeyValuePairs_fn = async function(mappingLocalValue) {
      const keyValueArray = await Promise.all(mappingLocalValue.map(async ([key, value]) => {
        let keyArg;
        if (typeof key === "string") {
          keyArg = { value: key };
        } else {
          keyArg = await this.deserializeForCdp(key);
        }
        const valueArg = await this.deserializeForCdp(value);
        return [keyArg, valueArg];
      }));
      return keyValueArray.flat();
    };
    _flattenValueList = new WeakSet();
    flattenValueList_fn = async function(listLocalValue) {
      return await Promise.all(listLocalValue.map((localValue) => this.deserializeForCdp(localValue)));
    };
    _serializeCdpExceptionDetails = new WeakSet();
    serializeCdpExceptionDetails_fn = async function(cdpExceptionDetails, lineOffset, resultOwnership) {
      const callFrames = cdpExceptionDetails.stackTrace?.callFrames.map((frame) => ({
        url: frame.url,
        functionName: frame.functionName,
        lineNumber: frame.lineNumber - lineOffset,
        columnNumber: frame.columnNumber
      })) ?? [];
      const exception = cdpExceptionDetails.exception;
      return {
        exception: await this.serializeCdpObject(exception, resultOwnership),
        columnNumber: cdpExceptionDetails.columnNumber,
        lineNumber: cdpExceptionDetails.lineNumber - lineOffset,
        stackTrace: {
          callFrames
        },
        text: await this.stringifyObject(exception) || cdpExceptionDetails.text
      };
    };
    _getExceptionResult = new WeakSet();
    getExceptionResult_fn = async function(exceptionDetails, lineOffset, resultOwnership) {
      return {
        exceptionDetails: await __privateMethod(this, _serializeCdpExceptionDetails, serializeCdpExceptionDetails_fn).call(this, exceptionDetails, lineOffset, resultOwnership),
        realm: this.realmId,
        type: "exception"
      };
    };
    _getSerializationOptions = new WeakSet();
    getSerializationOptions_fn = function(serialization, serializationOptions) {
      var _a3, _b;
      return {
        serialization,
        additionalParameters: __privateMethod(_a3 = _Realm, _getAdditionalSerializationParameters, getAdditionalSerializationParameters_fn).call(_a3, serializationOptions),
        ...__privateMethod(_b = _Realm, _getMaxObjectDepth, getMaxObjectDepth_fn).call(_b, serializationOptions)
      };
    };
    _getAdditionalSerializationParameters = new WeakSet();
    getAdditionalSerializationParameters_fn = function(serializationOptions) {
      const additionalParameters = {};
      if (serializationOptions.maxDomDepth !== void 0) {
        additionalParameters["maxNodeDepth"] = serializationOptions.maxDomDepth === null ? 1e3 : serializationOptions.maxDomDepth;
      }
      if (serializationOptions.includeShadowTree !== void 0) {
        additionalParameters["includeShadowTree"] = serializationOptions.includeShadowTree;
      }
      return additionalParameters;
    };
    _getMaxObjectDepth = new WeakSet();
    getMaxObjectDepth_fn = function(serializationOptions) {
      return serializationOptions.maxObjectDepth === void 0 || serializationOptions.maxObjectDepth === null ? {} : { maxDepth: serializationOptions.maxObjectDepth };
    };
    _releaseObject = new WeakSet();
    releaseObject_fn = async function(handle) {
      try {
        await this.cdpClient.sendCommand("Runtime.releaseObject", {
          objectId: handle
        });
      } catch (error) {
        if (!(error.code === -32e3 && error.message === "Invalid remote object id")) {
          throw error;
        }
      }
    };
    __privateAdd(Realm3, _cdpRemoteObjectToCallArgument);
    __privateAdd(Realm3, _getSerializationOptions);
    __privateAdd(Realm3, _getAdditionalSerializationParameters);
    __privateAdd(Realm3, _getMaxObjectDepth);
    exports.Realm = Realm3;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js
var require_SharedId = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSharedId = getSharedId;
    exports.parseSharedId = parseSharedId;
    var SHARED_ID_DIVIDER = "_element_";
    function getSharedId(frameId, documentId, backendNodeId) {
      return `f.${frameId}.d.${documentId}.e.${backendNodeId}`;
    }
    function parseLegacySharedId(sharedId) {
      const match = sharedId.match(new RegExp(`(.*)${SHARED_ID_DIVIDER}(.*)`));
      if (!match) {
        return null;
      }
      const documentId = match[1];
      const elementId = match[2];
      if (documentId === void 0 || elementId === void 0) {
        return null;
      }
      const backendNodeId = parseInt(elementId ?? "");
      if (isNaN(backendNodeId)) {
        return null;
      }
      return {
        documentId,
        backendNodeId
      };
    }
    function parseSharedId(sharedId) {
      const legacyFormattedSharedId = parseLegacySharedId(sharedId);
      if (legacyFormattedSharedId !== null) {
        return { ...legacyFormattedSharedId, frameId: void 0 };
      }
      const match = sharedId.match(/f\.(.*)\.d\.(.*)\.e\.([0-9]*)/);
      if (!match) {
        return null;
      }
      const frameId = match[1];
      const documentId = match[2];
      const elementId = match[3];
      if (frameId === void 0 || documentId === void 0 || elementId === void 0) {
        return null;
      }
      const backendNodeId = parseInt(elementId ?? "");
      if (isNaN(backendNodeId)) {
        return null;
      }
      return {
        frameId,
        documentId,
        backendNodeId
      };
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js
var require_WindowRealm = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WindowRealm = void 0;
    var protocol_js_1 = require_protocol();
    var Realm_js_1 = require_Realm();
    var SharedId_js_1 = require_SharedId();
    var WindowRealm2 = class extends Realm_js_1.Realm {
      #browsingContextId;
      #browsingContextStorage;
      sandbox;
      constructor(browsingContextId, browsingContextStorage, cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage, sandbox) {
        super(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage);
        this.#browsingContextId = browsingContextId;
        this.#browsingContextStorage = browsingContextStorage;
        this.sandbox = sandbox;
        this.initialize();
      }
      #getBrowsingContextId(navigableId) {
        const maybeBrowsingContext = this.#browsingContextStorage.getAllContexts().find((context2) => context2.navigableId === navigableId);
        return maybeBrowsingContext?.id ?? "UNKNOWN";
      }
      get browsingContext() {
        return this.#browsingContextStorage.getContext(this.#browsingContextId);
      }
      get associatedBrowsingContexts() {
        return [this.browsingContext];
      }
      get realmType() {
        return "window";
      }
      get realmInfo() {
        return {
          ...this.baseInfo,
          type: this.realmType,
          context: this.#browsingContextId,
          sandbox: this.sandbox
        };
      }
      get source() {
        return {
          realm: this.realmId,
          context: this.browsingContext.id
        };
      }
      serializeForBiDi(deepSerializedValue, internalIdMap) {
        const bidiValue = deepSerializedValue.value;
        if (deepSerializedValue.type === "node" && bidiValue !== void 0) {
          if (Object.hasOwn(bidiValue, "backendNodeId")) {
            let navigableId = this.browsingContext.navigableId ?? "UNKNOWN";
            if (Object.hasOwn(bidiValue, "loaderId")) {
              navigableId = bidiValue.loaderId;
              delete bidiValue["loaderId"];
            }
            deepSerializedValue.sharedId = (0, SharedId_js_1.getSharedId)(this.#getBrowsingContextId(navigableId), navigableId, bidiValue.backendNodeId);
            delete bidiValue["backendNodeId"];
          }
          if (Object.hasOwn(bidiValue, "children")) {
            for (const i in bidiValue.children) {
              bidiValue.children[i] = this.serializeForBiDi(bidiValue.children[i], internalIdMap);
            }
          }
          if (Object.hasOwn(bidiValue, "shadowRoot") && bidiValue.shadowRoot !== null) {
            bidiValue.shadowRoot = this.serializeForBiDi(bidiValue.shadowRoot, internalIdMap);
          }
          if (bidiValue.namespaceURI === "") {
            bidiValue.namespaceURI = null;
          }
        }
        return super.serializeForBiDi(deepSerializedValue, internalIdMap);
      }
      async deserializeForCdp(localValue) {
        if ("sharedId" in localValue && localValue.sharedId) {
          const parsedSharedId = (0, SharedId_js_1.parseSharedId)(localValue.sharedId);
          if (parsedSharedId === null) {
            throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
          }
          const { documentId, backendNodeId } = parsedSharedId;
          if (this.browsingContext.navigableId !== documentId) {
            throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" belongs to different document. Current document is ${this.browsingContext.navigableId}.`);
          }
          try {
            const { object } = await this.cdpClient.sendCommand("DOM.resolveNode", {
              backendNodeId,
              executionContextId: this.executionContextId
            });
            return { objectId: object.objectId };
          } catch (error) {
            if (error.code === -32e3 && error.message === "No node with given id found") {
              throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
            }
            throw new protocol_js_1.UnknownErrorException(error.message, error.stack);
          }
        }
        return await super.deserializeForCdp(localValue);
      }
      async evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi) {
        await this.#browsingContextStorage.getContext(this.#browsingContextId).targetUnblockedOrThrow();
        return await super.evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi);
      }
      async callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation) {
        await this.#browsingContextStorage.getContext(this.#browsingContextId).targetUnblockedOrThrow();
        return await super.callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation);
      }
    };
    exports.WindowRealm = WindowRealm2;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/urlHelpers.js
var require_urlHelpers = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/urlHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.urlMatchesAboutBlank = urlMatchesAboutBlank;
    function urlMatchesAboutBlank(url) {
      if (url === "") {
        return true;
      }
      try {
        const parsedUrl = new URL(url);
        const schema = parsedUrl.protocol.replace(/:$/, "");
        return schema.toLowerCase() === "about" && parsedUrl.pathname.toLowerCase() === "blank" && parsedUrl.username === "" && parsedUrl.password === "" && parsedUrl.host === "";
      } catch (err) {
        if (err instanceof TypeError) {
          return false;
        }
        throw err;
      }
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/NavigationTracker.js
var require_NavigationTracker = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/NavigationTracker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NavigationTracker = exports.NavigationState = exports.NavigationResult = void 0;
    var protocol_js_1 = require_protocol();
    var Deferred_js_1 = require_Deferred();
    var log_js_1 = require_log();
    var time_js_1 = require_time();
    var urlHelpers_js_1 = require_urlHelpers();
    var uuid_js_1 = require_uuid();
    var NavigationResult = class {
      eventName;
      message;
      constructor(eventName, message) {
        this.eventName = eventName;
        this.message = message;
      }
    };
    exports.NavigationResult = NavigationResult;
    var NavigationState = class {
      navigationId = (0, uuid_js_1.uuidv4)();
      #browsingContextId;
      #started = false;
      #finished = new Deferred_js_1.Deferred();
      url;
      loaderId;
      #isInitial;
      #eventManager;
      committed = new Deferred_js_1.Deferred();
      isFragmentNavigation;
      get finished() {
        return this.#finished;
      }
      constructor(url, browsingContextId, isInitial, eventManager) {
        this.#browsingContextId = browsingContextId;
        this.url = url;
        this.#isInitial = isInitial;
        this.#eventManager = eventManager;
      }
      navigationInfo() {
        return {
          context: this.#browsingContextId,
          navigation: this.navigationId,
          timestamp: (0, time_js_1.getTimestamp)(),
          url: this.url
        };
      }
      start() {
        if (!this.#isInitial && !this.#started) {
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted,
            params: this.navigationInfo()
          }, this.#browsingContextId);
        }
        this.#started = true;
      }
      #finish(navigationResult) {
        this.#started = true;
        if (!this.#isInitial && !this.#finished.isFinished && navigationResult.eventName !== "browsingContext.load") {
          this.#eventManager.registerEvent({
            type: "event",
            method: navigationResult.eventName,
            params: this.navigationInfo()
          }, this.#browsingContextId);
        }
        this.#finished.resolve(navigationResult);
      }
      frameNavigated() {
        this.committed.resolve();
        if (!this.#isInitial) {
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationCommitted,
            params: this.navigationInfo()
          }, this.#browsingContextId);
        }
      }
      fragmentNavigated() {
        this.committed.resolve();
        this.#finish(new NavigationResult(
          "browsingContext.fragmentNavigated"
          /* NavigationEventName.FragmentNavigated */
        ));
      }
      load() {
        this.#finish(new NavigationResult(
          "browsingContext.load"
          /* NavigationEventName.Load */
        ));
      }
      fail(message) {
        this.#finish(new NavigationResult(this.committed.isFinished ? "browsingContext.navigationAborted" : "browsingContext.navigationFailed", message));
      }
    };
    exports.NavigationState = NavigationState;
    var NavigationTracker = class {
      #eventManager;
      #logger;
      #loaderIdToNavigationsMap = /* @__PURE__ */ new Map();
      #browsingContextId;
      #currentNavigation;
      // When a new navigation is started via `BrowsingContext.navigate` with `wait` set to
      // `None`, the command result should have `navigation` value, but mapper does not have
      // it yet. This value will be set to `navigationId` after next .
      #pendingNavigation;
      // Flags if the initial navigation to `about:blank` is in progress.
      #isInitialNavigation = true;
      constructor(url, browsingContextId, eventManager, logger) {
        this.#browsingContextId = browsingContextId;
        this.#eventManager = eventManager;
        this.#logger = logger;
        this.#isInitialNavigation = true;
        this.#currentNavigation = new NavigationState(url, browsingContextId, (0, urlHelpers_js_1.urlMatchesAboutBlank)(url), this.#eventManager);
      }
      /**
       * Returns current started ongoing navigation. It can be either a started pending
       * navigation, or one is already navigated.
       */
      get currentNavigationId() {
        if (this.#pendingNavigation?.loaderId !== void 0) {
          return this.#pendingNavigation.navigationId;
        }
        return this.#currentNavigation.navigationId;
      }
      /**
       * Flags if the current navigation relates to the initial to `about:blank` navigation.
       */
      get isInitialNavigation() {
        return this.#isInitialNavigation;
      }
      /**
       * Url of the last navigated navigation.
       */
      get url() {
        return this.#currentNavigation.url;
      }
      /**
       * Creates a pending navigation e.g. when navigation command is called. Required to
       * provide navigation id before the actual navigation is started. It will be used when
       * navigation started. Can be aborted, failed, fragment navigated, or became a current
       * navigation.
       */
      createPendingNavigation(url, canBeInitialNavigation = false) {
        this.#logger?.(log_js_1.LogType.debug, "createCommandNavigation");
        this.#isInitialNavigation = canBeInitialNavigation && this.#isInitialNavigation && (0, urlHelpers_js_1.urlMatchesAboutBlank)(url);
        this.#pendingNavigation?.fail("navigation canceled by concurrent navigation");
        const navigation = new NavigationState(url, this.#browsingContextId, this.#isInitialNavigation, this.#eventManager);
        this.#pendingNavigation = navigation;
        return navigation;
      }
      dispose() {
        this.#pendingNavigation?.fail("navigation canceled by context disposal");
        this.#currentNavigation.fail("navigation canceled by context disposal");
      }
      // Update the current url.
      onTargetInfoChanged(url) {
        this.#logger?.(log_js_1.LogType.debug, `onTargetInfoChanged ${url}`);
        this.#currentNavigation.url = url;
      }
      #getNavigationForFrameNavigated(url, loaderId) {
        if (this.#loaderIdToNavigationsMap.has(loaderId)) {
          return this.#loaderIdToNavigationsMap.get(loaderId);
        }
        if (this.#pendingNavigation !== void 0 && this.#pendingNavigation.loaderId === void 0) {
          return this.#pendingNavigation;
        }
        return this.createPendingNavigation(url, true);
      }
      /**
       * @param {string} unreachableUrl indicated the navigation is actually failed.
       */
      frameNavigated(url, loaderId, unreachableUrl) {
        this.#logger?.(log_js_1.LogType.debug, `frameNavigated ${url}`);
        if (unreachableUrl !== void 0 && !this.#loaderIdToNavigationsMap.has(loaderId)) {
          const navigation2 = this.#pendingNavigation ?? this.createPendingNavigation(unreachableUrl, true);
          navigation2.url = unreachableUrl;
          navigation2.start();
          navigation2.fail("the requested url is unreachable");
          return;
        }
        const navigation = this.#getNavigationForFrameNavigated(url, loaderId);
        if (navigation !== this.#currentNavigation) {
          this.#currentNavigation.fail("navigation canceled by concurrent navigation");
        }
        navigation.url = url;
        navigation.loaderId = loaderId;
        this.#loaderIdToNavigationsMap.set(loaderId, navigation);
        navigation.start();
        navigation.frameNavigated();
        this.#currentNavigation = navigation;
        if (this.#pendingNavigation === navigation) {
          this.#pendingNavigation = void 0;
        }
      }
      navigatedWithinDocument(url, navigationType) {
        this.#logger?.(log_js_1.LogType.debug, `navigatedWithinDocument ${url}, ${navigationType}`);
        this.#currentNavigation.url = url;
        if (navigationType !== "fragment") {
          return;
        }
        const fragmentNavigation = this.#pendingNavigation !== void 0 && this.#pendingNavigation.loaderId === void 0 ? this.#pendingNavigation : new NavigationState(url, this.#browsingContextId, false, this.#eventManager);
        fragmentNavigation.fragmentNavigated();
        if (fragmentNavigation === this.#pendingNavigation) {
          this.#pendingNavigation = void 0;
        }
      }
      frameRequestedNavigation(url) {
        this.#logger?.(log_js_1.LogType.debug, `Page.frameRequestedNavigation ${url}`);
        this.createPendingNavigation(url, true);
      }
      /**
       * Required to mark navigation as fully complete.
       * TODO: navigation should be complete when it became the current one on
       * `Page.frameNavigated` or on navigating command finished with a new loader Id.
       */
      loadPageEvent(loaderId) {
        this.#logger?.(log_js_1.LogType.debug, "loadPageEvent");
        this.#isInitialNavigation = false;
        this.#loaderIdToNavigationsMap.get(loaderId)?.load();
      }
      /**
       * Fail navigation due to navigation command failed.
       */
      failNavigation(navigation, errorText) {
        this.#logger?.(log_js_1.LogType.debug, "failCommandNavigation");
        navigation.fail(errorText);
      }
      /**
       * Updates the navigation's `loaderId` and sets it as current one, if it is a
       * cross-document navigation.
       */
      navigationCommandFinished(navigation, loaderId) {
        this.#logger?.(log_js_1.LogType.debug, `finishCommandNavigation ${navigation.navigationId}, ${loaderId}`);
        if (loaderId !== void 0) {
          navigation.loaderId = loaderId;
          this.#loaderIdToNavigationsMap.set(loaderId, navigation);
        }
        navigation.isFragmentNavigation = loaderId === void 0;
        if (loaderId === void 0 || this.#currentNavigation === navigation) {
          return;
        }
        this.#currentNavigation.fail("navigation canceled by concurrent navigation");
        navigation.start();
        this.#currentNavigation = navigation;
        if (this.#pendingNavigation === navigation) {
          this.#pendingNavigation = void 0;
        }
      }
      /**
       * Emulated event, tight to `Network.requestWillBeSent`.
       */
      frameStartedNavigating(url, loaderId) {
        this.#logger?.(log_js_1.LogType.debug, `frameStartedNavigating ${url}, ${loaderId}`);
        if (this.#loaderIdToNavigationsMap.has(loaderId)) {
          return;
        }
        const pendingNavigation = this.#pendingNavigation ?? this.createPendingNavigation(url, true);
        pendingNavigation.url = url;
        pendingNavigation.start();
        pendingNavigation.loaderId = loaderId;
        this.#loaderIdToNavigationsMap.set(loaderId, pendingNavigation);
      }
      /**
       * In case of `beforeunload` handler, the pending navigation should be marked as started
       * for consistency, as the `browsingContext.navigationStarted` should be emitted before
       * user prompt.
       */
      beforeunload() {
        this.#logger?.(log_js_1.LogType.debug, `beforeunload`);
        if (this.#pendingNavigation === void 0) {
          this.#logger?.(log_js_1.LogType.debugError, `Unexpectedly no pending navigation on beforeunload`);
          return;
        }
        this.#pendingNavigation.start();
      }
      /**
       * If there is a navigation with the loaderId equals to the network request id, it means
       * that the navigation failed.
       */
      networkLoadingFailed(loaderId, errorText) {
        this.#loaderIdToNavigationsMap.get(loaderId)?.fail(errorText);
      }
    };
    exports.NavigationTracker = NavigationTracker;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js
var require_BrowsingContextImpl = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js"(exports) {
    "use strict";
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowsingContextImpl = void 0;
    exports.serializeOrigin = serializeOrigin;
    var protocol_js_1 = require_protocol();
    var assert_js_1 = require_assert();
    var Deferred_js_1 = require_Deferred();
    var log_js_1 = require_log();
    var time_js_1 = require_time();
    var unitConversions_js_1 = require_unitConversions();
    var WindowRealm_js_1 = require_WindowRealm();
    var NavigationTracker_js_1 = require_NavigationTracker();
    var _children, _id, _loaderId, _parentId, _previousViewport, _originalOpener, _lifecycle, _cdpTarget, _defaultRealmDeferred, _browsingContextStorage, _eventManager, _logger, _navigationTracker, _realmStorage, _unhandledPromptBehavior, _lastUserPromptType, _deleteAllChildren, deleteAllChildren_fn, _initListeners, initListeners_fn, _getPromptType, getPromptType_fn, _getPromptHandler, getPromptHandler_fn, _documentChanged, documentChanged_fn, _resetLifecycleIfFinished, resetLifecycleIfFinished_fn, _failLifecycleIfNotFinished, failLifecycleIfNotFinished_fn, _waitNavigation, waitNavigation_fn, _parseRect, parseRect_fn, _getLocatorDelegate, getLocatorDelegate_fn, _locateNodesByLocator, locateNodesByLocator_fn;
    var BrowsingContextImpl = class {
      constructor(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger) {
        __privateAdd(this, _deleteAllChildren);
        __privateAdd(this, _initListeners);
        __privateAdd(this, _getPromptHandler);
        __privateAdd(this, _documentChanged);
        __privateAdd(this, _resetLifecycleIfFinished);
        __privateAdd(this, _failLifecycleIfNotFinished);
        __privateAdd(this, _waitNavigation);
        /**
         * See
         * https://w3c.github.io/webdriver-bidi/#:~:text=If%20command%20parameters%20contains%20%22clip%22%3A
         */
        __privateAdd(this, _parseRect);
        __privateAdd(this, _getLocatorDelegate);
        __privateAdd(this, _locateNodesByLocator);
        /** Direct children browsing contexts. */
        __privateAdd(this, _children, /* @__PURE__ */ new Set());
        /** The ID of this browsing context. */
        __privateAdd(this, _id, void 0);
        __publicField(this, "userContext");
        /**
         * The ID of the parent browsing context.
         * If null, this is a top-level context.
         */
        __privateAdd(this, _loaderId, void 0);
        __privateAdd(this, _parentId, null);
        // Keeps track of the previously set viewport.
        __privateAdd(this, _previousViewport, { width: 0, height: 0 });
        __privateAdd(this, _originalOpener, void 0);
        __privateAdd(this, _lifecycle, {
          DOMContentLoaded: new Deferred_js_1.Deferred(),
          load: new Deferred_js_1.Deferred()
        });
        __privateAdd(this, _cdpTarget, void 0);
        __privateAdd(this, _defaultRealmDeferred, new Deferred_js_1.Deferred());
        __privateAdd(this, _browsingContextStorage, void 0);
        __privateAdd(this, _eventManager, void 0);
        __privateAdd(this, _logger, void 0);
        __privateAdd(this, _navigationTracker, void 0);
        __privateAdd(this, _realmStorage, void 0);
        // The deferred will be resolved when the default realm is created.
        __privateAdd(this, _unhandledPromptBehavior, void 0);
        // Set when the user prompt is opened. Required to provide the type in closing event.
        __privateAdd(this, _lastUserPromptType, void 0);
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateSet(this, _id, id);
        __privateSet(this, _parentId, parentId);
        this.userContext = userContext;
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _unhandledPromptBehavior, unhandledPromptBehavior);
        __privateSet(this, _logger, logger);
        __privateSet(this, _originalOpener, originalOpener);
        __privateSet(this, _navigationTracker, new NavigationTracker_js_1.NavigationTracker(url, id, eventManager, logger));
      }
      static create(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger) {
        var _a4;
        const context2 = new _a3(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger);
        __privateMethod(_a4 = context2, _initListeners, initListeners_fn).call(_a4);
        browsingContextStorage.addContext(context2);
        if (!context2.isTopLevelContext()) {
          context2.parent.addChild(context2.id);
        }
        eventManager.registerPromiseEvent(context2.targetUnblockedOrThrow().then(() => {
          return {
            kind: "success",
            value: {
              type: "event",
              method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
              params: {
                ...context2.serializeToBidiValue(),
                // Hack to provide the initial URL of the context, as it can be changed
                // between the page target is attached and unblocked, as the page is not
                // fully paused in MPArch session (https://crbug.com/372842894).
                // TODO: remove once https://crbug.com/372842894 is addressed.
                url
              }
            }
          };
        }, (error) => {
          return {
            kind: "error",
            error
          };
        }), context2.id, protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated);
        return context2;
      }
      /**
       * @see https://html.spec.whatwg.org/multipage/document-sequences.html#navigable
       */
      get navigableId() {
        return __privateGet(this, _loaderId);
      }
      get navigationId() {
        return __privateGet(this, _navigationTracker).currentNavigationId;
      }
      dispose(emitContextDestroyed) {
        __privateGet(this, _navigationTracker).dispose();
        __privateGet(this, _realmStorage).deleteRealms({
          browsingContextId: this.id
        });
        if (!this.isTopLevelContext()) {
          __privateGet(this.parent, _children).delete(this.id);
        }
        __privateMethod(this, _failLifecycleIfNotFinished, failLifecycleIfNotFinished_fn).call(this);
        if (emitContextDestroyed) {
          __privateGet(this, _eventManager).registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextDestroyed,
            params: this.serializeToBidiValue(null)
          }, this.id);
        }
        __privateMethod(this, _deleteAllChildren, deleteAllChildren_fn).call(this);
        __privateGet(this, _eventManager).clearBufferedEvents(this.id);
        __privateGet(this, _browsingContextStorage).deleteContextById(this.id);
      }
      /** Returns the ID of this context. */
      get id() {
        return __privateGet(this, _id);
      }
      /** Returns the parent context ID. */
      get parentId() {
        return __privateGet(this, _parentId);
      }
      /** Sets the parent context ID and updates parent's children. */
      set parentId(parentId) {
        var _a4;
        if (__privateGet(this, _parentId) !== null) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, "Parent context already set");
          return;
        }
        __privateSet(this, _parentId, parentId);
        if (!this.isTopLevelContext()) {
          this.parent.addChild(this.id);
        }
      }
      /** Returns the parent context. */
      get parent() {
        if (this.parentId === null) {
          return null;
        }
        return __privateGet(this, _browsingContextStorage).getContext(this.parentId);
      }
      /** Returns all direct children contexts. */
      get directChildren() {
        return [...__privateGet(this, _children)].map((id) => __privateGet(this, _browsingContextStorage).getContext(id));
      }
      /** Returns all children contexts, flattened. */
      get allChildren() {
        const children = this.directChildren;
        return children.concat(...children.map((child) => child.allChildren));
      }
      /**
       * Returns true if this is a top-level context.
       * This is the case whenever the parent context ID is null.
       */
      isTopLevelContext() {
        return __privateGet(this, _parentId) === null;
      }
      get top() {
        let topContext = this;
        let parent = topContext.parent;
        while (parent) {
          topContext = parent;
          parent = topContext.parent;
        }
        return topContext;
      }
      addChild(childId) {
        __privateGet(this, _children).add(childId);
      }
      get cdpTarget() {
        return __privateGet(this, _cdpTarget);
      }
      updateCdpTarget(cdpTarget) {
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateMethod(this, _initListeners, initListeners_fn).call(this);
      }
      get url() {
        return __privateGet(this, _navigationTracker).url;
      }
      async lifecycleLoaded() {
        await __privateGet(this, _lifecycle).load;
      }
      async targetUnblockedOrThrow() {
        const result = await __privateGet(this, _cdpTarget).unblocked;
        if (result.kind === "error") {
          throw result.error;
        }
      }
      async getOrCreateSandbox(sandbox) {
        if (sandbox === void 0 || sandbox === "") {
          return await __privateGet(this, _defaultRealmDeferred);
        }
        let maybeSandboxes = __privateGet(this, _realmStorage).findRealms({
          browsingContextId: this.id,
          sandbox
        });
        if (maybeSandboxes.length === 0) {
          await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.createIsolatedWorld", {
            frameId: this.id,
            worldName: sandbox
          });
          maybeSandboxes = __privateGet(this, _realmStorage).findRealms({
            browsingContextId: this.id,
            sandbox
          });
          (0, assert_js_1.assert)(maybeSandboxes.length !== 0);
        }
        return maybeSandboxes[0];
      }
      /**
       * Implements https://w3c.github.io/webdriver-bidi/#get-the-navigable-info.
       */
      serializeToBidiValue(maxDepth = 0, addParentField = true) {
        return {
          context: __privateGet(this, _id),
          url: this.url,
          userContext: this.userContext,
          originalOpener: __privateGet(this, _originalOpener) ?? null,
          // TODO(#2646): Implement Client Window correctly
          clientWindow: "",
          children: maxDepth === null || maxDepth > 0 ? this.directChildren.map((c) => c.serializeToBidiValue(maxDepth === null ? maxDepth : maxDepth - 1, false)) : null,
          ...addParentField ? { parent: __privateGet(this, _parentId) } : {}
        };
      }
      onTargetInfoChanged(params) {
        __privateGet(this, _navigationTracker).onTargetInfoChanged(params.targetInfo.url);
      }
      async navigate(url, wait) {
        try {
          new URL(url);
        } catch {
          throw new protocol_js_1.InvalidArgumentException(`Invalid URL: ${url}`);
        }
        const navigationState = __privateGet(this, _navigationTracker).createPendingNavigation(url);
        const cdpNavigatePromise = (async () => {
          const cdpNavigateResult = await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.navigate", {
            url,
            frameId: this.id
          });
          if (cdpNavigateResult.errorText) {
            __privateGet(this, _navigationTracker).failNavigation(navigationState, cdpNavigateResult.errorText);
            throw new protocol_js_1.UnknownErrorException(cdpNavigateResult.errorText);
          }
          __privateGet(this, _navigationTracker).navigationCommandFinished(navigationState, cdpNavigateResult.loaderId);
          __privateMethod(this, _documentChanged, documentChanged_fn).call(this, cdpNavigateResult.loaderId);
        })();
        const result = await Promise.race([
          // No `loaderId` means same-document navigation.
          __privateMethod(this, _waitNavigation, waitNavigation_fn).call(this, wait, cdpNavigatePromise, navigationState),
          // Throw an error if the navigation is canceled.
          navigationState.finished
        ]);
        if (result instanceof NavigationTracker_js_1.NavigationResult) {
          if (
            // TODO: check after decision on the spec is done:
            //  https://github.com/w3c/webdriver-bidi/issues/799.
            result.eventName === "browsingContext.navigationAborted" || result.eventName === "browsingContext.navigationFailed"
          ) {
            throw new protocol_js_1.UnknownErrorException(result.message ?? "unknown exception");
          }
        }
        return {
          navigation: navigationState.navigationId,
          // Url can change due to redirects. Get the one from commandNavigation.
          url: navigationState.url
        };
      }
      // TODO: support concurrent navigations analogous to `navigate`.
      async reload(ignoreCache, wait) {
        await this.targetUnblockedOrThrow();
        __privateMethod(this, _resetLifecycleIfFinished, resetLifecycleIfFinished_fn).call(this);
        const navigationState = __privateGet(this, _navigationTracker).createPendingNavigation(__privateGet(this, _navigationTracker).url);
        const cdpReloadPromise = __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.reload", {
          ignoreCache
        });
        const result = await Promise.race([
          // No `loaderId` means same-document navigation.
          __privateMethod(this, _waitNavigation, waitNavigation_fn).call(this, wait, cdpReloadPromise, navigationState),
          // Throw an error if the navigation is canceled.
          navigationState.finished
        ]);
        if (result instanceof NavigationTracker_js_1.NavigationResult) {
          if (result.eventName === "browsingContext.navigationAborted" || result.eventName === "browsingContext.navigationFailed") {
            throw new protocol_js_1.UnknownErrorException(result.message ?? "unknown exception");
          }
        }
        return {
          navigation: navigationState.navigationId,
          // Url can change due to redirects. Get the one from commandNavigation.
          url: navigationState.url
        };
      }
      async setViewport(viewport, devicePixelRatio) {
        if (viewport === null && devicePixelRatio === null) {
          await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Emulation.clearDeviceMetricsOverride");
        } else {
          try {
            let appliedViewport;
            if (viewport === void 0) {
              appliedViewport = __privateGet(this, _previousViewport);
            } else if (viewport === null) {
              appliedViewport = {
                width: 0,
                height: 0
              };
            } else {
              appliedViewport = viewport;
            }
            __privateSet(this, _previousViewport, appliedViewport);
            await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Emulation.setDeviceMetricsOverride", {
              width: __privateGet(this, _previousViewport).width,
              height: __privateGet(this, _previousViewport).height,
              deviceScaleFactor: devicePixelRatio ? devicePixelRatio : 0,
              mobile: false,
              dontSetVisibleSize: true
            });
          } catch (err) {
            if (err.message.startsWith(
              // https://crsrc.org/c/content/browser/devtools/protocol/emulation_handler.cc;l=257;drc=2f6eee84cf98d4227e7c41718dd71b82f26d90ff
              "Width and height values must be positive"
            )) {
              throw new protocol_js_1.UnsupportedOperationException("Provided viewport dimensions are not supported");
            }
            throw err;
          }
        }
      }
      async handleUserPrompt(accept, userText) {
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.handleJavaScriptDialog", {
          accept: accept ?? true,
          promptText: userText
        });
      }
      async activate() {
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.bringToFront");
      }
      async captureScreenshot(params) {
        if (!this.isTopLevelContext()) {
          throw new protocol_js_1.UnsupportedOperationException(`Non-top-level 'context' (${params.context}) is currently not supported`);
        }
        const formatParameters = getImageFormatParameters(params);
        let captureBeyondViewport = false;
        let script;
        params.origin ??= "viewport";
        switch (params.origin) {
          case "document": {
            script = String(() => {
              const element = document.documentElement;
              return {
                x: 0,
                y: 0,
                width: element.scrollWidth,
                height: element.scrollHeight
              };
            });
            captureBeyondViewport = true;
            break;
          }
          case "viewport": {
            script = String(() => {
              const viewport = window.visualViewport;
              return {
                x: viewport.pageLeft,
                y: viewport.pageTop,
                width: viewport.width,
                height: viewport.height
              };
            });
            break;
          }
        }
        const realm = await this.getOrCreateSandbox(void 0);
        const originResult = await realm.callFunction(script, false);
        (0, assert_js_1.assert)(originResult.type === "success");
        const origin = deserializeDOMRect(originResult.result);
        (0, assert_js_1.assert)(origin);
        let rect = origin;
        if (params.clip) {
          const clip = params.clip;
          if (params.origin === "viewport" && clip.type === "box") {
            clip.x += origin.x;
            clip.y += origin.y;
          }
          rect = getIntersectionRect2(await __privateMethod(this, _parseRect, parseRect_fn).call(this, clip), origin);
        }
        if (rect.width === 0 || rect.height === 0) {
          throw new protocol_js_1.UnableToCaptureScreenException(`Unable to capture screenshot with zero dimensions: width=${rect.width}, height=${rect.height}`);
        }
        return await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.captureScreenshot", {
          clip: { ...rect, scale: 1 },
          ...formatParameters,
          captureBeyondViewport
        });
      }
      async print(params) {
        if (!this.isTopLevelContext()) {
          throw new protocol_js_1.UnsupportedOperationException("Printing of non-top level contexts is not supported");
        }
        const cdpParams = {};
        if (params.background !== void 0) {
          cdpParams.printBackground = params.background;
        }
        if (params.margin?.bottom !== void 0) {
          cdpParams.marginBottom = (0, unitConversions_js_1.inchesFromCm)(params.margin.bottom);
        }
        if (params.margin?.left !== void 0) {
          cdpParams.marginLeft = (0, unitConversions_js_1.inchesFromCm)(params.margin.left);
        }
        if (params.margin?.right !== void 0) {
          cdpParams.marginRight = (0, unitConversions_js_1.inchesFromCm)(params.margin.right);
        }
        if (params.margin?.top !== void 0) {
          cdpParams.marginTop = (0, unitConversions_js_1.inchesFromCm)(params.margin.top);
        }
        if (params.orientation !== void 0) {
          cdpParams.landscape = params.orientation === "landscape";
        }
        if (params.page?.height !== void 0) {
          cdpParams.paperHeight = (0, unitConversions_js_1.inchesFromCm)(params.page.height);
        }
        if (params.page?.width !== void 0) {
          cdpParams.paperWidth = (0, unitConversions_js_1.inchesFromCm)(params.page.width);
        }
        if (params.pageRanges !== void 0) {
          for (const range of params.pageRanges) {
            if (typeof range === "number") {
              continue;
            }
            const rangeParts = range.split("-");
            if (rangeParts.length < 1 || rangeParts.length > 2) {
              throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${range} is not a valid integer range.`);
            }
            if (rangeParts.length === 1) {
              void parseInteger(rangeParts[0] ?? "");
              continue;
            }
            let lowerBound;
            let upperBound;
            const [rangeLowerPart = "", rangeUpperPart = ""] = rangeParts;
            if (rangeLowerPart === "") {
              lowerBound = 1;
            } else {
              lowerBound = parseInteger(rangeLowerPart);
            }
            if (rangeUpperPart === "") {
              upperBound = Number.MAX_SAFE_INTEGER;
            } else {
              upperBound = parseInteger(rangeUpperPart);
            }
            if (lowerBound > upperBound) {
              throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${rangeLowerPart} > ${rangeUpperPart}`);
            }
          }
          cdpParams.pageRanges = params.pageRanges.join(",");
        }
        if (params.scale !== void 0) {
          cdpParams.scale = params.scale;
        }
        if (params.shrinkToFit !== void 0) {
          cdpParams.preferCSSPageSize = !params.shrinkToFit;
        }
        try {
          const result = await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.printToPDF", cdpParams);
          return {
            data: result.data
          };
        } catch (error) {
          if (error.message === "invalid print parameters: content area is empty") {
            throw new protocol_js_1.UnsupportedOperationException(error.message);
          }
          throw error;
        }
      }
      async close() {
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.close");
      }
      async traverseHistory(delta) {
        if (delta === 0) {
          return;
        }
        const history = await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.getNavigationHistory");
        const entry = history.entries[history.currentIndex + delta];
        if (!entry) {
          throw new protocol_js_1.NoSuchHistoryEntryException(`No history entry at delta ${delta}`);
        }
        await __privateGet(this, _cdpTarget).cdpClient.sendCommand("Page.navigateToHistoryEntry", {
          entryId: entry.id
        });
      }
      async toggleModulesIfNeeded() {
        await Promise.all([
          __privateGet(this, _cdpTarget).toggleNetworkIfNeeded(),
          __privateGet(this, _cdpTarget).toggleDeviceAccessIfNeeded()
        ]);
      }
      async locateNodes(params) {
        return await __privateMethod(this, _locateNodesByLocator, locateNodesByLocator_fn).call(this, await __privateGet(this, _defaultRealmDeferred), params.locator, params.startNodes ?? [], params.maxNodeCount, params.serializationOptions);
      }
    };
    _children = new WeakMap();
    _id = new WeakMap();
    _loaderId = new WeakMap();
    _parentId = new WeakMap();
    _previousViewport = new WeakMap();
    _originalOpener = new WeakMap();
    _lifecycle = new WeakMap();
    _cdpTarget = new WeakMap();
    _defaultRealmDeferred = new WeakMap();
    _browsingContextStorage = new WeakMap();
    _eventManager = new WeakMap();
    _logger = new WeakMap();
    _navigationTracker = new WeakMap();
    _realmStorage = new WeakMap();
    _unhandledPromptBehavior = new WeakMap();
    _lastUserPromptType = new WeakMap();
    _deleteAllChildren = new WeakSet();
    deleteAllChildren_fn = function(emitContextDestroyed = false) {
      this.directChildren.map((child) => child.dispose(emitContextDestroyed));
    };
    _initListeners = new WeakSet();
    initListeners_fn = function() {
      __privateGet(this, _cdpTarget).cdpClient.on("Network.loadingFailed", (params) => {
        __privateGet(this, _navigationTracker).networkLoadingFailed(params.requestId, params.errorText);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.frameNavigated", (params) => {
        if (this.id !== params.frame.id) {
          return;
        }
        __privateGet(this, _navigationTracker).frameNavigated(
          params.frame.url + (params.frame.urlFragment ?? ""),
          params.frame.loaderId,
          // `unreachableUrl` indicates if the navigation failed.
          params.frame.unreachableUrl
        );
        __privateMethod(this, _deleteAllChildren, deleteAllChildren_fn).call(this);
        __privateMethod(this, _documentChanged, documentChanged_fn).call(this, params.frame.loaderId);
      });
      __privateGet(this, _cdpTarget).on("frameStartedNavigating", (params) => {
        var _a4;
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugInfo, `Received ${"frameStartedNavigating"} event`, params);
        const possibleFrameIds = [
          this.id,
          ...this.cdpTarget.id === this.id ? [void 0] : []
        ];
        if (!possibleFrameIds.includes(params.frameId)) {
          return;
        }
        __privateGet(this, _navigationTracker).frameStartedNavigating(params.url, params.loaderId);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.navigatedWithinDocument", (params) => {
        if (this.id !== params.frameId) {
          return;
        }
        __privateGet(this, _navigationTracker).navigatedWithinDocument(params.url, params.navigationType);
        if (params.navigationType === "historyApi") {
          __privateGet(this, _eventManager).registerEvent({
            type: "event",
            method: "browsingContext.historyUpdated",
            params: {
              context: this.id,
              url: __privateGet(this, _navigationTracker).url
            }
          }, this.id);
          return;
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.frameRequestedNavigation", (params) => {
        if (this.id !== params.frameId) {
          return;
        }
        __privateGet(this, _navigationTracker).frameRequestedNavigation(params.url);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.lifecycleEvent", (params) => {
        if (this.id !== params.frameId) {
          return;
        }
        if (params.name === "init") {
          __privateMethod(this, _documentChanged, documentChanged_fn).call(this, params.loaderId);
          return;
        }
        if (params.name === "commit") {
          __privateSet(this, _loaderId, params.loaderId);
          return;
        }
        if (!__privateGet(this, _loaderId)) {
          __privateSet(this, _loaderId, params.loaderId);
        }
        if (params.loaderId !== __privateGet(this, _loaderId)) {
          return;
        }
        switch (params.name) {
          case "DOMContentLoaded":
            if (!__privateGet(this, _navigationTracker).isInitialNavigation) {
              __privateGet(this, _eventManager).registerEvent({
                type: "event",
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.DomContentLoaded,
                params: {
                  context: this.id,
                  navigation: __privateGet(this, _navigationTracker).currentNavigationId,
                  timestamp: (0, time_js_1.getTimestamp)(),
                  url: __privateGet(this, _navigationTracker).url
                }
              }, this.id);
            }
            __privateGet(this, _lifecycle).DOMContentLoaded.resolve();
            break;
          case "load":
            if (!__privateGet(this, _navigationTracker).isInitialNavigation) {
              __privateGet(this, _eventManager).registerEvent({
                type: "event",
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.Load,
                params: {
                  context: this.id,
                  navigation: __privateGet(this, _navigationTracker).currentNavigationId,
                  timestamp: (0, time_js_1.getTimestamp)(),
                  url: __privateGet(this, _navigationTracker).url
                }
              }, this.id);
            }
            __privateGet(this, _navigationTracker).loadPageEvent(params.loaderId);
            __privateGet(this, _lifecycle).load.resolve();
            break;
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.executionContextCreated", (params) => {
        var _a4;
        const { auxData, name, uniqueId, id } = params.context;
        if (!auxData || auxData.frameId !== this.id) {
          return;
        }
        let origin;
        let sandbox;
        switch (auxData.type) {
          case "isolated":
            sandbox = name;
            if (!__privateGet(this, _defaultRealmDeferred).isFinished) {
              (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, "Unexpectedly, isolated realm created before the default one");
            }
            origin = __privateGet(this, _defaultRealmDeferred).isFinished ? __privateGet(this, _defaultRealmDeferred).result.origin : (
              // This fallback is not expected to be ever reached.
              ""
            );
            break;
          case "default":
            origin = serializeOrigin(params.context.origin);
            break;
          default:
            return;
        }
        const realm = new WindowRealm_js_1.WindowRealm(this.id, __privateGet(this, _browsingContextStorage), __privateGet(this, _cdpTarget).cdpClient, __privateGet(this, _eventManager), id, __privateGet(this, _logger), origin, uniqueId, __privateGet(this, _realmStorage), sandbox);
        if (auxData.isDefault) {
          __privateGet(this, _defaultRealmDeferred).resolve(realm);
          void Promise.all(__privateGet(this, _cdpTarget).getChannels().map((channel) => channel.startListenerFromWindow(realm, __privateGet(this, _eventManager))));
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.executionContextDestroyed", (params) => {
        if (__privateGet(this, _defaultRealmDeferred).isFinished && __privateGet(this, _defaultRealmDeferred).result.executionContextId === params.executionContextId) {
          __privateSet(this, _defaultRealmDeferred, new Deferred_js_1.Deferred());
        }
        __privateGet(this, _realmStorage).deleteRealms({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId,
          executionContextId: params.executionContextId
        });
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.executionContextsCleared", () => {
        if (!__privateGet(this, _defaultRealmDeferred).isFinished) {
          __privateGet(this, _defaultRealmDeferred).reject(new protocol_js_1.UnknownErrorException("execution contexts cleared"));
        }
        __privateSet(this, _defaultRealmDeferred, new Deferred_js_1.Deferred());
        __privateGet(this, _realmStorage).deleteRealms({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId
        });
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.javascriptDialogClosed", (params) => {
        var _a4;
        const accepted = params.result;
        if (__privateGet(this, _lastUserPromptType) === void 0) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, "Unexpectedly no opening prompt event before closing one");
        }
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptClosed,
          params: {
            context: this.id,
            accepted,
            // `lastUserPromptType` should never be undefined here, so fallback to
            // `UNKNOWN`. The fallback is required to prevent tests from hanging while
            // waiting for the closing event. The cast is required, as the `UNKNOWN` value
            // is not standard.
            type: __privateGet(this, _lastUserPromptType) ?? "UNKNOWN",
            userText: accepted && params.userInput ? params.userInput : void 0
          }
        }, this.id);
        __privateSet(this, _lastUserPromptType, void 0);
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Page.javascriptDialogOpening", (params) => {
        var _a4;
        const promptType = __privateMethod(_a4 = _a3, _getPromptType, getPromptType_fn).call(_a4, params.type);
        if (params.type === "beforeunload") {
          __privateGet(this, _navigationTracker).beforeunload();
        }
        __privateSet(this, _lastUserPromptType, promptType);
        const promptHandler = __privateMethod(this, _getPromptHandler, getPromptHandler_fn).call(this, promptType);
        __privateGet(this, _eventManager).registerEvent({
          type: "event",
          method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptOpened,
          params: {
            context: this.id,
            handler: promptHandler,
            type: promptType,
            message: params.message,
            ...params.type === "prompt" ? { defaultValue: params.defaultPrompt } : {}
          }
        }, this.id);
        switch (promptHandler) {
          case "accept":
            void this.handleUserPrompt(true);
            break;
          case "dismiss":
            void this.handleUserPrompt(false);
            break;
          case "ignore":
            break;
        }
      });
    };
    _getPromptType = new WeakSet();
    getPromptType_fn = function(cdpType) {
      switch (cdpType) {
        case "alert":
          return "alert";
        case "beforeunload":
          return "beforeunload";
        case "confirm":
          return "confirm";
        case "prompt":
          return "prompt";
      }
    };
    _getPromptHandler = new WeakSet();
    getPromptHandler_fn = function(promptType) {
      const defaultPromptHandler = "dismiss";
      switch (promptType) {
        case "alert":
          return __privateGet(this, _unhandledPromptBehavior)?.alert ?? __privateGet(this, _unhandledPromptBehavior)?.default ?? defaultPromptHandler;
        case "beforeunload":
          return __privateGet(this, _unhandledPromptBehavior)?.beforeUnload ?? __privateGet(this, _unhandledPromptBehavior)?.default ?? "accept";
        case "confirm":
          return __privateGet(this, _unhandledPromptBehavior)?.confirm ?? __privateGet(this, _unhandledPromptBehavior)?.default ?? defaultPromptHandler;
        case "prompt":
          return __privateGet(this, _unhandledPromptBehavior)?.prompt ?? __privateGet(this, _unhandledPromptBehavior)?.default ?? defaultPromptHandler;
      }
    };
    _documentChanged = new WeakSet();
    documentChanged_fn = function(loaderId) {
      if (loaderId === void 0 || __privateGet(this, _loaderId) === loaderId) {
        return;
      }
      __privateMethod(this, _resetLifecycleIfFinished, resetLifecycleIfFinished_fn).call(this);
      __privateSet(this, _loaderId, loaderId);
      __privateMethod(this, _deleteAllChildren, deleteAllChildren_fn).call(this, true);
    };
    _resetLifecycleIfFinished = new WeakSet();
    resetLifecycleIfFinished_fn = function() {
      var _a4, _b;
      if (__privateGet(this, _lifecycle).DOMContentLoaded.isFinished) {
        __privateGet(this, _lifecycle).DOMContentLoaded = new Deferred_js_1.Deferred();
      } else {
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, _a3.LOGGER_PREFIX, "Document changed (DOMContentLoaded)");
      }
      if (__privateGet(this, _lifecycle).load.isFinished) {
        __privateGet(this, _lifecycle).load = new Deferred_js_1.Deferred();
      } else {
        (_b = __privateGet(this, _logger)) == null ? void 0 : _b.call(this, _a3.LOGGER_PREFIX, "Document changed (load)");
      }
    };
    _failLifecycleIfNotFinished = new WeakSet();
    failLifecycleIfNotFinished_fn = function() {
      if (!__privateGet(this, _lifecycle).DOMContentLoaded.isFinished) {
        __privateGet(this, _lifecycle).DOMContentLoaded.reject(new protocol_js_1.UnknownErrorException("navigation canceled"));
      }
      if (!__privateGet(this, _lifecycle).load.isFinished) {
        __privateGet(this, _lifecycle).load.reject(new protocol_js_1.UnknownErrorException("navigation canceled"));
      }
    };
    _waitNavigation = new WeakSet();
    waitNavigation_fn = async function(wait, cdpCommandPromise, navigationState) {
      await Promise.all([navigationState.committed, cdpCommandPromise]);
      if (wait === "none") {
        return;
      }
      if (navigationState.isFragmentNavigation === true) {
        await navigationState.finished;
        return;
      }
      if (wait === "interactive") {
        await __privateGet(this, _lifecycle).DOMContentLoaded;
        return;
      }
      if (wait === "complete") {
        await __privateGet(this, _lifecycle).load;
        return;
      }
      throw new protocol_js_1.InvalidArgumentException(`Wait condition ${wait} is not supported`);
    };
    _parseRect = new WeakSet();
    parseRect_fn = async function(clip) {
      switch (clip.type) {
        case "box":
          return { x: clip.x, y: clip.y, width: clip.width, height: clip.height };
        case "element": {
          const sandbox = await this.getOrCreateSandbox(void 0);
          const result = await sandbox.callFunction(String((element) => {
            return element instanceof Element;
          }), false, { type: "undefined" }, [clip.element]);
          if (result.type === "exception") {
            throw new protocol_js_1.NoSuchElementException(`Element '${clip.element.sharedId}' was not found`);
          }
          (0, assert_js_1.assert)(result.result.type === "boolean");
          if (!result.result.value) {
            throw new protocol_js_1.NoSuchElementException(`Node '${clip.element.sharedId}' is not an Element`);
          }
          {
            const result2 = await sandbox.callFunction(String((element) => {
              const rect2 = element.getBoundingClientRect();
              return {
                x: rect2.x,
                y: rect2.y,
                height: rect2.height,
                width: rect2.width
              };
            }), false, { type: "undefined" }, [clip.element]);
            (0, assert_js_1.assert)(result2.type === "success");
            const rect = deserializeDOMRect(result2.result);
            if (!rect) {
              throw new protocol_js_1.UnableToCaptureScreenException(`Could not get bounding box for Element '${clip.element.sharedId}'`);
            }
            return rect;
          }
        }
      }
    };
    _getLocatorDelegate = new WeakSet();
    getLocatorDelegate_fn = async function(realm, locator, maxNodeCount, startNodes) {
      switch (locator.type) {
        case "context":
          throw new Error("Unreachable");
        case "css":
          return {
            functionDeclaration: String((cssSelector, maxNodeCount2, ...startNodes2) => {
              const locateNodesUsingCss = (element) => {
                if (!(element instanceof HTMLElement || element instanceof Document || element instanceof DocumentFragment)) {
                  throw new Error("startNodes in css selector should be HTMLElement, Document or DocumentFragment");
                }
                return [...element.querySelectorAll(cssSelector)];
              };
              startNodes2 = startNodes2.length > 0 ? startNodes2 : [document];
              const returnedNodes = startNodes2.map((startNode) => (
                // TODO: stop search early if `maxNodeCount` is reached.
                locateNodesUsingCss(startNode)
              )).flat(1);
              return maxNodeCount2 === 0 ? returnedNodes : returnedNodes.slice(0, maxNodeCount2);
            }),
            argumentsLocalValues: [
              // `cssSelector`
              { type: "string", value: locator.value },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `startNodes`
              ...startNodes
            ]
          };
        case "xpath":
          return {
            functionDeclaration: String((xPathSelector, maxNodeCount2, ...startNodes2) => {
              const evaluator = new XPathEvaluator();
              const expression = evaluator.createExpression(xPathSelector);
              const locateNodesUsingXpath = (element) => {
                const xPathResult = expression.evaluate(element, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
                const returnedNodes2 = [];
                for (let i = 0; i < xPathResult.snapshotLength; i++) {
                  returnedNodes2.push(xPathResult.snapshotItem(i));
                }
                return returnedNodes2;
              };
              startNodes2 = startNodes2.length > 0 ? startNodes2 : [document];
              const returnedNodes = startNodes2.map((startNode) => (
                // TODO: stop search early if `maxNodeCount` is reached.
                locateNodesUsingXpath(startNode)
              )).flat(1);
              return maxNodeCount2 === 0 ? returnedNodes : returnedNodes.slice(0, maxNodeCount2);
            }),
            argumentsLocalValues: [
              // `xPathSelector`
              { type: "string", value: locator.value },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `startNodes`
              ...startNodes
            ]
          };
        case "innerText":
          if (locator.value === "") {
            throw new protocol_js_1.InvalidSelectorException("innerText locator cannot be empty");
          }
          return {
            functionDeclaration: String((innerTextSelector, fullMatch, ignoreCase, maxNodeCount2, maxDepth, ...startNodes2) => {
              const searchText = ignoreCase ? innerTextSelector.toUpperCase() : innerTextSelector;
              const locateNodesUsingInnerText = (node, currentMaxDepth) => {
                const returnedNodes2 = [];
                if (node instanceof DocumentFragment || node instanceof Document) {
                  const children = [...node.children];
                  children.forEach((child) => (
                    // `currentMaxDepth` is not decremented intentionally according to
                    // https://github.com/w3c/webdriver-bidi/pull/713.
                    returnedNodes2.push(...locateNodesUsingInnerText(child, currentMaxDepth))
                  ));
                  return returnedNodes2;
                }
                if (!(node instanceof HTMLElement)) {
                  return [];
                }
                const element = node;
                const nodeInnerText = ignoreCase ? element.innerText?.toUpperCase() : element.innerText;
                if (!nodeInnerText.includes(searchText)) {
                  return [];
                }
                const childNodes = [];
                for (const child of element.children) {
                  if (child instanceof HTMLElement) {
                    childNodes.push(child);
                  }
                }
                if (childNodes.length === 0) {
                  if (fullMatch && nodeInnerText === searchText) {
                    returnedNodes2.push(element);
                  } else {
                    if (!fullMatch) {
                      returnedNodes2.push(element);
                    }
                  }
                } else {
                  const childNodeMatches = (
                    // Don't search deeper if `maxDepth` is reached.
                    currentMaxDepth <= 0 ? [] : childNodes.map((child) => locateNodesUsingInnerText(child, currentMaxDepth - 1)).flat(1)
                  );
                  if (childNodeMatches.length === 0) {
                    if (!fullMatch || nodeInnerText === searchText) {
                      returnedNodes2.push(element);
                    }
                  } else {
                    returnedNodes2.push(...childNodeMatches);
                  }
                }
                return returnedNodes2;
              };
              startNodes2 = startNodes2.length > 0 ? startNodes2 : [document];
              const returnedNodes = startNodes2.map((startNode) => (
                // TODO: stop search early if `maxNodeCount` is reached.
                locateNodesUsingInnerText(startNode, maxDepth)
              )).flat(1);
              return maxNodeCount2 === 0 ? returnedNodes : returnedNodes.slice(0, maxNodeCount2);
            }),
            argumentsLocalValues: [
              // `innerTextSelector`
              { type: "string", value: locator.value },
              // `fullMatch` with default `true`.
              { type: "boolean", value: locator.matchType !== "partial" },
              // `ignoreCase` with default `false`.
              { type: "boolean", value: locator.ignoreCase === true },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `maxDepth` with default `1000` (same as default full serialization depth).
              { type: "number", value: locator.maxDepth ?? 1e3 },
              // `startNodes`
              ...startNodes
            ]
          };
        case "accessibility": {
          if (!locator.value.name && !locator.value.role) {
            throw new protocol_js_1.InvalidSelectorException("Either name or role has to be specified");
          }
          await Promise.all([
            __privateGet(this, _cdpTarget).cdpClient.sendCommand("Accessibility.enable"),
            __privateGet(this, _cdpTarget).cdpClient.sendCommand("Accessibility.getRootAXNode")
          ]);
          const bindings = await realm.evaluate(
            /* expression=*/
            "({getAccessibleName, getAccessibleRole})",
            /* awaitPromise=*/
            false,
            "root",
            /* serializationOptions= */
            void 0,
            /* userActivation=*/
            false,
            /* includeCommandLineApi=*/
            true
          );
          if (bindings.type !== "success") {
            throw new Error("Could not get bindings");
          }
          if (bindings.result.type !== "object") {
            throw new Error("Could not get bindings");
          }
          return {
            functionDeclaration: String((name, role, bindings2, maxNodeCount2, ...startNodes2) => {
              const returnedNodes = [];
              let aborted = false;
              function collect(contextNodes, selector) {
                if (aborted) {
                  return;
                }
                for (const contextNode of contextNodes) {
                  let match = true;
                  if (selector.role) {
                    const role2 = bindings2.getAccessibleRole(contextNode);
                    if (selector.role !== role2) {
                      match = false;
                    }
                  }
                  if (selector.name) {
                    const name2 = bindings2.getAccessibleName(contextNode);
                    if (selector.name !== name2) {
                      match = false;
                    }
                  }
                  if (match) {
                    if (maxNodeCount2 !== 0 && returnedNodes.length === maxNodeCount2) {
                      aborted = true;
                      break;
                    }
                    returnedNodes.push(contextNode);
                  }
                  const childNodes = [];
                  for (const child of contextNode.children) {
                    if (child instanceof HTMLElement) {
                      childNodes.push(child);
                    }
                  }
                  collect(childNodes, selector);
                }
              }
              startNodes2 = startNodes2.length > 0 ? startNodes2 : Array.from(document.documentElement.children).filter((c) => c instanceof HTMLElement);
              collect(startNodes2, {
                role,
                name
              });
              return returnedNodes;
            }),
            argumentsLocalValues: [
              // `name`
              { type: "string", value: locator.value.name || "" },
              // `role`
              { type: "string", value: locator.value.role || "" },
              // `bindings`.
              { handle: bindings.result.handle },
              // `maxNodeCount` with `0` means no limit.
              { type: "number", value: maxNodeCount ?? 0 },
              // `startNodes`
              ...startNodes
            ]
          };
        }
      }
    };
    _locateNodesByLocator = new WeakSet();
    locateNodesByLocator_fn = async function(realm, locator, startNodes, maxNodeCount, serializationOptions) {
      var _a4;
      if (locator.type === "context") {
        if (startNodes.length !== 0) {
          throw new protocol_js_1.InvalidArgumentException("Start nodes are not supported");
        }
        const contextId = locator.value.context;
        if (!contextId) {
          throw new protocol_js_1.InvalidSelectorException("Invalid context");
        }
        const context2 = __privateGet(this, _browsingContextStorage).getContext(contextId);
        const parent = context2.parent;
        if (!parent) {
          throw new protocol_js_1.InvalidArgumentException("This context has no container");
        }
        try {
          const { backendNodeId } = await __privateGet(parent, _cdpTarget).cdpClient.sendCommand("DOM.getFrameOwner", {
            frameId: contextId
          });
          const { object } = await __privateGet(parent, _cdpTarget).cdpClient.sendCommand("DOM.resolveNode", {
            backendNodeId
          });
          const locatorResult2 = await realm.callFunction(`function () { return this; }`, false, { handle: object.objectId }, [], "none", serializationOptions);
          if (locatorResult2.type === "exception") {
            throw new Error("Unknown exception");
          }
          return { nodes: [locatorResult2.result] };
        } catch {
          throw new protocol_js_1.InvalidArgumentException("Context does not exist");
        }
      }
      const locatorDelegate = await __privateMethod(this, _getLocatorDelegate, getLocatorDelegate_fn).call(this, realm, locator, maxNodeCount, startNodes);
      serializationOptions = {
        ...serializationOptions,
        // The returned object is an array of nodes, so no need in deeper JS serialization.
        maxObjectDepth: 1
      };
      const locatorResult = await realm.callFunction(locatorDelegate.functionDeclaration, false, { type: "undefined" }, locatorDelegate.argumentsLocalValues, "none", serializationOptions);
      if (locatorResult.type !== "success") {
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, _a3.LOGGER_PREFIX, "Failed locateNodesByLocator", locatorResult);
        if (
          // CSS selector.
          locatorResult.exceptionDetails.text?.endsWith("is not a valid selector.") || // XPath selector.
          locatorResult.exceptionDetails.text?.endsWith("is not a valid XPath expression.")
        ) {
          throw new protocol_js_1.InvalidSelectorException(`Not valid selector ${typeof locator.value === "string" ? locator.value : JSON.stringify(locator.value)}`);
        }
        if (locatorResult.exceptionDetails.text === "Error: startNodes in css selector should be HTMLElement, Document or DocumentFragment") {
          throw new protocol_js_1.InvalidArgumentException("startNodes in css selector should be HTMLElement, Document or DocumentFragment");
        }
        throw new protocol_js_1.UnknownErrorException(`Unexpected error in selector script: ${locatorResult.exceptionDetails.text}`);
      }
      if (locatorResult.result.type !== "array") {
        throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result type: ${locatorResult.result.type}`);
      }
      const nodes = locatorResult.result.value.map((value) => {
        if (value.type !== "node") {
          throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result element: ${value.type}`);
        }
        return value;
      });
      return { nodes };
    };
    __privateAdd(BrowsingContextImpl, _getPromptType);
    __publicField(BrowsingContextImpl, "LOGGER_PREFIX", `${log_js_1.LogType.debug}:browsingContext`);
    exports.BrowsingContextImpl = BrowsingContextImpl;
    _a3 = BrowsingContextImpl;
    function serializeOrigin(origin) {
      if (["://", ""].includes(origin)) {
        origin = "null";
      }
      return origin;
    }
    function getImageFormatParameters(params) {
      const { quality, type } = params.format ?? {
        type: "image/png"
      };
      switch (type) {
        case "image/png": {
          return { format: "png" };
        }
        case "image/jpeg": {
          return {
            format: "jpeg",
            ...quality === void 0 ? {} : { quality: Math.round(quality * 100) }
          };
        }
        case "image/webp": {
          return {
            format: "webp",
            ...quality === void 0 ? {} : { quality: Math.round(quality * 100) }
          };
        }
      }
      throw new protocol_js_1.InvalidArgumentException(`Image format '${type}' is not a supported format`);
    }
    function deserializeDOMRect(result) {
      if (result.type !== "object" || result.value === void 0) {
        return;
      }
      const x = result.value.find(([key]) => {
        return key === "x";
      })?.[1];
      const y = result.value.find(([key]) => {
        return key === "y";
      })?.[1];
      const height = result.value.find(([key]) => {
        return key === "height";
      })?.[1];
      const width = result.value.find(([key]) => {
        return key === "width";
      })?.[1];
      if (x?.type !== "number" || y?.type !== "number" || height?.type !== "number" || width?.type !== "number") {
        return;
      }
      return {
        x: x.value,
        y: y.value,
        width: width.value,
        height: height.value
      };
    }
    function normalizeRect(box) {
      return {
        ...box.width < 0 ? {
          x: box.x + box.width,
          width: -box.width
        } : {
          x: box.x,
          width: box.width
        },
        ...box.height < 0 ? {
          y: box.y + box.height,
          height: -box.height
        } : {
          y: box.y,
          height: box.height
        }
      };
    }
    function getIntersectionRect2(first2, second) {
      first2 = normalizeRect(first2);
      second = normalizeRect(second);
      const x = Math.max(first2.x, second.x);
      const y = Math.max(first2.y, second.y);
      return {
        x,
        y,
        width: Math.max(Math.min(first2.x + first2.width, second.x + second.width) - x, 0),
        height: Math.max(Math.min(first2.y + first2.height, second.y + second.height) - y, 0)
      };
    }
    function parseInteger(value) {
      value = value.trim();
      if (!/^[0-9]+$/.test(value)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid integer: ${value}`);
      }
      return parseInt(value);
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js
var require_WorkerRealm = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkerRealm = void 0;
    var Realm_js_1 = require_Realm();
    var WorkerRealm = class extends Realm_js_1.Realm {
      #realmType;
      #ownerRealms;
      constructor(cdpClient, eventManager, executionContextId, logger, origin, ownerRealms, realmId, realmStorage, realmType) {
        super(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage);
        this.#ownerRealms = ownerRealms;
        this.#realmType = realmType;
        this.initialize();
      }
      get associatedBrowsingContexts() {
        return this.#ownerRealms.flatMap((realm) => realm.associatedBrowsingContexts);
      }
      get realmType() {
        return this.#realmType;
      }
      get source() {
        return {
          realm: this.realmId,
          // This is a hack to make Puppeteer able to track workers.
          // TODO: remove after Puppeteer tracks workers by owners and use the base version.
          context: this.associatedBrowsingContexts[0]?.id
        };
      }
      get realmInfo() {
        const owners = this.#ownerRealms.map((realm) => realm.realmId);
        const { realmType } = this;
        switch (realmType) {
          case "dedicated-worker": {
            const owner = owners[0];
            if (owner === void 0 || owners.length !== 1) {
              throw new Error("Dedicated worker must have exactly one owner");
            }
            return {
              ...this.baseInfo,
              type: realmType,
              owners: [owner]
            };
          }
          case "service-worker":
          case "shared-worker": {
            return {
              ...this.baseInfo,
              type: realmType
            };
          }
        }
      }
    };
    exports.WorkerRealm = WorkerRealm;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js
var require_logHelper = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logMessageFormatter = logMessageFormatter;
    exports.getRemoteValuesText = getRemoteValuesText;
    var assert_js_1 = require_assert();
    var specifiers = ["%s", "%d", "%i", "%f", "%o", "%O", "%c"];
    function isFormatSpecifier(str) {
      return specifiers.some((spec) => str.includes(spec));
    }
    function logMessageFormatter(args) {
      let output = "";
      const argFormat = args[0].value.toString();
      const argValues = args.slice(1, void 0);
      const tokens = argFormat.split(new RegExp(specifiers.map((spec) => `(${spec})`).join("|"), "g"));
      for (const token of tokens) {
        if (token === void 0 || token === "") {
          continue;
        }
        if (isFormatSpecifier(token)) {
          const arg = argValues.shift();
          (0, assert_js_1.assert)(arg, `Less value is provided: "${getRemoteValuesText(args, false)}"`);
          if (token === "%s") {
            output += stringFromArg(arg);
          } else if (token === "%d" || token === "%i") {
            if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
              output += parseInt(arg.value.toString(), 10);
            } else {
              output += "NaN";
            }
          } else if (token === "%f") {
            if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
              output += parseFloat(arg.value.toString());
            } else {
              output += "NaN";
            }
          } else {
            output += toJson(arg);
          }
        } else {
          output += token;
        }
      }
      if (argValues.length > 0) {
        throw new Error(`More value is provided: "${getRemoteValuesText(args, false)}"`);
      }
      return output;
    }
    function toJson(arg) {
      if (arg.type !== "array" && arg.type !== "bigint" && arg.type !== "date" && arg.type !== "number" && arg.type !== "object" && arg.type !== "string") {
        return stringFromArg(arg);
      }
      if (arg.type === "bigint") {
        return `${arg.value.toString()}n`;
      }
      if (arg.type === "number") {
        return arg.value.toString();
      }
      if (["date", "string"].includes(arg.type)) {
        return JSON.stringify(arg.value);
      }
      if (arg.type === "object") {
        return `{${arg.value.map((pair) => {
          return `${JSON.stringify(pair[0])}:${toJson(pair[1])}`;
        }).join(",")}}`;
      }
      if (arg.type === "array") {
        return `[${arg.value?.map((val) => toJson(val)).join(",") ?? ""}]`;
      }
      throw Error(`Invalid value type: ${arg}`);
    }
    function stringFromArg(arg) {
      if (!Object.hasOwn(arg, "value")) {
        return arg.type;
      }
      switch (arg.type) {
        case "string":
        case "number":
        case "boolean":
        case "bigint":
          return String(arg.value);
        case "regexp":
          return `/${arg.value.pattern}/${arg.value.flags ?? ""}`;
        case "date":
          return new Date(arg.value).toString();
        case "object":
          return `Object(${arg.value?.length ?? ""})`;
        case "array":
          return `Array(${arg.value?.length ?? ""})`;
        case "map":
          return `Map(${arg.value?.length})`;
        case "set":
          return `Set(${arg.value?.length})`;
        default:
          return arg.type;
      }
    }
    function getRemoteValuesText(args, formatText) {
      const arg = args[0];
      if (!arg) {
        return "";
      }
      if (arg.type === "string" && isFormatSpecifier(arg.value.toString()) && formatText) {
        return logMessageFormatter(args);
      }
      return args.map((arg2) => {
        return stringFromArg(arg2);
      }).join(" ");
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js
var require_LogManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js"(exports) {
    "use strict";
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogManager = void 0;
    var protocol_js_1 = require_protocol();
    var log_js_1 = require_log();
    var logHelper_js_1 = require_logHelper();
    function getBidiStackTrace(cdpStackTrace) {
      const stackFrames = cdpStackTrace?.callFrames.map((callFrame) => {
        return {
          columnNumber: callFrame.columnNumber,
          functionName: callFrame.functionName,
          lineNumber: callFrame.lineNumber,
          url: callFrame.url
        };
      });
      return stackFrames ? { callFrames: stackFrames } : void 0;
    }
    function getLogLevel(consoleApiType) {
      if (["error", "assert"].includes(consoleApiType)) {
        return "error";
      }
      if (["debug", "trace"].includes(consoleApiType)) {
        return "debug";
      }
      if (["warn", "warning"].includes(consoleApiType)) {
        return "warn";
      }
      return "info";
    }
    function getLogMethod(consoleApiType) {
      switch (consoleApiType) {
        case "warning":
          return "warn";
        case "startGroup":
          return "group";
        case "startGroupCollapsed":
          return "groupCollapsed";
        case "endGroup":
          return "groupEnd";
      }
      return consoleApiType;
    }
    var _eventManager, _realmStorage, _cdpTarget, _logger, _heuristicSerializeArg, heuristicSerializeArg_fn, _initializeEntryAddedEventListener, initializeEntryAddedEventListener_fn, _getExceptionText, getExceptionText_fn;
    var LogManager = class {
      constructor(cdpTarget, realmStorage, eventManager, logger) {
        /**
         * Heuristic serialization of CDP remote object. If possible, return the BiDi value
         * without deep serialization.
         */
        __privateAdd(this, _heuristicSerializeArg);
        __privateAdd(this, _initializeEntryAddedEventListener);
        __privateAdd(this, _eventManager, void 0);
        __privateAdd(this, _realmStorage, void 0);
        __privateAdd(this, _cdpTarget, void 0);
        __privateAdd(this, _logger, void 0);
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateSet(this, _realmStorage, realmStorage);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _logger, logger);
      }
      static create(cdpTarget, realmStorage, eventManager, logger) {
        var _a4;
        const logManager = new _a3(cdpTarget, realmStorage, eventManager, logger);
        __privateMethod(_a4 = logManager, _initializeEntryAddedEventListener, initializeEntryAddedEventListener_fn).call(_a4);
        return logManager;
      }
    };
    _eventManager = new WeakMap();
    _realmStorage = new WeakMap();
    _cdpTarget = new WeakMap();
    _logger = new WeakMap();
    _heuristicSerializeArg = new WeakSet();
    heuristicSerializeArg_fn = async function(arg, realm) {
      switch (arg.type) {
        case "undefined":
          return { type: "undefined" };
        case "boolean":
          return { type: "boolean", value: arg.value };
        case "string":
          return { type: "string", value: arg.value };
        case "number":
          return { type: "number", value: arg.unserializableValue ?? arg.value };
        case "bigint":
          if (arg.unserializableValue !== void 0 && arg.unserializableValue[arg.unserializableValue.length - 1] === "n") {
            return {
              type: arg.type,
              value: arg.unserializableValue.slice(0, -1)
            };
          }
          break;
        case "object":
          if (arg.subtype === "null") {
            return { type: "null" };
          }
          break;
        default:
          break;
      }
      return await realm.serializeCdpObject(
        arg,
        "none"
        /* Script.ResultOwnership.None */
      );
    };
    _initializeEntryAddedEventListener = new WeakSet();
    initializeEntryAddedEventListener_fn = function() {
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.consoleAPICalled", (params) => {
        var _a4;
        const realm = __privateGet(this, _realmStorage).findRealm({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId,
          executionContextId: params.executionContextId
        });
        if (realm === void 0) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.cdp, params);
          return;
        }
        const argsPromise = Promise.all(params.args.map((arg) => __privateMethod(this, _heuristicSerializeArg, heuristicSerializeArg_fn).call(this, arg, realm)));
        for (const browsingContext of realm.associatedBrowsingContexts) {
          __privateGet(this, _eventManager).registerPromiseEvent(argsPromise.then((args) => ({
            kind: "success",
            value: {
              type: "event",
              method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
              params: {
                level: getLogLevel(params.type),
                source: realm.source,
                text: (0, logHelper_js_1.getRemoteValuesText)(args, true),
                timestamp: Math.round(params.timestamp),
                stackTrace: getBidiStackTrace(params.stackTrace),
                type: "console",
                method: getLogMethod(params.type),
                args
              }
            }
          }), (error) => ({
            kind: "error",
            error
          })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
        }
      });
      __privateGet(this, _cdpTarget).cdpClient.on("Runtime.exceptionThrown", (params) => {
        var _a4, _b;
        const realm = __privateGet(this, _realmStorage).findRealm({
          cdpSessionId: __privateGet(this, _cdpTarget).cdpSessionId,
          executionContextId: params.exceptionDetails.executionContextId
        });
        if (realm === void 0) {
          (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.cdp, params);
          return;
        }
        for (const browsingContext of realm.associatedBrowsingContexts) {
          __privateGet(this, _eventManager).registerPromiseEvent(__privateMethod(_b = _a3, _getExceptionText, getExceptionText_fn).call(_b, params, realm).then((text) => ({
            kind: "success",
            value: {
              type: "event",
              method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
              params: {
                level: "error",
                source: realm.source,
                text,
                timestamp: Math.round(params.timestamp),
                stackTrace: getBidiStackTrace(params.exceptionDetails.stackTrace),
                type: "javascript"
              }
            }
          }), (error) => ({
            kind: "error",
            error
          })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
        }
      });
    };
    _getExceptionText = new WeakSet();
    getExceptionText_fn = async function(params, realm) {
      if (!params.exceptionDetails.exception) {
        return params.exceptionDetails.text;
      }
      if (realm === void 0) {
        return JSON.stringify(params.exceptionDetails.exception);
      }
      return await realm.stringifyObject(params.exceptionDetails.exception);
    };
    /**
     * Try the best to get the exception text.
     */
    __privateAdd(LogManager, _getExceptionText);
    exports.LogManager = LogManager;
    _a3 = LogManager;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js
var require_CdpTarget = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CdpTarget = void 0;
    var chromium_bidi_js_1 = require_chromium_bidi();
    var Deferred_js_1 = require_Deferred();
    var EventEmitter_js_1 = require_EventEmitter();
    var log_js_1 = require_log();
    var BrowsingContextImpl_js_1 = require_BrowsingContextImpl();
    var LogManager_js_1 = require_LogManager();
    var CdpTarget2 = class extends EventEmitter_js_1.EventEmitter {
      #id;
      #cdpClient;
      #browserCdpClient;
      #parentCdpClient;
      #realmStorage;
      #eventManager;
      #preloadScriptStorage;
      #browsingContextStorage;
      #prerenderingDisabled;
      #networkStorage;
      #unblocked = new Deferred_js_1.Deferred();
      #unhandledPromptBehavior;
      #logger;
      #deviceAccessEnabled = false;
      #cacheDisableState = false;
      #fetchDomainStages = {
        request: false,
        response: false,
        auth: false
      };
      static create(targetId, cdpClient, browserCdpClient, parentCdpClient, realmStorage, eventManager, preloadScriptStorage, browsingContextStorage, networkStorage, prerenderingDisabled, unhandledPromptBehavior, logger) {
        const cdpTarget = new CdpTarget2(targetId, cdpClient, browserCdpClient, parentCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, prerenderingDisabled, unhandledPromptBehavior, logger);
        LogManager_js_1.LogManager.create(cdpTarget, realmStorage, eventManager, logger);
        cdpTarget.#setEventListeners();
        void cdpTarget.#unblock();
        return cdpTarget;
      }
      constructor(targetId, cdpClient, browserCdpClient, parentCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, prerenderingDisabled, unhandledPromptBehavior, logger) {
        super();
        this.#id = targetId;
        this.#cdpClient = cdpClient;
        this.#browserCdpClient = browserCdpClient;
        this.#parentCdpClient = parentCdpClient;
        this.#eventManager = eventManager;
        this.#realmStorage = realmStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#networkStorage = networkStorage;
        this.#browsingContextStorage = browsingContextStorage;
        this.#prerenderingDisabled = prerenderingDisabled;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
      }
      /** Returns a deferred that resolves when the target is unblocked. */
      get unblocked() {
        return this.#unblocked;
      }
      get id() {
        return this.#id;
      }
      get cdpClient() {
        return this.#cdpClient;
      }
      get parentCdpClient() {
        return this.#parentCdpClient;
      }
      get browserCdpClient() {
        return this.#browserCdpClient;
      }
      /** Needed for CDP escape path. */
      get cdpSessionId() {
        return this.#cdpClient.sessionId;
      }
      /**
       * Enables all the required CDP domains and unblocks the target.
       */
      async #unblock() {
        try {
          await Promise.all([
            this.#cdpClient.sendCommand("Page.enable"),
            // There can be some existing frames in the target, if reconnecting to an
            // existing browser instance, e.g. via Puppeteer. Need to restore the browsing
            // contexts for the frames to correctly handle further events, like
            // `Runtime.executionContextCreated`.
            // It's important to schedule this task together with enabling domains commands to
            // prepare the tree before the events (e.g. Runtime.executionContextCreated) start
            // coming.
            // https://github.com/GoogleChromeLabs/chromium-bidi/issues/2282
            this.#cdpClient.sendCommand("Page.getFrameTree").then((frameTree) => this.#restoreFrameTreeState(frameTree.frameTree)),
            this.#cdpClient.sendCommand("Runtime.enable"),
            this.#cdpClient.sendCommand("Page.setLifecycleEventsEnabled", {
              enabled: true
            }),
            this.#cdpClient.sendCommand("Page.setPrerenderingAllowed", {
              isAllowed: !this.#prerenderingDisabled
            }).catch(() => {
            }),
            // Enabling CDP Network domain is required for navigation detection:
            // https://github.com/GoogleChromeLabs/chromium-bidi/issues/2856.
            this.#cdpClient.sendCommand("Network.enable").then(() => this.toggleNetworkIfNeeded()),
            this.#cdpClient.sendCommand("Target.setAutoAttach", {
              autoAttach: true,
              waitForDebuggerOnStart: true,
              flatten: true
            }),
            this.#initAndEvaluatePreloadScripts(),
            this.#cdpClient.sendCommand("Runtime.runIfWaitingForDebugger"),
            // Resume tab execution as well if it was paused by the debugger.
            this.#parentCdpClient.sendCommand("Runtime.runIfWaitingForDebugger"),
            this.toggleDeviceAccessIfNeeded()
          ]);
        } catch (error) {
          this.#logger?.(log_js_1.LogType.debugError, "Failed to unblock target", error);
          if (!this.#cdpClient.isCloseError(error)) {
            this.#unblocked.resolve({
              kind: "error",
              error
            });
            return;
          }
        }
        this.#unblocked.resolve({
          kind: "success",
          value: void 0
        });
      }
      #restoreFrameTreeState(frameTree) {
        const frame = frameTree.frame;
        const maybeContext = this.#browsingContextStorage.findContext(frame.id);
        if (maybeContext !== void 0) {
          if (maybeContext.parentId === null && frame.parentId !== null && frame.parentId !== void 0) {
            maybeContext.parentId = frame.parentId;
          }
        }
        if (maybeContext === void 0 && frame.parentId !== void 0) {
          const parentBrowsingContext = this.#browsingContextStorage.getContext(frame.parentId);
          BrowsingContextImpl_js_1.BrowsingContextImpl.create(frame.id, frame.parentId, parentBrowsingContext.userContext, parentBrowsingContext.cdpTarget, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, frame.url, void 0, this.#unhandledPromptBehavior, this.#logger);
        }
        frameTree.childFrames?.map((frameTree2) => this.#restoreFrameTreeState(frameTree2));
      }
      async toggleFetchIfNeeded() {
        const stages = this.#networkStorage.getInterceptionStages(this.topLevelId);
        if (this.#fetchDomainStages.request === stages.request && this.#fetchDomainStages.response === stages.response && this.#fetchDomainStages.auth === stages.auth) {
          return;
        }
        const patterns = [];
        this.#fetchDomainStages = stages;
        if (stages.request || stages.auth) {
          patterns.push({
            urlPattern: "*",
            requestStage: "Request"
          });
        }
        if (stages.response) {
          patterns.push({
            urlPattern: "*",
            requestStage: "Response"
          });
        }
        if (patterns.length) {
          await this.#cdpClient.sendCommand("Fetch.enable", {
            patterns,
            handleAuthRequests: stages.auth
          });
        } else {
          const blockedRequest = this.#networkStorage.getRequestsByTarget(this).filter((request) => request.interceptPhase);
          void Promise.allSettled(blockedRequest.map((request) => request.waitNextPhase)).then(async () => {
            const blockedRequest2 = this.#networkStorage.getRequestsByTarget(this).filter((request) => request.interceptPhase);
            if (blockedRequest2.length) {
              return await this.toggleFetchIfNeeded();
            }
            return await this.#cdpClient.sendCommand("Fetch.disable");
          }).catch((error) => {
            this.#logger?.(log_js_1.LogType.bidi, "Disable failed", error);
          });
        }
      }
      /**
       * Toggles CDP "Fetch" domain and enable/disable network cache.
       */
      async toggleNetworkIfNeeded() {
        try {
          await Promise.all([
            this.toggleSetCacheDisabled(),
            this.toggleFetchIfNeeded()
          ]);
        } catch (err) {
          this.#logger?.(log_js_1.LogType.debugError, err);
          if (!this.#isExpectedError(err)) {
            throw err;
          }
        }
      }
      async toggleSetCacheDisabled(disable) {
        const defaultCacheDisabled = this.#networkStorage.defaultCacheBehavior === "bypass";
        const cacheDisabled = disable ?? defaultCacheDisabled;
        if (this.#cacheDisableState === cacheDisabled) {
          return;
        }
        this.#cacheDisableState = cacheDisabled;
        try {
          await this.#cdpClient.sendCommand("Network.setCacheDisabled", {
            cacheDisabled
          });
        } catch (err) {
          this.#logger?.(log_js_1.LogType.debugError, err);
          this.#cacheDisableState = !cacheDisabled;
          if (!this.#isExpectedError(err)) {
            throw err;
          }
        }
      }
      async toggleDeviceAccessIfNeeded() {
        const enabled = this.isSubscribedTo(chromium_bidi_js_1.Bluetooth.EventNames.RequestDevicePromptUpdated);
        if (this.#deviceAccessEnabled === enabled) {
          return;
        }
        this.#deviceAccessEnabled = enabled;
        try {
          await this.#cdpClient.sendCommand(enabled ? "DeviceAccess.enable" : "DeviceAccess.disable");
        } catch (err) {
          this.#logger?.(log_js_1.LogType.debugError, err);
          this.#deviceAccessEnabled = !enabled;
          if (!this.#isExpectedError(err)) {
            throw err;
          }
        }
      }
      /**
       * Heuristic checking if the error is due to the session being closed. If so, ignore the
       * error.
       */
      #isExpectedError(err) {
        const error = err;
        return error.code === -32001 && error.message === "Session with given id not found." || this.#cdpClient.isCloseError(err);
      }
      #setEventListeners() {
        this.#cdpClient.on("Network.requestWillBeSent", (eventParams) => {
          if (eventParams.loaderId === eventParams.requestId) {
            this.emit("frameStartedNavigating", {
              loaderId: eventParams.loaderId,
              url: eventParams.request.url,
              frameId: eventParams.frameId
            });
          }
        });
        this.#cdpClient.on("*", (event, params) => {
          if (typeof event !== "string") {
            return;
          }
          this.#eventManager.registerEvent({
            type: "event",
            method: `goog:cdp.${event}`,
            params: {
              event,
              params,
              session: this.cdpSessionId
            }
          }, this.id);
          this.#eventManager.registerEvent({
            type: "event",
            method: `cdp.${event}`,
            params: {
              event,
              params,
              session: this.cdpSessionId
            }
          }, this.id);
        });
      }
      async #enableFetch(stages) {
        const patterns = [];
        if (stages.request || stages.auth) {
          patterns.push({
            urlPattern: "*",
            requestStage: "Request"
          });
        }
        if (stages.response) {
          patterns.push({
            urlPattern: "*",
            requestStage: "Response"
          });
        }
        if (patterns.length) {
          const oldStages = this.#fetchDomainStages;
          this.#fetchDomainStages = stages;
          try {
            await this.#cdpClient.sendCommand("Fetch.enable", {
              patterns,
              handleAuthRequests: stages.auth
            });
          } catch {
            this.#fetchDomainStages = oldStages;
          }
        }
      }
      async #disableFetch() {
        const blockedRequest = this.#networkStorage.getRequestsByTarget(this).filter((request) => request.interceptPhase);
        if (blockedRequest.length === 0) {
          this.#fetchDomainStages = {
            request: false,
            response: false,
            auth: false
          };
          await this.#cdpClient.sendCommand("Fetch.disable");
        }
      }
      async toggleNetwork() {
        const stages = this.#networkStorage.getInterceptionStages(this.topLevelId);
        const fetchEnable = Object.values(stages).some((value) => value);
        const fetchChanged = this.#fetchDomainStages.request !== stages.request || this.#fetchDomainStages.response !== stages.response || this.#fetchDomainStages.auth !== stages.auth;
        this.#logger?.(log_js_1.LogType.debugInfo, "Toggle Network", `Fetch (${fetchEnable}) ${fetchChanged}`);
        if (fetchEnable && fetchChanged) {
          await this.#enableFetch(stages);
        }
        if (!fetchEnable && fetchChanged) {
          await this.#disableFetch();
        }
      }
      /**
       * All the ProxyChannels from all the preload scripts of the given
       * BrowsingContext.
       */
      getChannels() {
        return this.#preloadScriptStorage.find().flatMap((script) => script.channels);
      }
      /** Loads all top-level preload scripts. */
      async #initAndEvaluatePreloadScripts() {
        await Promise.all(this.#preloadScriptStorage.find({
          // Needed for OOPIF
          targetId: this.topLevelId
        }).map((script) => {
          return script.initInTarget(this, true);
        }));
      }
      get topLevelId() {
        return this.#browsingContextStorage.findTopLevelContextId(this.id) ?? this.id;
      }
      isSubscribedTo(moduleOrEvent) {
        return this.#eventManager.subscriptionManager.isSubscribedTo(moduleOrEvent, this.topLevelId);
      }
    };
    exports.CdpTarget = CdpTarget2;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js
var require_CdpTargetManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CdpTargetManager = void 0;
    var log_js_1 = require_log();
    var BrowsingContextImpl_js_1 = require_BrowsingContextImpl();
    var WorkerRealm_js_1 = require_WorkerRealm();
    var CdpTarget_js_1 = require_CdpTarget();
    var cdpToBidiTargetTypes = {
      service_worker: "service-worker",
      shared_worker: "shared-worker",
      worker: "dedicated-worker"
    };
    var CdpTargetManager = class {
      #browserCdpClient;
      #cdpConnection;
      #targetKeysToBeIgnoredByAutoAttach = /* @__PURE__ */ new Set();
      #selfTargetId;
      #eventManager;
      #browsingContextStorage;
      #networkStorage;
      #bluetoothProcessor;
      #preloadScriptStorage;
      #realmStorage;
      #defaultUserContextId;
      #logger;
      #unhandledPromptBehavior;
      #prerenderingDisabled;
      constructor(cdpConnection, browserCdpClient, selfTargetId, eventManager, browsingContextStorage, realmStorage, networkStorage, bluetoothProcessor, preloadScriptStorage, defaultUserContextId, prerenderingDisabled, unhandledPromptBehavior, logger) {
        this.#cdpConnection = cdpConnection;
        this.#browserCdpClient = browserCdpClient;
        this.#targetKeysToBeIgnoredByAutoAttach.add(selfTargetId);
        this.#selfTargetId = selfTargetId;
        this.#eventManager = eventManager;
        this.#browsingContextStorage = browsingContextStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#networkStorage = networkStorage;
        this.#bluetoothProcessor = bluetoothProcessor;
        this.#realmStorage = realmStorage;
        this.#defaultUserContextId = defaultUserContextId;
        this.#prerenderingDisabled = prerenderingDisabled;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
        this.#setEventListeners(browserCdpClient);
      }
      /**
       * This method is called for each CDP session, since this class is responsible
       * for creating and destroying all targets and browsing contexts.
       */
      #setEventListeners(cdpClient) {
        cdpClient.on("Target.attachedToTarget", (params) => {
          this.#handleAttachedToTargetEvent(params, cdpClient);
        });
        cdpClient.on("Target.detachedFromTarget", this.#handleDetachedFromTargetEvent.bind(this));
        cdpClient.on("Target.targetInfoChanged", this.#handleTargetInfoChangedEvent.bind(this));
        cdpClient.on("Inspector.targetCrashed", () => {
          this.#handleTargetCrashedEvent(cdpClient);
        });
        cdpClient.on("Page.frameAttached", this.#handleFrameAttachedEvent.bind(this));
        cdpClient.on("Page.frameSubtreeWillBeDetached", this.#handleFrameSubtreeWillBeDetached.bind(this));
      }
      #handleFrameAttachedEvent(params) {
        const parentBrowsingContext = this.#browsingContextStorage.findContext(params.parentFrameId);
        if (parentBrowsingContext !== void 0) {
          BrowsingContextImpl_js_1.BrowsingContextImpl.create(
            params.frameId,
            params.parentFrameId,
            parentBrowsingContext.userContext,
            parentBrowsingContext.cdpTarget,
            this.#eventManager,
            this.#browsingContextStorage,
            this.#realmStorage,
            // At this point, we don't know the URL of the frame yet, so it will be updated
            // later.
            "about:blank",
            void 0,
            this.#unhandledPromptBehavior,
            this.#logger
          );
        }
      }
      #handleFrameSubtreeWillBeDetached(params) {
        this.#browsingContextStorage.findContext(params.frameId)?.dispose(true);
      }
      #handleAttachedToTargetEvent(params, parentSessionCdpClient) {
        const { sessionId, targetInfo } = params;
        const targetCdpClient = this.#cdpConnection.getCdpClient(sessionId);
        const detach = async () => {
          await targetCdpClient.sendCommand("Runtime.runIfWaitingForDebugger").then(() => parentSessionCdpClient.sendCommand("Target.detachFromTarget", params)).catch((error) => this.#logger?.(log_js_1.LogType.debugError, error));
        };
        if (this.#selfTargetId === targetInfo.targetId) {
          void detach();
          return;
        }
        const targetKey = targetInfo.type === "service_worker" ? `${parentSessionCdpClient.sessionId}_${targetInfo.targetId}` : targetInfo.targetId;
        if (this.#targetKeysToBeIgnoredByAutoAttach.has(targetKey)) {
          return;
        }
        this.#targetKeysToBeIgnoredByAutoAttach.add(targetKey);
        const userContext = targetInfo.browserContextId && targetInfo.browserContextId !== this.#defaultUserContextId ? targetInfo.browserContextId : "default";
        switch (targetInfo.type) {
          case "tab": {
            this.#setEventListeners(targetCdpClient);
            void (async () => {
              await targetCdpClient.sendCommand("Target.setAutoAttach", {
                autoAttach: true,
                waitForDebuggerOnStart: true,
                flatten: true
              });
            })();
            return;
          }
          case "page":
          case "iframe": {
            const cdpTarget = this.#createCdpTarget(targetCdpClient, parentSessionCdpClient, targetInfo, userContext);
            const maybeContext = this.#browsingContextStorage.findContext(targetInfo.targetId);
            if (maybeContext && targetInfo.type === "iframe") {
              maybeContext.updateCdpTarget(cdpTarget);
            } else {
              const parentId = this.#findFrameParentId(targetInfo, parentSessionCdpClient.sessionId);
              BrowsingContextImpl_js_1.BrowsingContextImpl.create(
                targetInfo.targetId,
                parentId,
                userContext,
                cdpTarget,
                this.#eventManager,
                this.#browsingContextStorage,
                this.#realmStorage,
                // Hack: when a new target created, CDP emits targetInfoChanged with an empty
                // url, and navigates it to about:blank later. When the event is emitted for
                // an existing target (reconnect), the url is already known, and navigation
                // events will not be emitted anymore. Replacing empty url with `about:blank`
                // allows to handle both cases in the same way.
                // "7.3.2.1 Creating browsing contexts".
                // https://html.spec.whatwg.org/multipage/document-sequences.html#creating-browsing-contexts
                // TODO: check who to deal with non-null creator and its `creatorOrigin`.
                targetInfo.url === "" ? "about:blank" : targetInfo.url,
                targetInfo.openerFrameId ?? targetInfo.openerId,
                this.#unhandledPromptBehavior,
                this.#logger
              );
            }
            return;
          }
          case "service_worker":
          case "worker": {
            const realm = this.#realmStorage.findRealm({
              cdpSessionId: parentSessionCdpClient.sessionId
            });
            if (!realm) {
              void detach();
              return;
            }
            const cdpTarget = this.#createCdpTarget(targetCdpClient, parentSessionCdpClient, targetInfo, userContext);
            this.#handleWorkerTarget(cdpToBidiTargetTypes[targetInfo.type], cdpTarget, realm);
            return;
          }
          case "shared_worker": {
            const cdpTarget = this.#createCdpTarget(targetCdpClient, parentSessionCdpClient, targetInfo, userContext);
            this.#handleWorkerTarget(cdpToBidiTargetTypes[targetInfo.type], cdpTarget);
            return;
          }
        }
        void detach();
      }
      /** Try to find the parent browsing context ID for the given attached target. */
      #findFrameParentId(targetInfo, parentSessionId) {
        if (targetInfo.type !== "iframe") {
          return null;
        }
        const parentId = targetInfo.openerFrameId ?? targetInfo.openerId;
        if (parentId !== void 0) {
          return parentId;
        }
        if (parentSessionId !== void 0) {
          return this.#browsingContextStorage.findContextBySession(parentSessionId)?.id ?? null;
        }
        return null;
      }
      #createCdpTarget(targetCdpClient, parentCdpClient, targetInfo, userContext) {
        this.#setEventListeners(targetCdpClient);
        this.#preloadScriptStorage.onCdpTargetCreated(targetInfo.targetId, userContext);
        const target = CdpTarget_js_1.CdpTarget.create(targetInfo.targetId, targetCdpClient, this.#browserCdpClient, parentCdpClient, this.#realmStorage, this.#eventManager, this.#preloadScriptStorage, this.#browsingContextStorage, this.#networkStorage, this.#prerenderingDisabled, this.#unhandledPromptBehavior, this.#logger);
        this.#networkStorage.onCdpTargetCreated(target);
        this.#bluetoothProcessor.onCdpTargetCreated(target);
        return target;
      }
      #workers = /* @__PURE__ */ new Map();
      #handleWorkerTarget(realmType, cdpTarget, ownerRealm) {
        cdpTarget.cdpClient.on("Runtime.executionContextCreated", (params) => {
          const { uniqueId, id, origin } = params.context;
          const workerRealm = new WorkerRealm_js_1.WorkerRealm(cdpTarget.cdpClient, this.#eventManager, id, this.#logger, (0, BrowsingContextImpl_js_1.serializeOrigin)(origin), ownerRealm ? [ownerRealm] : [], uniqueId, this.#realmStorage, realmType);
          this.#workers.set(cdpTarget.cdpSessionId, workerRealm);
        });
      }
      #handleDetachedFromTargetEvent({ sessionId, targetId }) {
        if (targetId) {
          this.#preloadScriptStorage.find({ targetId }).map((preloadScript) => {
            preloadScript.dispose(targetId);
          });
        }
        const context2 = this.#browsingContextStorage.findContextBySession(sessionId);
        if (context2) {
          context2.dispose(true);
          return;
        }
        const worker = this.#workers.get(sessionId);
        if (worker) {
          this.#realmStorage.deleteRealms({
            cdpSessionId: worker.cdpClient.sessionId
          });
        }
      }
      #handleTargetInfoChangedEvent(params) {
        const context2 = this.#browsingContextStorage.findContext(params.targetInfo.targetId);
        if (context2) {
          context2.onTargetInfoChanged(params);
        }
      }
      #handleTargetCrashedEvent(cdpClient) {
        const realms = this.#realmStorage.findRealms({
          cdpSessionId: cdpClient.sessionId
        });
        for (const realm of realms) {
          realm.dispose();
        }
      }
    };
    exports.CdpTargetManager = CdpTargetManager;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js
var require_BrowsingContextStorage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowsingContextStorage = void 0;
    var protocol_js_1 = require_protocol();
    var EventEmitter_js_1 = require_EventEmitter();
    var BrowsingContextStorage = class {
      /** Map from context ID to context implementation. */
      #contexts = /* @__PURE__ */ new Map();
      /** Event emitter for browsing context storage eventsis not expected to be exposed to
       * the outside world. */
      #eventEmitter = new EventEmitter_js_1.EventEmitter();
      /** Gets all top-level contexts, i.e. those with no parent. */
      getTopLevelContexts() {
        return this.getAllContexts().filter((context2) => context2.isTopLevelContext());
      }
      /** Gets all contexts. */
      getAllContexts() {
        return Array.from(this.#contexts.values());
      }
      /** Deletes the context with the given ID. */
      deleteContextById(id) {
        this.#contexts.delete(id);
      }
      /** Deletes the given context. */
      deleteContext(context2) {
        this.#contexts.delete(context2.id);
      }
      /** Tracks the given context. */
      addContext(context2) {
        this.#contexts.set(context2.id, context2);
        this.#eventEmitter.emit("added", {
          browsingContext: context2
        });
      }
      /**
       * Waits for a context with the given ID to be added and returns it.
       */
      waitForContext(browsingContextId) {
        if (this.#contexts.has(browsingContextId)) {
          return Promise.resolve(this.getContext(browsingContextId));
        }
        return new Promise((resolve) => {
          const listener = (event) => {
            if (event.browsingContext.id === browsingContextId) {
              this.#eventEmitter.off("added", listener);
              resolve(event.browsingContext);
            }
          };
          this.#eventEmitter.on("added", listener);
        });
      }
      /** Returns true whether there is an existing context with the given ID. */
      hasContext(id) {
        return this.#contexts.has(id);
      }
      /** Gets the context with the given ID, if any. */
      findContext(id) {
        return this.#contexts.get(id);
      }
      /** Returns the top-level context ID of the given context, if any. */
      findTopLevelContextId(id) {
        if (id === null) {
          return null;
        }
        const maybeContext = this.findContext(id);
        if (!maybeContext) {
          return null;
        }
        const parentId = maybeContext.parentId ?? null;
        if (parentId === null) {
          return id;
        }
        return this.findTopLevelContextId(parentId);
      }
      findContextBySession(sessionId) {
        for (const context2 of this.#contexts.values()) {
          if (context2.cdpTarget.cdpSessionId === sessionId) {
            return context2;
          }
        }
        return;
      }
      /** Gets the context with the given ID, if any, otherwise throws. */
      getContext(id) {
        const result = this.findContext(id);
        if (result === void 0) {
          throw new protocol_js_1.NoSuchFrameException(`Context ${id} not found`);
        }
        return result;
      }
      verifyTopLevelContextsList(contexts) {
        const foundContexts = /* @__PURE__ */ new Set();
        if (!contexts) {
          return foundContexts;
        }
        for (const contextId of contexts) {
          const context2 = this.getContext(contextId);
          if (context2.isTopLevelContext()) {
            foundContexts.add(context2);
          } else {
            throw new protocol_js_1.InvalidArgumentException(`Non top-level context '${contextId}' given.`);
          }
        }
        return foundContexts;
      }
      verifyContextsList(contexts) {
        if (!contexts.length) {
          return;
        }
        for (const contextId of contexts) {
          this.getContext(contextId);
        }
      }
    };
    exports.BrowsingContextStorage = BrowsingContextStorage;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js
var require_DefaultMap = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultMap = void 0;
    var DefaultMap = class extends Map {
      /** The default value to return whenever a key is not present in the map. */
      #getDefaultValue;
      constructor(getDefaultValue, entries) {
        super(entries);
        this.#getDefaultValue = getDefaultValue;
      }
      get(key) {
        if (!this.has(key)) {
          this.set(key, this.#getDefaultValue(key));
        }
        return super.get(key);
      }
    };
    exports.DefaultMap = DefaultMap;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js
var require_NetworkRequest = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js"(exports) {
    "use strict";
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkRequest = void 0;
    var protocol_js_1 = require_protocol();
    var assert_js_1 = require_assert();
    var DefaultMap_js_1 = require_DefaultMap();
    var Deferred_js_1 = require_Deferred();
    var log_js_1 = require_log();
    var NetworkUtils_js_1 = require_NetworkUtils();
    var REALM_REGEX = /(?<=realm=").*(?=")/;
    var _id, _fetchId, _interceptPhase, _servedFromCache, _redirectCount, _request, _requestOverrides, _responseOverrides, _response, _eventManager, _networkStorage, _cdpTarget, _logger, _emittedEvents, _isDataUrl, isDataUrl_fn, _method, method_get, _navigationId, navigationId_get, _cookies, cookies_get, _bodySize, bodySize_get, _context, context_get, _statusCode, statusCode_get, _requestHeaders, requestHeaders_get, _authChallenges, authChallenges_get, _timings, timings_get, _phaseChanged, phaseChanged_fn, _interceptsInPhase, interceptsInPhase_fn, _isBlockedInPhase, isBlockedInPhase_fn, _emitEventsIfReady, emitEventsIfReady_fn, _continueRequest, continueRequest_fn, _continueResponse, continueResponse_fn, _continueWithAuth, continueWithAuth_fn, _emitEvent, emitEvent_fn, _getBaseEventParams, getBaseEventParams_fn, _getResponseEventParams, getResponseEventParams_fn, _getRequestData, getRequestData_fn, _getDestination, getDestination_fn, _getInitiatorType, getInitiatorType_fn, _getBeforeRequestEvent, getBeforeRequestEvent_fn, _getResponseStartedEvent, getResponseStartedEvent_fn, _getResponseReceivedEvent, getResponseReceivedEvent_fn, _isIgnoredEvent, isIgnoredEvent_fn, _getOverrideHeader, getOverrideHeader_fn, _getInitiator, getInitiator_fn;
    var NetworkRequest = class {
      constructor(id, eventManager, networkStorage, cdpTarget, redirectCount = 0, logger) {
        __privateAdd(this, _isDataUrl);
        __privateAdd(this, _method);
        __privateAdd(this, _navigationId);
        __privateAdd(this, _cookies);
        __privateAdd(this, _bodySize);
        __privateAdd(this, _context);
        /** Returns the HTTP status code associated with this request if any. */
        __privateAdd(this, _statusCode);
        __privateAdd(this, _requestHeaders);
        __privateAdd(this, _authChallenges);
        __privateAdd(this, _timings);
        __privateAdd(this, _phaseChanged);
        __privateAdd(this, _interceptsInPhase);
        __privateAdd(this, _isBlockedInPhase);
        __privateAdd(this, _emitEventsIfReady);
        __privateAdd(this, _continueRequest);
        __privateAdd(this, _continueResponse);
        __privateAdd(this, _continueWithAuth);
        __privateAdd(this, _emitEvent);
        __privateAdd(this, _getBaseEventParams);
        __privateAdd(this, _getResponseEventParams);
        __privateAdd(this, _getRequestData);
        /**
         * Heuristic trying to guess the destination.
         * Specification: https://fetch.spec.whatwg.org/#concept-request-destination.
         * Specified values: "audio", "audioworklet", "document", "embed", "font", "frame",
         * "iframe", "image", "json", "manifest", "object", "paintworklet", "report", "script",
         * "serviceworker", "sharedworker", "style", "track", "video", "webidentity", "worker",
         * "xslt".
         */
        __privateAdd(this, _getDestination);
        /**
         * Heuristic trying to guess the initiator type.
         * Specification: https://fetch.spec.whatwg.org/#request-initiator-type.
         * Specified values: "audio", "beacon", "body", "css", "early-hints", "embed", "fetch",
         * "font", "frame", "iframe", "image", "img", "input", "link", "object", "ping",
         * "script", "track", "video", "xmlhttprequest", "other".
         */
        __privateAdd(this, _getInitiatorType);
        __privateAdd(this, _getBeforeRequestEvent);
        __privateAdd(this, _getResponseStartedEvent);
        __privateAdd(this, _getResponseReceivedEvent);
        __privateAdd(this, _isIgnoredEvent);
        __privateAdd(this, _getOverrideHeader);
        /**
         * Each network request has an associated request id, which is a string
         * uniquely identifying that request.
         *
         * The identifier for a request resulting from a redirect matches that of the
         * request that initiated it.
         */
        __privateAdd(this, _id, void 0);
        __privateAdd(this, _fetchId, void 0);
        /**
         * Indicates the network intercept phase, if the request is currently blocked.
         * Undefined necessarily implies that the request is not blocked.
         */
        __privateAdd(this, _interceptPhase, void 0);
        __privateAdd(this, _servedFromCache, false);
        __privateAdd(this, _redirectCount, void 0);
        __privateAdd(this, _request, {});
        __privateAdd(this, _requestOverrides, void 0);
        __privateAdd(this, _responseOverrides, void 0);
        __privateAdd(this, _response, {});
        __privateAdd(this, _eventManager, void 0);
        __privateAdd(this, _networkStorage, void 0);
        __privateAdd(this, _cdpTarget, void 0);
        __privateAdd(this, _logger, void 0);
        __privateAdd(this, _emittedEvents, {
          [protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.FetchError]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted]: false,
          [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted]: false
        });
        __publicField(this, "waitNextPhase", new Deferred_js_1.Deferred());
        __privateSet(this, _id, id);
        __privateSet(this, _eventManager, eventManager);
        __privateSet(this, _networkStorage, networkStorage);
        __privateSet(this, _cdpTarget, cdpTarget);
        __privateSet(this, _redirectCount, redirectCount);
        __privateSet(this, _logger, logger);
      }
      get id() {
        return __privateGet(this, _id);
      }
      get fetchId() {
        return __privateGet(this, _fetchId);
      }
      /**
       * When blocked returns the phase for it
       */
      get interceptPhase() {
        return __privateGet(this, _interceptPhase);
      }
      get url() {
        const fragment = __privateGet(this, _request).info?.request.urlFragment ?? __privateGet(this, _request).paused?.request.urlFragment ?? "";
        const url = __privateGet(this, _response).paused?.request.url ?? __privateGet(this, _requestOverrides)?.url ?? __privateGet(this, _response).info?.url ?? __privateGet(this, _request).auth?.request.url ?? __privateGet(this, _request).info?.request.url ?? __privateGet(this, _request).paused?.request.url ?? _a3.unknownParameter;
        return `${url}${fragment}`;
      }
      get redirectCount() {
        return __privateGet(this, _redirectCount);
      }
      get cdpTarget() {
        return __privateGet(this, _cdpTarget);
      }
      get cdpClient() {
        return __privateGet(this, _cdpTarget).cdpClient;
      }
      isRedirecting() {
        return Boolean(__privateGet(this, _request).info);
      }
      handleRedirect(event) {
        __privateGet(this, _response).hasExtraInfo = false;
        __privateGet(this, _response).info = event.redirectResponse;
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this, {
          wasRedirected: true
        });
      }
      onRequestWillBeSentEvent(event) {
        __privateGet(this, _request).info = event;
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this);
      }
      onRequestWillBeSentExtraInfoEvent(event) {
        __privateGet(this, _request).extraInfo = event;
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this);
      }
      onResponseReceivedExtraInfoEvent(event) {
        if (event.statusCode >= 300 && event.statusCode <= 399 && __privateGet(this, _request).info && event.headers["location"] === __privateGet(this, _request).info.request.url) {
          return;
        }
        __privateGet(this, _response).extraInfo = event;
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this);
      }
      onResponseReceivedEvent(event) {
        __privateGet(this, _response).hasExtraInfo = event.hasExtraInfo;
        __privateGet(this, _response).info = event.response;
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this);
      }
      onServedFromCache() {
        __privateSet(this, _servedFromCache, true);
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this);
      }
      onLoadingFailedEvent(event) {
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this, {
          hasFailed: true
        });
        __privateMethod(this, _emitEvent, emitEvent_fn).call(this, () => {
          return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.FetchError,
            params: {
              ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this),
              errorText: event.errorText
            }
          };
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest */
      async failRequest(errorReason) {
        (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
        await this.cdpClient.sendCommand("Fetch.failRequest", {
          requestId: __privateGet(this, _fetchId),
          errorReason
        });
        __privateSet(this, _interceptPhase, void 0);
      }
      onRequestPaused(event) {
        __privateSet(this, _fetchId, event.requestId);
        if (event.responseStatusCode || event.responseErrorReason) {
          __privateGet(this, _response).paused = event;
          if (__privateMethod(this, _isBlockedInPhase, isBlockedInPhase_fn).call(this, "responseStarted") && // CDP may emit multiple events for a single request
          !__privateGet(this, _emittedEvents)[protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted] && // Continue all response that have not enabled Network domain
          __privateGet(this, _fetchId) !== this.id) {
            __privateSet(this, _interceptPhase, "responseStarted");
          } else {
            void __privateMethod(this, _continueResponse, continueResponse_fn).call(this);
          }
        } else {
          __privateGet(this, _request).paused = event;
          if (__privateMethod(this, _isBlockedInPhase, isBlockedInPhase_fn).call(this, "beforeRequestSent") && // CDP may emit multiple events for a single request
          !__privateGet(this, _emittedEvents)[protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent] && // Continue all requests that have not enabled Network domain
          __privateGet(this, _fetchId) !== this.id) {
            __privateSet(this, _interceptPhase, "beforeRequestSent");
          } else {
            void __privateMethod(this, _continueRequest, continueRequest_fn).call(this);
          }
        }
        __privateMethod(this, _emitEventsIfReady, emitEventsIfReady_fn).call(this);
      }
      onAuthRequired(event) {
        __privateSet(this, _fetchId, event.requestId);
        __privateGet(this, _request).auth = event;
        if (__privateMethod(this, _isBlockedInPhase, isBlockedInPhase_fn).call(this, "authRequired") && // Continue all auth requests that have not enabled Network domain
        __privateGet(this, _fetchId) !== this.id) {
          __privateSet(this, _interceptPhase, "authRequired");
        } else {
          void __privateMethod(this, _continueWithAuth, continueWithAuth_fn).call(this, {
            response: "Default"
          });
        }
        __privateMethod(this, _emitEvent, emitEvent_fn).call(this, () => {
          return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired,
            params: {
              ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this, "authRequired"),
              response: __privateMethod(this, _getResponseEventParams, getResponseEventParams_fn).call(this)
            }
          };
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest */
      async continueRequest(overrides = {}) {
        const overrideHeaders = __privateMethod(this, _getOverrideHeader, getOverrideHeader_fn).call(this, overrides.headers, overrides.cookies);
        const headers = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
        const postData = getCdpBodyFromBiDiBytesValue(overrides.body);
        await __privateMethod(this, _continueRequest, continueRequest_fn).call(this, {
          url: overrides.url,
          method: overrides.method,
          headers,
          postData
        });
        __privateSet(this, _requestOverrides, {
          url: overrides.url,
          method: overrides.method,
          headers: overrides.headers,
          cookies: overrides.cookies,
          bodySize: getSizeFromBiDiBytesValue(overrides.body)
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse */
      async continueResponse(overrides = {}) {
        if (this.interceptPhase === "authRequired") {
          if (overrides.credentials) {
            await Promise.all([
              this.waitNextPhase,
              await __privateMethod(this, _continueWithAuth, continueWithAuth_fn).call(this, {
                response: "ProvideCredentials",
                username: overrides.credentials.username,
                password: overrides.credentials.password
              })
            ]);
          } else {
            return await __privateMethod(this, _continueWithAuth, continueWithAuth_fn).call(this, {
              response: "ProvideCredentials"
            });
          }
        }
        if (__privateGet(this, _interceptPhase) === "responseStarted") {
          const overrideHeaders = __privateMethod(this, _getOverrideHeader, getOverrideHeader_fn).call(this, overrides.headers, overrides.cookies);
          const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
          await __privateMethod(this, _continueResponse, continueResponse_fn).call(this, {
            responseCode: overrides.statusCode ?? __privateGet(this, _response).paused?.responseStatusCode,
            responsePhrase: overrides.reasonPhrase ?? __privateGet(this, _response).paused?.responseStatusText,
            responseHeaders: responseHeaders ?? __privateGet(this, _response).paused?.responseHeaders
          });
          __privateSet(this, _responseOverrides, {
            statusCode: overrides.statusCode,
            headers: overrideHeaders
          });
        }
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth */
      async continueWithAuth(authChallenge) {
        let username;
        let password;
        if (authChallenge.action === "provideCredentials") {
          const { credentials } = authChallenge;
          username = credentials.username;
          password = credentials.password;
        }
        const response = (0, NetworkUtils_js_1.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction)(authChallenge.action);
        await __privateMethod(this, _continueWithAuth, continueWithAuth_fn).call(this, {
          response,
          username,
          password
        });
      }
      /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-provideResponse */
      async provideResponse(overrides) {
        (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
        if (this.interceptPhase === "authRequired") {
          return await __privateMethod(this, _continueWithAuth, continueWithAuth_fn).call(this, {
            response: "ProvideCredentials"
          });
        }
        if (!overrides.body && !overrides.headers) {
          return await __privateMethod(this, _continueRequest, continueRequest_fn).call(this);
        }
        const overrideHeaders = __privateMethod(this, _getOverrideHeader, getOverrideHeader_fn).call(this, overrides.headers, overrides.cookies);
        const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrideHeaders);
        const responseCode = overrides.statusCode ?? __privateGet(this, _statusCode, statusCode_get) ?? 200;
        await this.cdpClient.sendCommand("Fetch.fulfillRequest", {
          requestId: __privateGet(this, _fetchId),
          responseCode,
          responsePhrase: overrides.reasonPhrase,
          responseHeaders,
          body: getCdpBodyFromBiDiBytesValue(overrides.body)
        });
        __privateSet(this, _interceptPhase, void 0);
      }
      dispose() {
        this.waitNextPhase.reject(new Error("waitNextPhase disposed"));
      }
    };
    _id = new WeakMap();
    _fetchId = new WeakMap();
    _interceptPhase = new WeakMap();
    _servedFromCache = new WeakMap();
    _redirectCount = new WeakMap();
    _request = new WeakMap();
    _requestOverrides = new WeakMap();
    _responseOverrides = new WeakMap();
    _response = new WeakMap();
    _eventManager = new WeakMap();
    _networkStorage = new WeakMap();
    _cdpTarget = new WeakMap();
    _logger = new WeakMap();
    _emittedEvents = new WeakMap();
    _isDataUrl = new WeakSet();
    isDataUrl_fn = function() {
      return this.url.startsWith("data:");
    };
    _method = new WeakSet();
    method_get = function() {
      return __privateGet(this, _requestOverrides)?.method ?? __privateGet(this, _request).info?.request.method ?? __privateGet(this, _request).paused?.request.method ?? __privateGet(this, _request).auth?.request.method ?? __privateGet(this, _response).paused?.request.method;
    };
    _navigationId = new WeakSet();
    navigationId_get = function() {
      if (!__privateGet(this, _request).info || !__privateGet(this, _request).info.loaderId || // When we navigate all CDP network events have `loaderId`
      // CDP's `loaderId` and `requestId` match when
      // that request triggered the loading
      __privateGet(this, _request).info.loaderId !== __privateGet(this, _request).info.requestId) {
        return null;
      }
      return __privateGet(this, _networkStorage).getNavigationId(__privateGet(this, _context, context_get) ?? void 0);
    };
    _cookies = new WeakSet();
    cookies_get = function() {
      let cookies = [];
      if (__privateGet(this, _request).extraInfo) {
        cookies = __privateGet(this, _request).extraInfo.associatedCookies.filter(({ blockedReasons }) => {
          return !Array.isArray(blockedReasons) || blockedReasons.length === 0;
        }).map(({ cookie }) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(cookie));
      }
      return cookies;
    };
    _bodySize = new WeakSet();
    bodySize_get = function() {
      let bodySize = 0;
      if (typeof __privateGet(this, _requestOverrides)?.bodySize === "number") {
        bodySize = __privateGet(this, _requestOverrides).bodySize;
      } else {
        bodySize = (0, NetworkUtils_js_1.bidiBodySizeFromCdpPostDataEntries)(__privateGet(this, _request).info?.request.postDataEntries ?? []);
      }
      return bodySize;
    };
    _context = new WeakSet();
    context_get = function() {
      return __privateGet(this, _response).paused?.frameId ?? __privateGet(this, _request).info?.frameId ?? __privateGet(this, _request).paused?.frameId ?? __privateGet(this, _request).auth?.frameId ?? null;
    };
    _statusCode = new WeakSet();
    statusCode_get = function() {
      return __privateGet(this, _responseOverrides)?.statusCode ?? __privateGet(this, _response).paused?.responseStatusCode ?? __privateGet(this, _response).extraInfo?.statusCode ?? __privateGet(this, _response).info?.status;
    };
    _requestHeaders = new WeakSet();
    requestHeaders_get = function() {
      let headers = [];
      if (__privateGet(this, _requestOverrides)?.headers) {
        const headerMap = new DefaultMap_js_1.DefaultMap(() => []);
        for (const header of __privateGet(this, _requestOverrides).headers) {
          headerMap.get(header.name).push(header.value.value);
        }
        for (const [name, value] of headerMap.entries()) {
          headers.push({
            name,
            value: {
              type: "string",
              value: value.join("\n").trimEnd()
            }
          });
        }
      } else {
        headers = [
          ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(__privateGet(this, _request).info?.request.headers),
          ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(__privateGet(this, _request).extraInfo?.headers)
        ];
      }
      return headers;
    };
    _authChallenges = new WeakSet();
    authChallenges_get = function() {
      if (!__privateGet(this, _response).info) {
        return;
      }
      if (!(__privateGet(this, _statusCode, statusCode_get) === 401 || __privateGet(this, _statusCode, statusCode_get) === 407)) {
        return void 0;
      }
      const headerName = __privateGet(this, _statusCode, statusCode_get) === 401 ? "WWW-Authenticate" : "Proxy-Authenticate";
      const authChallenges = [];
      for (const [header, value] of Object.entries(__privateGet(this, _response).info.headers)) {
        if (header.localeCompare(headerName, void 0, { sensitivity: "base" }) === 0) {
          authChallenges.push({
            scheme: value.split(" ").at(0) ?? "",
            realm: value.match(REALM_REGEX)?.at(0) ?? ""
          });
        }
      }
      return authChallenges;
    };
    _timings = new WeakSet();
    timings_get = function() {
      const responseTimeOffset = (0, NetworkUtils_js_1.getTiming)((0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.requestTime) - (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _request).info?.timestamp));
      return {
        // TODO: Verify this is correct
        timeOrigin: Math.round((0, NetworkUtils_js_1.getTiming)(__privateGet(this, _request).info?.wallTime) * 1e3),
        // Timing baseline.
        // TODO: Verify this is correct.
        requestTime: 0,
        // TODO: set if redirect detected.
        redirectStart: 0,
        // TODO: set if redirect detected.
        redirectEnd: 0,
        // TODO: Verify this is correct
        // https://source.chromium.org/chromium/chromium/src/+/main:net/base/load_timing_info.h;l=145
        fetchStart: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.workerFetchStart, responseTimeOffset),
        // fetchStart: 0,
        dnsStart: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.dnsStart, responseTimeOffset),
        dnsEnd: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.dnsEnd, responseTimeOffset),
        connectStart: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.connectStart, responseTimeOffset),
        connectEnd: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.connectEnd, responseTimeOffset),
        tlsStart: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.sslStart, responseTimeOffset),
        requestStart: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.sendStart, responseTimeOffset),
        // https://source.chromium.org/chromium/chromium/src/+/main:net/base/load_timing_info.h;l=196
        responseStart: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.receiveHeadersStart, responseTimeOffset),
        responseEnd: (0, NetworkUtils_js_1.getTiming)(__privateGet(this, _response).info?.timing?.receiveHeadersEnd, responseTimeOffset)
      };
    };
    _phaseChanged = new WeakSet();
    phaseChanged_fn = function() {
      this.waitNextPhase.resolve();
      this.waitNextPhase = new Deferred_js_1.Deferred();
    };
    _interceptsInPhase = new WeakSet();
    interceptsInPhase_fn = function(phase) {
      if (!__privateGet(this, _cdpTarget).isSubscribedTo(`network.${phase}`)) {
        return /* @__PURE__ */ new Set();
      }
      return __privateGet(this, _networkStorage).getInterceptsForPhase(this, phase);
    };
    _isBlockedInPhase = new WeakSet();
    isBlockedInPhase_fn = function(phase) {
      return __privateMethod(this, _interceptsInPhase, interceptsInPhase_fn).call(this, phase).size > 0;
    };
    _emitEventsIfReady = new WeakSet();
    emitEventsIfReady_fn = function(options = {}) {
      const requestExtraInfoCompleted = (
        // Flush redirects
        options.wasRedirected || options.hasFailed || __privateMethod(this, _isDataUrl, isDataUrl_fn).call(this) || Boolean(__privateGet(this, _request).extraInfo) || // Requests from cache don't have extra info
        __privateGet(this, _servedFromCache) || // Sometimes there is no extra info and the response
        // is the only place we can find out
        Boolean(__privateGet(this, _response).info && !__privateGet(this, _response).hasExtraInfo)
      );
      const noInterceptionExpected = (
        // We can't intercept data urls from CDP
        __privateMethod(this, _isDataUrl, isDataUrl_fn).call(this) || // Cached requests never hit the network
        __privateGet(this, _servedFromCache)
      );
      const requestInterceptionExpected = !noInterceptionExpected && __privateMethod(this, _isBlockedInPhase, isBlockedInPhase_fn).call(this, "beforeRequestSent");
      const requestInterceptionCompleted = !requestInterceptionExpected || requestInterceptionExpected && Boolean(__privateGet(this, _request).paused);
      if (Boolean(__privateGet(this, _request).info) && (requestInterceptionExpected ? requestInterceptionCompleted : requestExtraInfoCompleted)) {
        __privateMethod(this, _emitEvent, emitEvent_fn).call(this, __privateMethod(this, _getBeforeRequestEvent, getBeforeRequestEvent_fn).bind(this));
      }
      const responseExtraInfoCompleted = Boolean(__privateGet(this, _response).extraInfo) || // Response from cache don't have extra info
      __privateGet(this, _servedFromCache) || // Don't expect extra info if the flag is false
      Boolean(__privateGet(this, _response).info && !__privateGet(this, _response).hasExtraInfo);
      const responseInterceptionExpected = !noInterceptionExpected && __privateMethod(this, _isBlockedInPhase, isBlockedInPhase_fn).call(this, "responseStarted");
      if (__privateGet(this, _response).info || responseInterceptionExpected && Boolean(__privateGet(this, _response).paused)) {
        __privateMethod(this, _emitEvent, emitEvent_fn).call(this, __privateMethod(this, _getResponseStartedEvent, getResponseStartedEvent_fn).bind(this));
      }
      const responseInterceptionCompleted = !responseInterceptionExpected || responseInterceptionExpected && Boolean(__privateGet(this, _response).paused);
      if (Boolean(__privateGet(this, _response).info) && responseExtraInfoCompleted && responseInterceptionCompleted) {
        __privateMethod(this, _emitEvent, emitEvent_fn).call(this, __privateMethod(this, _getResponseReceivedEvent, getResponseReceivedEvent_fn).bind(this));
        __privateGet(this, _networkStorage).deleteRequest(this.id);
      }
    };
    _continueRequest = new WeakSet();
    continueRequest_fn = async function(overrides = {}) {
      (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
      await this.cdpClient.sendCommand("Fetch.continueRequest", {
        requestId: __privateGet(this, _fetchId),
        url: overrides.url,
        method: overrides.method,
        headers: overrides.headers,
        postData: overrides.postData
      });
      __privateSet(this, _interceptPhase, void 0);
    };
    _continueResponse = new WeakSet();
    continueResponse_fn = async function({ responseCode, responsePhrase, responseHeaders } = {}) {
      (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
      await this.cdpClient.sendCommand("Fetch.continueResponse", {
        requestId: __privateGet(this, _fetchId),
        responseCode,
        responsePhrase,
        responseHeaders
      });
      __privateSet(this, _interceptPhase, void 0);
    };
    _continueWithAuth = new WeakSet();
    continueWithAuth_fn = async function(authChallengeResponse) {
      (0, assert_js_1.assert)(__privateGet(this, _fetchId), "Network Interception not set-up.");
      await this.cdpClient.sendCommand("Fetch.continueWithAuth", {
        requestId: __privateGet(this, _fetchId),
        authChallengeResponse
      });
      __privateSet(this, _interceptPhase, void 0);
    };
    _emitEvent = new WeakSet();
    emitEvent_fn = function(getEvent) {
      var _a4;
      let event;
      try {
        event = getEvent();
      } catch (error) {
        (_a4 = __privateGet(this, _logger)) == null ? void 0 : _a4.call(this, log_js_1.LogType.debugError, error);
        return;
      }
      if (__privateMethod(this, _isIgnoredEvent, isIgnoredEvent_fn).call(this) || __privateGet(this, _emittedEvents)[event.method] && // Special case this event can be emitted multiple times
      event.method !== protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired) {
        return;
      }
      __privateMethod(this, _phaseChanged, phaseChanged_fn).call(this);
      __privateGet(this, _emittedEvents)[event.method] = true;
      if (__privateGet(this, _context, context_get)) {
        __privateGet(this, _eventManager).registerEvent(Object.assign(event, {
          type: "event"
        }), __privateGet(this, _context, context_get));
      } else {
        __privateGet(this, _eventManager).registerGlobalEvent(Object.assign(event, {
          type: "event"
        }));
      }
    };
    _getBaseEventParams = new WeakSet();
    getBaseEventParams_fn = function(phase) {
      const interceptProps = {
        isBlocked: false
      };
      if (phase) {
        const blockedBy = __privateMethod(this, _interceptsInPhase, interceptsInPhase_fn).call(this, phase);
        interceptProps.isBlocked = blockedBy.size > 0;
        if (interceptProps.isBlocked) {
          interceptProps.intercepts = [...blockedBy];
        }
      }
      return {
        context: __privateGet(this, _context, context_get),
        navigation: __privateGet(this, _navigationId, navigationId_get),
        redirectCount: __privateGet(this, _redirectCount),
        request: __privateMethod(this, _getRequestData, getRequestData_fn).call(this),
        // Timestamp should be in milliseconds, while CDP provides it in seconds.
        timestamp: Math.round((0, NetworkUtils_js_1.getTiming)(__privateGet(this, _request).info?.wallTime) * 1e3),
        // Contains isBlocked and intercepts
        ...interceptProps
      };
    };
    _getResponseEventParams = new WeakSet();
    getResponseEventParams_fn = function() {
      if (__privateGet(this, _response).info?.fromDiskCache) {
        __privateGet(this, _response).extraInfo = void 0;
      }
      const headers = [
        ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(__privateGet(this, _response).info?.headers),
        ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(__privateGet(this, _response).extraInfo?.headers)
        // TODO: Verify how to dedupe these
        // ...bidiNetworkHeadersFromCdpNetworkHeadersEntries(
        //   this.#response.paused?.responseHeaders
        // ),
      ];
      const authChallenges = __privateGet(this, _authChallenges, authChallenges_get);
      const response = {
        url: this.url,
        protocol: __privateGet(this, _response).info?.protocol ?? "",
        status: __privateGet(this, _statusCode, statusCode_get) ?? -1,
        // TODO: Throw an exception or use some other status code?
        statusText: __privateGet(this, _response).info?.statusText || __privateGet(this, _response).paused?.responseStatusText || "",
        fromCache: __privateGet(this, _response).info?.fromDiskCache || __privateGet(this, _response).info?.fromPrefetchCache || __privateGet(this, _servedFromCache),
        headers: __privateGet(this, _responseOverrides)?.headers ?? headers,
        mimeType: __privateGet(this, _response).info?.mimeType || "",
        bytesReceived: __privateGet(this, _response).info?.encodedDataLength || 0,
        headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
        // TODO: consider removing from spec.
        bodySize: 0,
        content: {
          // TODO: consider removing from spec.
          size: 0
        },
        ...authChallenges ? { authChallenges } : {}
      };
      return {
        ...response,
        "goog:securityDetails": __privateGet(this, _response).info?.securityDetails
      };
    };
    _getRequestData = new WeakSet();
    getRequestData_fn = function() {
      const headers = __privateGet(this, _requestHeaders, requestHeaders_get);
      const request = {
        request: __privateGet(this, _id),
        url: this.url,
        method: __privateGet(this, _method, method_get) ?? _a3.unknownParameter,
        headers,
        cookies: __privateGet(this, _cookies, cookies_get),
        headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
        bodySize: __privateGet(this, _bodySize, bodySize_get),
        // TODO: populate
        destination: __privateMethod(this, _getDestination, getDestination_fn).call(this),
        // TODO: populate
        initiatorType: __privateMethod(this, _getInitiatorType, getInitiatorType_fn).call(this),
        timings: __privateGet(this, _timings, timings_get)
      };
      return {
        ...request,
        "goog:postData": __privateGet(this, _request).info?.request?.postData,
        "goog:hasPostData": __privateGet(this, _request).info?.request?.hasPostData,
        "goog:resourceType": __privateGet(this, _request).info?.type,
        "goog:resourceInitiator": __privateGet(this, _request).info?.initiator
      };
    };
    _getDestination = new WeakSet();
    getDestination_fn = function() {
      switch (__privateGet(this, _request).info?.type) {
        case "Script":
          return "script";
        case "Stylesheet":
          return "style";
        case "Image":
          return "image";
        case "Document":
          return __privateGet(this, _request).info?.initiator.type === "parser" ? "iframe" : "";
        default:
          return "";
      }
    };
    _getInitiatorType = new WeakSet();
    getInitiatorType_fn = function() {
      if (__privateGet(this, _request).info?.initiator.type === "parser") {
        switch (__privateGet(this, _request).info?.type) {
          case "Document":
            return "iframe";
          case "Font":
            return __privateGet(this, _request).info?.initiator?.url === __privateGet(this, _request).info?.documentURL ? "font" : "css";
          case "Image":
            return __privateGet(this, _request).info?.initiator?.url === __privateGet(this, _request).info?.documentURL ? "img" : "css";
          case "Script":
            return "script";
          case "Stylesheet":
            return "link";
          default:
            return null;
        }
      }
      if (__privateGet(this, _request)?.info?.type === "Fetch") {
        return "fetch";
      }
      return null;
    };
    _getBeforeRequestEvent = new WeakSet();
    getBeforeRequestEvent_fn = function() {
      var _a4;
      (0, assert_js_1.assert)(__privateGet(this, _request).info, "RequestWillBeSentEvent is not set");
      return {
        method: protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent,
        params: {
          ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this, "beforeRequestSent"),
          initiator: {
            type: __privateMethod(_a4 = _a3, _getInitiator, getInitiator_fn).call(_a4, __privateGet(this, _request).info.initiator.type),
            columnNumber: __privateGet(this, _request).info.initiator.columnNumber,
            lineNumber: __privateGet(this, _request).info.initiator.lineNumber,
            stackTrace: __privateGet(this, _request).info.initiator.stack,
            request: __privateGet(this, _request).info.initiator.requestId
          }
        }
      };
    };
    _getResponseStartedEvent = new WeakSet();
    getResponseStartedEvent_fn = function() {
      return {
        method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted,
        params: {
          ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this, "responseStarted"),
          response: __privateMethod(this, _getResponseEventParams, getResponseEventParams_fn).call(this)
        }
      };
    };
    _getResponseReceivedEvent = new WeakSet();
    getResponseReceivedEvent_fn = function() {
      return {
        method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted,
        params: {
          ...__privateMethod(this, _getBaseEventParams, getBaseEventParams_fn).call(this),
          response: __privateMethod(this, _getResponseEventParams, getResponseEventParams_fn).call(this)
        }
      };
    };
    _isIgnoredEvent = new WeakSet();
    isIgnoredEvent_fn = function() {
      const faviconUrl = "/favicon.ico";
      return __privateGet(this, _request).paused?.request.url.endsWith(faviconUrl) ?? __privateGet(this, _request).info?.request.url.endsWith(faviconUrl) ?? false;
    };
    _getOverrideHeader = new WeakSet();
    getOverrideHeader_fn = function(headers, cookies) {
      if (!headers && !cookies) {
        return void 0;
      }
      let overrideHeaders = headers;
      const cookieHeader = (0, NetworkUtils_js_1.networkHeaderFromCookieHeaders)(cookies);
      if (cookieHeader && !overrideHeaders) {
        overrideHeaders = __privateGet(this, _requestHeaders, requestHeaders_get);
      }
      if (cookieHeader && overrideHeaders) {
        overrideHeaders.filter((header) => header.name.localeCompare("cookie", void 0, {
          sensitivity: "base"
        }) !== 0);
        overrideHeaders.push(cookieHeader);
      }
      return overrideHeaders;
    };
    _getInitiator = new WeakSet();
    getInitiator_fn = function(initiatorType) {
      switch (initiatorType) {
        case "parser":
        case "script":
        case "preflight":
          return initiatorType;
        default:
          return "other";
      }
    };
    __privateAdd(NetworkRequest, _getInitiator);
    __publicField(NetworkRequest, "unknownParameter", "UNKNOWN");
    exports.NetworkRequest = NetworkRequest;
    _a3 = NetworkRequest;
    function getCdpBodyFromBiDiBytesValue(body) {
      let parsedBody;
      if (body?.type === "string") {
        parsedBody = (0, NetworkUtils_js_1.stringToBase64)(body.value);
      } else if (body?.type === "base64") {
        parsedBody = body.value;
      }
      return parsedBody;
    }
    function getSizeFromBiDiBytesValue(body) {
      if (body?.type === "string") {
        return body.value.length;
      } else if (body?.type === "base64") {
        return atob(body.value).length;
      }
      return 0;
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js
var require_NetworkStorage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkStorage = void 0;
    var protocol_js_1 = require_protocol();
    var uuid_js_1 = require_uuid();
    var NetworkRequest_js_1 = require_NetworkRequest();
    var NetworkUtils_js_1 = require_NetworkUtils();
    var NetworkStorage = class {
      #browsingContextStorage;
      #eventManager;
      #logger;
      /**
       * A map from network request ID to Network Request objects.
       * Needed as long as information about requests comes from different events.
       */
      #requests = /* @__PURE__ */ new Map();
      /** A map from intercept ID to track active network intercepts. */
      #intercepts = /* @__PURE__ */ new Map();
      #defaultCacheBehavior = "default";
      constructor(eventManager, browsingContextStorage, browserClient, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#eventManager = eventManager;
        browserClient.on("Target.detachedFromTarget", ({ sessionId }) => {
          this.disposeRequestMap(sessionId);
        });
        this.#logger = logger;
      }
      /**
       * Gets the network request with the given ID, if any.
       * Otherwise, creates a new network request with the given ID and cdp target.
       */
      #getOrCreateNetworkRequest(id, cdpTarget, redirectCount) {
        let request = this.getRequestById(id);
        if (request) {
          return request;
        }
        request = new NetworkRequest_js_1.NetworkRequest(id, this.#eventManager, this, cdpTarget, redirectCount, this.#logger);
        this.addRequest(request);
        return request;
      }
      onCdpTargetCreated(cdpTarget) {
        const cdpClient = cdpTarget.cdpClient;
        const listeners = [
          [
            "Network.requestWillBeSent",
            (params) => {
              const request = this.getRequestById(params.requestId);
              if (request && request.isRedirecting()) {
                request.handleRedirect(params);
                this.deleteRequest(params.requestId);
                this.#getOrCreateNetworkRequest(params.requestId, cdpTarget, request.redirectCount + 1).onRequestWillBeSentEvent(params);
              } else {
                this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onRequestWillBeSentEvent(params);
              }
            }
          ],
          [
            "Network.requestWillBeSentExtraInfo",
            (params) => {
              this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onRequestWillBeSentExtraInfoEvent(params);
            }
          ],
          [
            "Network.responseReceived",
            (params) => {
              this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onResponseReceivedEvent(params);
            }
          ],
          [
            "Network.responseReceivedExtraInfo",
            (params) => {
              this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onResponseReceivedExtraInfoEvent(params);
            }
          ],
          [
            "Network.requestServedFromCache",
            (params) => {
              this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onServedFromCache();
            }
          ],
          [
            "Network.loadingFailed",
            (params) => {
              this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onLoadingFailedEvent(params);
            }
          ],
          [
            "Fetch.requestPaused",
            (event) => {
              this.#getOrCreateNetworkRequest(
                // CDP quirk if the Network domain is not present this is undefined
                event.networkId ?? event.requestId,
                cdpTarget
              ).onRequestPaused(event);
            }
          ],
          [
            "Fetch.authRequired",
            (event) => {
              let request = this.getRequestByFetchId(event.requestId);
              if (!request) {
                request = this.#getOrCreateNetworkRequest(event.requestId, cdpTarget);
              }
              request.onAuthRequired(event);
            }
          ]
        ];
        for (const [event, listener] of listeners) {
          cdpClient.on(event, listener);
        }
      }
      getInterceptionStages(browsingContextId) {
        const stages = {
          request: false,
          response: false,
          auth: false
        };
        for (const intercept of this.#intercepts.values()) {
          if (intercept.contexts && !intercept.contexts.includes(browsingContextId)) {
            continue;
          }
          stages.request ||= intercept.phases.includes(
            "beforeRequestSent"
            /* Network.InterceptPhase.BeforeRequestSent */
          );
          stages.response ||= intercept.phases.includes(
            "responseStarted"
            /* Network.InterceptPhase.ResponseStarted */
          );
          stages.auth ||= intercept.phases.includes(
            "authRequired"
            /* Network.InterceptPhase.AuthRequired */
          );
        }
        return stages;
      }
      getInterceptsForPhase(request, phase) {
        if (request.url === NetworkRequest_js_1.NetworkRequest.unknownParameter) {
          return /* @__PURE__ */ new Set();
        }
        const intercepts = /* @__PURE__ */ new Set();
        for (const [interceptId, intercept] of this.#intercepts.entries()) {
          if (!intercept.phases.includes(phase) || intercept.contexts && !intercept.contexts.includes(request.cdpTarget.topLevelId)) {
            continue;
          }
          if (intercept.urlPatterns.length === 0) {
            intercepts.add(interceptId);
            continue;
          }
          for (const pattern of intercept.urlPatterns) {
            if ((0, NetworkUtils_js_1.matchUrlPattern)(pattern, request.url)) {
              intercepts.add(interceptId);
              break;
            }
          }
        }
        return intercepts;
      }
      disposeRequestMap(sessionId) {
        for (const request of this.#requests.values()) {
          if (request.cdpClient.sessionId === sessionId) {
            this.#requests.delete(request.id);
            request.dispose();
          }
        }
      }
      /**
       * Adds the given entry to the intercept map.
       * URL patterns are assumed to be parsed.
       *
       * @return The intercept ID.
       */
      addIntercept(value) {
        const interceptId = (0, uuid_js_1.uuidv4)();
        this.#intercepts.set(interceptId, value);
        return interceptId;
      }
      /**
       * Removes the given intercept from the intercept map.
       * Throws NoSuchInterceptException if the intercept does not exist.
       */
      removeIntercept(intercept) {
        if (!this.#intercepts.has(intercept)) {
          throw new protocol_js_1.NoSuchInterceptException(`Intercept '${intercept}' does not exist.`);
        }
        this.#intercepts.delete(intercept);
      }
      getRequestsByTarget(target) {
        const requests2 = [];
        for (const request of this.#requests.values()) {
          if (request.cdpTarget === target) {
            requests2.push(request);
          }
        }
        return requests2;
      }
      getRequestById(id) {
        return this.#requests.get(id);
      }
      getRequestByFetchId(fetchId) {
        for (const request of this.#requests.values()) {
          if (request.fetchId === fetchId) {
            return request;
          }
        }
        return;
      }
      addRequest(request) {
        this.#requests.set(request.id, request);
      }
      deleteRequest(id) {
        this.#requests.delete(id);
      }
      /**
       * Gets the virtual navigation ID for the given navigable ID.
       */
      getNavigationId(contextId) {
        if (contextId === void 0) {
          return null;
        }
        return this.#browsingContextStorage.findContext(contextId)?.navigationId ?? null;
      }
      set defaultCacheBehavior(behavior) {
        this.#defaultCacheBehavior = behavior;
      }
      get defaultCacheBehavior() {
        return this.#defaultCacheBehavior;
      }
    };
    exports.NetworkStorage = NetworkStorage;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js
var require_PreloadScriptStorage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PreloadScriptStorage = void 0;
    var ErrorResponse_js_1 = require_ErrorResponse();
    var PreloadScriptStorage = class {
      /** Tracks all BiDi preload scripts.  */
      #scripts = /* @__PURE__ */ new Set();
      /**
       * Finds all entries that match the given filter (OR logic).
       */
      find(filter2) {
        if (!filter2) {
          return [...this.#scripts];
        }
        return [...this.#scripts].filter((script) => {
          if (script.contexts === void 0 && script.userContexts === void 0) {
            return true;
          }
          if (filter2.targetId !== void 0 && script.targetIds.has(filter2.targetId)) {
            return true;
          }
          return false;
        });
      }
      add(preloadScript) {
        this.#scripts.add(preloadScript);
      }
      /** Deletes all BiDi preload script entries that match the given filter. */
      remove(id) {
        const script = [...this.#scripts].find((script2) => script2.id === id);
        if (script === void 0) {
          throw new ErrorResponse_js_1.NoSuchScriptException(`No preload script with id '${id}'`);
        }
        this.#scripts.delete(script);
      }
      /** Gets the preload script with the given ID, if any, otherwise throws. */
      getPreloadScript(id) {
        const script = [...this.#scripts].find((script2) => script2.id === id);
        if (script === void 0) {
          throw new ErrorResponse_js_1.NoSuchScriptException(`No preload script with id '${id}'`);
        }
        return script;
      }
      onCdpTargetCreated(targetId, userContext) {
        const scriptInUserContext = [...this.#scripts].filter((script) => {
          if (!script.userContexts && !script.contexts) {
            return true;
          }
          return script.userContexts?.includes(userContext);
        });
        for (const script of scriptInUserContext) {
          script.targetIds.add(targetId);
        }
      }
    };
    exports.PreloadScriptStorage = PreloadScriptStorage;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js
var require_RealmStorage = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RealmStorage = void 0;
    var protocol_js_1 = require_protocol();
    var WindowRealm_js_1 = require_WindowRealm();
    var RealmStorage = class {
      /** Tracks handles and their realms sent to the client. */
      #knownHandlesToRealmMap = /* @__PURE__ */ new Map();
      /** Map from realm ID to Realm. */
      #realmMap = /* @__PURE__ */ new Map();
      get knownHandlesToRealmMap() {
        return this.#knownHandlesToRealmMap;
      }
      addRealm(realm) {
        this.#realmMap.set(realm.realmId, realm);
      }
      /** Finds all realms that match the given filter. */
      findRealms(filter2) {
        return Array.from(this.#realmMap.values()).filter((realm) => {
          if (filter2.realmId !== void 0 && filter2.realmId !== realm.realmId) {
            return false;
          }
          if (filter2.browsingContextId !== void 0 && !realm.associatedBrowsingContexts.map((browsingContext) => browsingContext.id).includes(filter2.browsingContextId)) {
            return false;
          }
          if (filter2.sandbox !== void 0 && (!(realm instanceof WindowRealm_js_1.WindowRealm) || filter2.sandbox !== realm.sandbox)) {
            return false;
          }
          if (filter2.executionContextId !== void 0 && filter2.executionContextId !== realm.executionContextId) {
            return false;
          }
          if (filter2.origin !== void 0 && filter2.origin !== realm.origin) {
            return false;
          }
          if (filter2.type !== void 0 && filter2.type !== realm.realmType) {
            return false;
          }
          if (filter2.cdpSessionId !== void 0 && filter2.cdpSessionId !== realm.cdpClient.sessionId) {
            return false;
          }
          return true;
        });
      }
      findRealm(filter2) {
        const maybeRealms = this.findRealms(filter2);
        if (maybeRealms.length !== 1) {
          return void 0;
        }
        return maybeRealms[0];
      }
      /** Gets the only realm that matches the given filter, if any, otherwise throws. */
      getRealm(filter2) {
        const maybeRealm = this.findRealm(filter2);
        if (maybeRealm === void 0) {
          throw new protocol_js_1.NoSuchFrameException(`Realm ${JSON.stringify(filter2)} not found`);
        }
        return maybeRealm;
      }
      /** Deletes all realms that match the given filter. */
      deleteRealms(filter2) {
        this.findRealms(filter2).map((realm) => {
          realm.dispose();
          this.#realmMap.delete(realm.realmId);
          Array.from(this.knownHandlesToRealmMap.entries()).filter(([, r]) => r === realm.realmId).map(([handle]) => this.knownHandlesToRealmMap.delete(handle));
        });
      }
    };
    exports.RealmStorage = RealmStorage;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/Buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = void 0;
    var Buffer2 = class {
      #capacity;
      #entries = [];
      #onItemRemoved;
      /**
       * @param capacity The buffer capacity.
       * @param onItemRemoved Delegate called for each removed element.
       */
      constructor(capacity, onItemRemoved) {
        this.#capacity = capacity;
        this.#onItemRemoved = onItemRemoved;
      }
      get() {
        return this.#entries;
      }
      add(value) {
        this.#entries.push(value);
        while (this.#entries.length > this.#capacity) {
          const item = this.#entries.shift();
          if (item !== void 0) {
            this.#onItemRemoved?.(item);
          }
        }
      }
    };
    exports.Buffer = Buffer2;
  }
});

// node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js
var require_IdWrapper = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IdWrapper = void 0;
    var _counter, _id;
    var _IdWrapper = class {
      constructor() {
        __privateAdd(this, _id, void 0);
        __privateSet(this, _id, ++__privateWrapper(_IdWrapper, _counter)._);
      }
      get id() {
        return __privateGet(this, _id);
      }
    };
    var IdWrapper = _IdWrapper;
    _counter = new WeakMap();
    _id = new WeakMap();
    __privateAdd(IdWrapper, _counter, 0);
    exports.IdWrapper = IdWrapper;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js
var require_events = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCdpEvent = isCdpEvent2;
    exports.isDeprecatedCdpEvent = isDeprecatedCdpEvent;
    exports.assertSupportedEvent = assertSupportedEvent;
    var protocol_js_1 = require_protocol();
    function isCdpEvent2(name) {
      return name.split(".").at(0)?.startsWith(protocol_js_1.ChromiumBidi.BiDiModule.Cdp) ?? false;
    }
    function isDeprecatedCdpEvent(name) {
      return name.split(".").at(0)?.startsWith(protocol_js_1.ChromiumBidi.BiDiModule.DeprecatedCdp) ?? false;
    }
    function assertSupportedEvent(name) {
      if (!protocol_js_1.ChromiumBidi.EVENT_NAMES.has(name) && !isCdpEvent2(name) && !isDeprecatedCdpEvent(name)) {
        throw new protocol_js_1.InvalidArgumentException(`Unknown event: ${name}`);
      }
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionManager = void 0;
    exports.cartesianProduct = cartesianProduct;
    exports.unrollEvents = unrollEvents;
    exports.difference = difference;
    var protocol_js_1 = require_protocol();
    var uuid_js_1 = require_uuid();
    function cartesianProduct(...a) {
      return a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e].flat())));
    }
    function unrollEvents(events) {
      const allEvents = /* @__PURE__ */ new Set();
      function addEvents(events2) {
        for (const event of events2) {
          allEvents.add(event);
        }
      }
      for (const event of events) {
        switch (event) {
          case protocol_js_1.ChromiumBidi.BiDiModule.Bluetooth:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Bluetooth.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.Log:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Log.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.Network:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Network.EventNames));
            break;
          case protocol_js_1.ChromiumBidi.BiDiModule.Script:
            addEvents(Object.values(protocol_js_1.ChromiumBidi.Script.EventNames));
            break;
          default:
            allEvents.add(event);
        }
      }
      return allEvents.values();
    }
    var SubscriptionManager = class {
      #subscriptions = [];
      #knownSubscriptionIds = /* @__PURE__ */ new Set();
      #browsingContextStorage;
      constructor(browsingContextStorage) {
        this.#browsingContextStorage = browsingContextStorage;
      }
      getChannelsSubscribedToEvent(eventName, contextId) {
        const channels = /* @__PURE__ */ new Map();
        for (const subscription of this.#subscriptions) {
          if (this.#isSubscribedTo(subscription, eventName, contextId)) {
            channels.set(JSON.stringify(subscription.channel), subscription.channel);
          }
        }
        return Array.from(channels.values());
      }
      getChannelsSubscribedToEventGlobally(eventName) {
        const channels = /* @__PURE__ */ new Map();
        for (const subscription of this.#subscriptions) {
          if (this.#isSubscribedTo(subscription, eventName)) {
            channels.set(JSON.stringify(subscription.channel), subscription.channel);
          }
        }
        return Array.from(channels.values());
      }
      #isSubscribedTo(subscription, moduleOrEvent, browsingContextId) {
        let includesEvent = false;
        for (const eventName of subscription.eventNames) {
          if (
            // Event explicitly subscribed
            eventName === moduleOrEvent || // Event subscribed via module
            eventName === moduleOrEvent.split(".").at(0) || // Event explicitly subscribed compared to module
            eventName.split(".").at(0) === moduleOrEvent
          ) {
            includesEvent = true;
            break;
          }
        }
        if (!includesEvent) {
          return false;
        }
        if (subscription.userContextIds.size !== 0) {
          if (!browsingContextId) {
            return false;
          }
          const context2 = this.#browsingContextStorage.findContext(browsingContextId);
          if (!context2) {
            return false;
          }
          return subscription.userContextIds.has(context2.userContext);
        }
        if (subscription.topLevelTraversableIds.size !== 0) {
          if (!browsingContextId) {
            return false;
          }
          const topLevelContext = this.#browsingContextStorage.findTopLevelContextId(browsingContextId);
          return topLevelContext !== null && subscription.topLevelTraversableIds.has(topLevelContext);
        }
        return true;
      }
      isSubscribedTo(moduleOrEvent, contextId) {
        for (const subscription of this.#subscriptions) {
          if (this.#isSubscribedTo(subscription, moduleOrEvent, contextId)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Subscribes to event in the given context and channel.
       * @param {EventNames} event
       * @param {BrowsingContext.BrowsingContext | null} contextId
       * @param {BidiPlusChannel} channel
       * @return {SubscriptionItem[]} List of
       * subscriptions. If the event is a whole module, it will return all the specific
       * events. If the contextId is null, it will return all the top-level contexts which were
       * not subscribed before the command.
       */
      subscribe(eventNames, contextIds, userContextIds, channel) {
        const subscription = {
          id: (0, uuid_js_1.uuidv4)(),
          eventNames: new Set(unrollEvents(eventNames)),
          topLevelTraversableIds: new Set(contextIds.map((contextId) => {
            const topLevelContext = this.#browsingContextStorage.findTopLevelContextId(contextId);
            if (!topLevelContext) {
              throw new protocol_js_1.NoSuchFrameException(`Top-level navigable not found for context id ${contextId}`);
            }
            return topLevelContext;
          })),
          userContextIds: new Set(userContextIds),
          channel
        };
        this.#subscriptions.push(subscription);
        this.#knownSubscriptionIds.add(subscription.id);
        return subscription;
      }
      /**
       * Unsubscribes atomically from all events in the given contexts and channel.
       *
       * This is a legacy spec branch to unsubscribe by attributes.
       */
      unsubscribe(inputEventNames, inputContextIds, channel) {
        const eventNames = new Set(unrollEvents(inputEventNames));
        this.#browsingContextStorage.verifyContextsList(inputContextIds);
        const topLevelTraversables = new Set(inputContextIds.map((contextId) => {
          const topLevelContext = this.#browsingContextStorage.findTopLevelContextId(contextId);
          if (!topLevelContext) {
            throw new protocol_js_1.NoSuchFrameException(`Top-level navigable not found for context id ${contextId}`);
          }
          return topLevelContext;
        }));
        const isGlobalUnsubscribe = topLevelTraversables.size === 0;
        const newSubscriptions = [];
        const eventsMatched = /* @__PURE__ */ new Set();
        const contextsMatched = /* @__PURE__ */ new Set();
        for (const subscription of this.#subscriptions) {
          if (JSON.stringify(subscription.channel) !== JSON.stringify(channel)) {
            newSubscriptions.push(subscription);
            continue;
          }
          if (subscription.userContextIds.size !== 0) {
            newSubscriptions.push(subscription);
            continue;
          }
          if (intersection(subscription.eventNames, eventNames).size === 0) {
            newSubscriptions.push(subscription);
            continue;
          }
          if (isGlobalUnsubscribe) {
            if (subscription.topLevelTraversableIds.size !== 0) {
              newSubscriptions.push(subscription);
              continue;
            }
            const subscriptionEventNames = new Set(subscription.eventNames);
            for (const eventName of eventNames) {
              if (subscriptionEventNames.has(eventName)) {
                eventsMatched.add(eventName);
                subscriptionEventNames.delete(eventName);
              }
            }
            if (subscriptionEventNames.size !== 0) {
              newSubscriptions.push({
                ...subscription,
                eventNames: subscriptionEventNames
              });
            }
          } else {
            if (subscription.topLevelTraversableIds.size === 0) {
              newSubscriptions.push(subscription);
              continue;
            }
            const eventMap = /* @__PURE__ */ new Map();
            for (const eventName of subscription.eventNames) {
              eventMap.set(eventName, new Set(subscription.topLevelTraversableIds));
            }
            for (const eventName of eventNames) {
              const eventContextSet = eventMap.get(eventName);
              if (!eventContextSet) {
                continue;
              }
              for (const toRemoveId of topLevelTraversables) {
                if (eventContextSet.has(toRemoveId)) {
                  contextsMatched.add(toRemoveId);
                  eventsMatched.add(eventName);
                  eventContextSet.delete(toRemoveId);
                }
              }
              if (eventContextSet.size === 0) {
                eventMap.delete(eventName);
              }
            }
            for (const [eventName, remainingContextIds] of eventMap) {
              const partialSubscription = {
                id: subscription.id,
                channel: subscription.channel,
                eventNames: /* @__PURE__ */ new Set([eventName]),
                topLevelTraversableIds: remainingContextIds,
                userContextIds: /* @__PURE__ */ new Set()
              };
              newSubscriptions.push(partialSubscription);
            }
          }
        }
        if (!equal(eventsMatched, eventNames)) {
          throw new protocol_js_1.InvalidArgumentException("No subscription found");
        }
        if (!isGlobalUnsubscribe && !equal(contextsMatched, topLevelTraversables)) {
          throw new protocol_js_1.InvalidArgumentException("No subscription found");
        }
        this.#subscriptions = newSubscriptions;
      }
      /**
       * Unsubscribes by subscriptionId.
       */
      unsubscribeById(subscriptionIds) {
        const subscriptionIdsSet = new Set(subscriptionIds);
        const unknownIds = difference(subscriptionIdsSet, this.#knownSubscriptionIds);
        if (unknownIds.size !== 0) {
          throw new protocol_js_1.InvalidArgumentException("No subscription found");
        }
        this.#subscriptions = this.#subscriptions.filter((subscription) => {
          return !subscriptionIdsSet.has(subscription.id);
        });
        this.#knownSubscriptionIds = difference(this.#knownSubscriptionIds, subscriptionIdsSet);
      }
    };
    exports.SubscriptionManager = SubscriptionManager;
    function intersection(setA, setB) {
      const result = /* @__PURE__ */ new Set();
      for (const a of setA) {
        if (setB.has(a)) {
          result.add(a);
        }
      }
      return result;
    }
    function difference(setA, setB) {
      const result = /* @__PURE__ */ new Set();
      for (const a of setA) {
        if (!setB.has(a)) {
          result.add(a);
        }
      }
      return result;
    }
    function equal(setA, setB) {
      if (setA.size !== setB.size) {
        return false;
      }
      for (const a of setA) {
        if (!setB.has(a)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js
var require_EventManager = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js"(exports) {
    "use strict";
    var _a3;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventManager = void 0;
    var protocol_js_1 = require_protocol();
    var Buffer_js_1 = require_Buffer();
    var DefaultMap_js_1 = require_DefaultMap();
    var EventEmitter_js_1 = require_EventEmitter();
    var IdWrapper_js_1 = require_IdWrapper();
    var OutgoingMessage_js_1 = require_OutgoingMessage();
    var events_js_1 = require_events();
    var SubscriptionManager_js_1 = require_SubscriptionManager();
    var EventWrapper = class {
      #idWrapper = new IdWrapper_js_1.IdWrapper();
      #contextId;
      #event;
      constructor(event, contextId) {
        this.#event = event;
        this.#contextId = contextId;
      }
      get id() {
        return this.#idWrapper.id;
      }
      get contextId() {
        return this.#contextId;
      }
      get event() {
        return this.#event;
      }
    };
    var eventBufferLength = /* @__PURE__ */ new Map([[protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded, 100]]);
    var _eventToContextsMap, _eventBuffers, _lastMessageSent, _subscriptionManager, _browsingContextStorage, _subscribeHooks, _userContextStorage, _getMapKey, getMapKey_fn, _bufferEvent, bufferEvent_fn, _markEventSent, markEventSent_fn, _getBufferedEvents, getBufferedEvents_fn;
    var EventManager = class extends EventEmitter_js_1.EventEmitter {
      constructor(browsingContextStorage, userContextStorage) {
        super();
        /**
         * If the event is buffer-able, put it in the buffer.
         */
        __privateAdd(this, _bufferEvent);
        /**
         * If the event is buffer-able, mark it as sent to the given contextId and channel.
         */
        __privateAdd(this, _markEventSent);
        /**
         * Returns events which are buffered and not yet sent to the given channel events.
         */
        __privateAdd(this, _getBufferedEvents);
        /**
         * Maps event name to a set of contexts where this event already happened.
         * Needed for getting buffered events from all the contexts in case of
         * subscripting to all contexts.
         */
        __privateAdd(this, _eventToContextsMap, new DefaultMap_js_1.DefaultMap(() => /* @__PURE__ */ new Set()));
        /**
         * Maps `eventName` + `browsingContext` to buffer. Used to get buffered events
         * during subscription. Channel-agnostic.
         */
        __privateAdd(this, _eventBuffers, /* @__PURE__ */ new Map());
        /**
         * Maps `eventName` + `browsingContext` to  Map of json stringified channel to last id.
         * Used to avoid sending duplicated events when user
         * subscribes -> unsubscribes -> subscribes.
         */
        __privateAdd(this, _lastMessageSent, /* @__PURE__ */ new Map());
        __privateAdd(this, _subscriptionManager, void 0);
        __privateAdd(this, _browsingContextStorage, void 0);
        /**
         * Map of event name to hooks to be called when client is subscribed to the event.
         */
        __privateAdd(this, _subscribeHooks, void 0);
        __privateAdd(this, _userContextStorage, void 0);
        __privateSet(this, _browsingContextStorage, browsingContextStorage);
        __privateSet(this, _userContextStorage, userContextStorage);
        __privateSet(this, _subscriptionManager, new SubscriptionManager_js_1.SubscriptionManager(browsingContextStorage));
        __privateSet(this, _subscribeHooks, new DefaultMap_js_1.DefaultMap(() => []));
      }
      get subscriptionManager() {
        return __privateGet(this, _subscriptionManager);
      }
      addSubscribeHook(event, hook) {
        __privateGet(this, _subscribeHooks).get(event).push(hook);
      }
      registerEvent(event, contextId) {
        this.registerPromiseEvent(Promise.resolve({
          kind: "success",
          value: event
        }), contextId, event.method);
      }
      registerGlobalEvent(event) {
        this.registerGlobalPromiseEvent(Promise.resolve({
          kind: "success",
          value: event
        }), event.method);
      }
      registerPromiseEvent(event, contextId, eventName) {
        const eventWrapper = new EventWrapper(event, contextId);
        const sortedChannels = __privateGet(this, _subscriptionManager).getChannelsSubscribedToEvent(eventName, contextId);
        __privateMethod(this, _bufferEvent, bufferEvent_fn).call(this, eventWrapper, eventName);
        for (const channel of sortedChannels) {
          this.emit("event", {
            message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(event, channel),
            event: eventName
          });
          __privateMethod(this, _markEventSent, markEventSent_fn).call(this, eventWrapper, channel, eventName);
        }
      }
      registerGlobalPromiseEvent(event, eventName) {
        const eventWrapper = new EventWrapper(event, null);
        const sortedChannels = __privateGet(this, _subscriptionManager).getChannelsSubscribedToEventGlobally(eventName);
        __privateMethod(this, _bufferEvent, bufferEvent_fn).call(this, eventWrapper, eventName);
        for (const channel of sortedChannels) {
          this.emit("event", {
            message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(event, channel),
            event: eventName
          });
          __privateMethod(this, _markEventSent, markEventSent_fn).call(this, eventWrapper, channel, eventName);
        }
      }
      async subscribe(eventNames, contextIds, userContextIds, channel) {
        for (const name of eventNames) {
          (0, events_js_1.assertSupportedEvent)(name);
        }
        if (userContextIds.length && contextIds.length) {
          throw new protocol_js_1.InvalidArgumentException("Both userContexts and contexts cannot be specified.");
        }
        __privateGet(this, _browsingContextStorage).verifyContextsList(contextIds);
        await __privateGet(this, _userContextStorage).verifyUserContextIdList(userContextIds);
        const unrolledEventNames = new Set((0, SubscriptionManager_js_1.unrollEvents)(eventNames));
        const subscribeStepEvents = /* @__PURE__ */ new Map();
        const subscriptionNavigableIds = new Set(contextIds.length ? contextIds.map((contextId) => {
          const id = __privateGet(this, _browsingContextStorage).findTopLevelContextId(contextId);
          if (!id) {
            throw new protocol_js_1.InvalidArgumentException("Invalid context id");
          }
          return id;
        }) : __privateGet(this, _browsingContextStorage).getTopLevelContexts().map((c) => c.id));
        for (const eventName of unrolledEventNames) {
          const subscribedNavigableIds = new Set(__privateGet(this, _browsingContextStorage).getTopLevelContexts().map((c) => c.id).filter((id) => {
            return __privateGet(this, _subscriptionManager).isSubscribedTo(eventName, id);
          }));
          subscribeStepEvents.set(eventName, (0, SubscriptionManager_js_1.difference)(subscriptionNavigableIds, subscribedNavigableIds));
        }
        const subscription = __privateGet(this, _subscriptionManager).subscribe(eventNames, contextIds, userContextIds, channel);
        for (const eventName of subscription.eventNames) {
          for (const contextId of subscriptionNavigableIds) {
            for (const eventWrapper of __privateMethod(this, _getBufferedEvents, getBufferedEvents_fn).call(this, eventName, contextId, channel)) {
              this.emit("event", {
                message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(eventWrapper.event, channel),
                event: eventName
              });
              __privateMethod(this, _markEventSent, markEventSent_fn).call(this, eventWrapper, channel, eventName);
            }
          }
        }
        for (const [eventName, contextIds2] of subscribeStepEvents) {
          for (const contextId of contextIds2) {
            __privateGet(this, _subscribeHooks).get(eventName).forEach((hook) => hook(contextId));
          }
        }
        await this.toggleModulesIfNeeded();
        return subscription.id;
      }
      async unsubscribe(eventNames, contextIds, channel) {
        for (const name of eventNames) {
          (0, events_js_1.assertSupportedEvent)(name);
        }
        __privateGet(this, _subscriptionManager).unsubscribe(eventNames, contextIds, channel);
        await this.toggleModulesIfNeeded();
      }
      async unsubscribeByIds(subscriptionIds) {
        __privateGet(this, _subscriptionManager).unsubscribeById(subscriptionIds);
        await this.toggleModulesIfNeeded();
      }
      async toggleModulesIfNeeded() {
        await Promise.all(__privateGet(this, _browsingContextStorage).getAllContexts().map(async (context2) => {
          return await context2.toggleModulesIfNeeded();
        }));
      }
      clearBufferedEvents(contextId) {
        var _a4;
        for (const eventName of eventBufferLength.keys()) {
          const bufferMapKey = __privateMethod(_a4 = _a3, _getMapKey, getMapKey_fn).call(_a4, eventName, contextId);
          __privateGet(this, _eventBuffers).delete(bufferMapKey);
        }
      }
    };
    _eventToContextsMap = new WeakMap();
    _eventBuffers = new WeakMap();
    _lastMessageSent = new WeakMap();
    _subscriptionManager = new WeakMap();
    _browsingContextStorage = new WeakMap();
    _subscribeHooks = new WeakMap();
    _userContextStorage = new WeakMap();
    _getMapKey = new WeakSet();
    getMapKey_fn = function(eventName, browsingContext) {
      return JSON.stringify({ eventName, browsingContext });
    };
    _bufferEvent = new WeakSet();
    bufferEvent_fn = function(eventWrapper, eventName) {
      var _a4;
      if (!eventBufferLength.has(eventName)) {
        return;
      }
      const bufferMapKey = __privateMethod(_a4 = _a3, _getMapKey, getMapKey_fn).call(_a4, eventName, eventWrapper.contextId);
      if (!__privateGet(this, _eventBuffers).has(bufferMapKey)) {
        __privateGet(this, _eventBuffers).set(bufferMapKey, new Buffer_js_1.Buffer(eventBufferLength.get(eventName)));
      }
      __privateGet(this, _eventBuffers).get(bufferMapKey).add(eventWrapper);
      __privateGet(this, _eventToContextsMap).get(eventName).add(eventWrapper.contextId);
    };
    _markEventSent = new WeakSet();
    markEventSent_fn = function(eventWrapper, channel, eventName) {
      var _a4;
      if (!eventBufferLength.has(eventName)) {
        return;
      }
      const lastSentMapKey = __privateMethod(_a4 = _a3, _getMapKey, getMapKey_fn).call(_a4, eventName, eventWrapper.contextId);
      const lastId = Math.max(__privateGet(this, _lastMessageSent).get(lastSentMapKey)?.get(JSON.stringify(channel)) ?? 0, eventWrapper.id);
      const channelMap = __privateGet(this, _lastMessageSent).get(lastSentMapKey);
      if (channelMap) {
        channelMap.set(JSON.stringify(channel), lastId);
      } else {
        __privateGet(this, _lastMessageSent).set(lastSentMapKey, /* @__PURE__ */ new Map([[JSON.stringify(channel), lastId]]));
      }
    };
    _getBufferedEvents = new WeakSet();
    getBufferedEvents_fn = function(eventName, contextId, channel) {
      var _a4;
      const bufferMapKey = __privateMethod(_a4 = _a3, _getMapKey, getMapKey_fn).call(_a4, eventName, contextId);
      const lastSentMessageId = __privateGet(this, _lastMessageSent).get(bufferMapKey)?.get(JSON.stringify(channel)) ?? -Infinity;
      const result = __privateGet(this, _eventBuffers).get(bufferMapKey)?.get().filter((wrapper) => wrapper.id > lastSentMessageId) ?? [];
      if (contextId === null) {
        Array.from(__privateGet(this, _eventToContextsMap).get(eventName).keys()).filter((_contextId) => (
          // Events without context are already in the result.
          _contextId !== null && // Events from deleted contexts should not be sent.
          __privateGet(this, _browsingContextStorage).hasContext(_contextId)
        )).map((_contextId) => __privateMethod(this, _getBufferedEvents, getBufferedEvents_fn).call(this, eventName, _contextId, channel)).forEach((events) => result.push(...events));
      }
      return result.sort((e1, e2) => e1.id - e2.id);
    };
    /**
     * Returns consistent key to be used to access value maps.
     */
    __privateAdd(EventManager, _getMapKey);
    exports.EventManager = EventManager;
    _a3 = EventManager;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js
var require_BidiServer = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BidiServer = void 0;
    var EventEmitter_js_1 = require_EventEmitter();
    var log_js_1 = require_log();
    var ProcessingQueue_js_1 = require_ProcessingQueue();
    var CommandProcessor_js_1 = require_CommandProcessor();
    var BluetoothProcessor_js_1 = require_BluetoothProcessor();
    var UserContextStorage_js_1 = require_UserContextStorage();
    var CdpTargetManager_js_1 = require_CdpTargetManager();
    var BrowsingContextStorage_js_1 = require_BrowsingContextStorage();
    var NetworkStorage_js_1 = require_NetworkStorage();
    var PreloadScriptStorage_js_1 = require_PreloadScriptStorage();
    var RealmStorage_js_1 = require_RealmStorage();
    var EventManager_js_1 = require_EventManager();
    var BidiServer2 = class extends EventEmitter_js_1.EventEmitter {
      #messageQueue;
      #transport;
      #commandProcessor;
      #eventManager;
      #browsingContextStorage = new BrowsingContextStorage_js_1.BrowsingContextStorage();
      #realmStorage = new RealmStorage_js_1.RealmStorage();
      #preloadScriptStorage = new PreloadScriptStorage_js_1.PreloadScriptStorage();
      #bluetoothProcessor;
      #logger;
      #handleIncomingMessage = (message) => {
        void this.#commandProcessor.processCommand(message).catch((error) => {
          this.#logger?.(log_js_1.LogType.debugError, error);
        });
      };
      #processOutgoingMessage = async (messageEntry) => {
        const message = { ...messageEntry.message, ...messageEntry.channel };
        await this.#transport.sendMessage(message);
      };
      constructor(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, parser, logger) {
        super();
        this.#logger = logger;
        this.#messageQueue = new ProcessingQueue_js_1.ProcessingQueue(this.#processOutgoingMessage, this.#logger);
        this.#transport = bidiTransport;
        this.#transport.setOnMessage(this.#handleIncomingMessage);
        const userUserContextStorage = new UserContextStorage_js_1.UserContextStorage(browserCdpClient);
        this.#eventManager = new EventManager_js_1.EventManager(this.#browsingContextStorage, userUserContextStorage);
        const networkStorage = new NetworkStorage_js_1.NetworkStorage(this.#eventManager, this.#browsingContextStorage, browserCdpClient, logger);
        this.#bluetoothProcessor = new BluetoothProcessor_js_1.BluetoothProcessor(this.#eventManager, this.#browsingContextStorage);
        this.#commandProcessor = new CommandProcessor_js_1.CommandProcessor(cdpConnection, browserCdpClient, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, this.#preloadScriptStorage, networkStorage, this.#bluetoothProcessor, userUserContextStorage, parser, async (options) => {
          await browserCdpClient.sendCommand("Security.setIgnoreCertificateErrors", {
            ignore: options.acceptInsecureCerts ?? false
          });
          new CdpTargetManager_js_1.CdpTargetManager(cdpConnection, browserCdpClient, selfTargetId, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, networkStorage, this.#bluetoothProcessor, this.#preloadScriptStorage, defaultUserContextId, options?.["goog:prerenderingDisabled"] ?? false, options?.unhandledPromptBehavior, logger);
          await browserCdpClient.sendCommand("Target.setDiscoverTargets", {
            discover: true
          });
          await browserCdpClient.sendCommand("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true,
            // Browser session should attach to tab instead of the page, so that
            // prerendering is not blocked.
            filter: [
              {
                type: "page",
                exclude: true
              },
              {}
            ]
          });
          await this.#topLevelContextsLoaded();
        }, this.#logger);
        this.#eventManager.on("event", ({ message, event }) => {
          this.emitOutgoingMessage(message, event);
        });
        this.#commandProcessor.on("response", ({ message, event }) => {
          this.emitOutgoingMessage(message, event);
        });
      }
      /**
       * Creates and starts BiDi Mapper instance.
       */
      static async createAndStart(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, parser, logger) {
        const [{ browserContextIds }, { targetInfos }] = await Promise.all([
          browserCdpClient.sendCommand("Target.getBrowserContexts"),
          browserCdpClient.sendCommand("Target.getTargets")
        ]);
        let defaultUserContextId = "default";
        for (const info of targetInfos) {
          if (info.browserContextId && !browserContextIds.includes(info.browserContextId)) {
            defaultUserContextId = info.browserContextId;
            break;
          }
        }
        const server = new BidiServer2(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, parser, logger);
        return server;
      }
      /**
       * Sends BiDi message.
       */
      emitOutgoingMessage(messageEntry, event) {
        this.#messageQueue.add(messageEntry, event);
      }
      close() {
        this.#transport.close();
      }
      async #topLevelContextsLoaded() {
        await Promise.all(this.#browsingContextStorage.getTopLevelContexts().map((c) => c.lifecycleLoaded()));
      }
    };
    exports.BidiServer = BidiServer2;
  }
});

// node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js
var require_BidiMapper = __commonJS({
  "node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutgoingMessage = exports.EventEmitter = exports.BidiServer = void 0;
    var BidiServer_js_1 = require_BidiServer();
    Object.defineProperty(exports, "BidiServer", { enumerable: true, get: function() {
      return BidiServer_js_1.BidiServer;
    } });
    var EventEmitter_js_1 = require_EventEmitter();
    Object.defineProperty(exports, "EventEmitter", { enumerable: true, get: function() {
      return EventEmitter_js_1.EventEmitter;
    } });
    var OutgoingMessage_js_1 = require_OutgoingMessage();
    Object.defineProperty(exports, "OutgoingMessage", { enumerable: true, get: function() {
      return OutgoingMessage_js_1.OutgoingMessage;
    } });
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js
var _detached, _connection, _sessionId, _BidiCdpSession, BidiCdpSession;
var init_CDPSession2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js"() {
    init_CDPSession();
    init_Errors();
    init_Deferred();
    _BidiCdpSession = class extends CDPSession {
      constructor(frame, sessionId) {
        super();
        __privateAdd(this, _detached, false);
        __privateAdd(this, _connection, void 0);
        __privateAdd(this, _sessionId, Deferred.create());
        __publicField(this, "frame");
        /**
         * @internal
         */
        __publicField(this, "onClose", () => {
          _BidiCdpSession.sessions.delete(this.id());
          __privateSet(this, _detached, true);
        });
        this.frame = frame;
        if (!this.frame.page().browser().cdpSupported) {
          return;
        }
        const connection = this.frame.page().browser().connection;
        __privateSet(this, _connection, connection);
        if (sessionId) {
          __privateGet(this, _sessionId).resolve(sessionId);
          _BidiCdpSession.sessions.set(sessionId, this);
        } else {
          (async () => {
            try {
              const { result } = await connection.send("goog:cdp.getSession", {
                context: frame._id
              });
              __privateGet(this, _sessionId).resolve(result.session);
              _BidiCdpSession.sessions.set(result.session, this);
            } catch (error) {
              __privateGet(this, _sessionId).reject(error);
            }
          })();
        }
        _BidiCdpSession.sessions.set(__privateGet(this, _sessionId).value(), this);
      }
      connection() {
        return void 0;
      }
      get detached() {
        return __privateGet(this, _detached);
      }
      async send(method, params, options) {
        if (__privateGet(this, _connection) === void 0) {
          throw new UnsupportedOperation("CDP support is required for this feature. The current browser does not support CDP.");
        }
        if (__privateGet(this, _detached)) {
          throw new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the page has been closed.`);
        }
        const session = await __privateGet(this, _sessionId).valueOrThrow();
        const { result } = await __privateGet(this, _connection).send("goog:cdp.sendCommand", {
          method,
          params,
          session
        }, options?.timeout);
        return result.result;
      }
      async detach() {
        if (__privateGet(this, _connection) === void 0 || __privateGet(this, _connection).closed || __privateGet(this, _detached)) {
          return;
        }
        try {
          await this.frame.client.send("Target.detachFromTarget", {
            sessionId: this.id()
          });
        } finally {
          this.onClose();
        }
      }
      id() {
        const value = __privateGet(this, _sessionId).value();
        return typeof value === "string" ? value : "";
      }
    };
    BidiCdpSession = _BidiCdpSession;
    _detached = new WeakMap();
    _connection = new WeakMap();
    _sessionId = new WeakMap();
    __publicField(BidiCdpSession, "sessions", /* @__PURE__ */ new Map());
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js
function createProtocolError(object) {
  let message = `${object.error} ${object.message}`;
  if (object.stacktrace) {
    message += ` ${object.stacktrace}`;
  }
  return message;
}
function isCdpEvent(event) {
  return event.method.startsWith("goog:cdp.");
}
var debugProtocolSend2, debugProtocolReceive2, BidiConnection;
var init_Connection = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js"() {
    init_CallbackRegistry();
    init_Debug();
    init_EventEmitter();
    init_util();
    init_assert();
    init_CDPSession2();
    debugProtocolSend2 = debug("puppeteer:webDriverBiDi:SEND \u25BA");
    debugProtocolReceive2 = debug("puppeteer:webDriverBiDi:RECV \u25C0");
    BidiConnection = class extends EventEmitter {
      #url;
      #transport;
      #delay;
      #timeout = 0;
      #closed = false;
      #callbacks = new CallbackRegistry();
      #emitters = [];
      constructor(url, transport, delay = 0, timeout2) {
        super();
        this.#url = url;
        this.#delay = delay;
        this.#timeout = timeout2 ?? 18e4;
        this.#transport = transport;
        this.#transport.onmessage = this.onMessage.bind(this);
        this.#transport.onclose = this.unbind.bind(this);
      }
      get closed() {
        return this.#closed;
      }
      get url() {
        return this.#url;
      }
      pipeTo(emitter) {
        this.#emitters.push(emitter);
      }
      emit(type, event) {
        for (const emitter of this.#emitters) {
          emitter.emit(type, event);
        }
        return super.emit(type, event);
      }
      send(method, params, timeout2) {
        assert(!this.#closed, "Protocol error: Connection closed.");
        return this.#callbacks.create(method, timeout2 ?? this.#timeout, (id) => {
          const stringifiedMessage = JSON.stringify({
            id,
            method,
            params
          });
          debugProtocolSend2(stringifiedMessage);
          this.#transport.send(stringifiedMessage);
        });
      }
      /**
       * @internal
       */
      async onMessage(message) {
        if (this.#delay) {
          await new Promise((f) => {
            return setTimeout(f, this.#delay);
          });
        }
        debugProtocolReceive2(message);
        const object = JSON.parse(message);
        if ("type" in object) {
          switch (object.type) {
            case "success":
              this.#callbacks.resolve(object.id, object);
              return;
            case "error":
              if (object.id === null) {
                break;
              }
              this.#callbacks.reject(object.id, createProtocolError(object), `${object.error}: ${object.message}`);
              return;
            case "event":
              if (isCdpEvent(object)) {
                BidiCdpSession.sessions.get(object.params.session)?.emit(object.params.event, object.params.params);
                return;
              }
              this.emit(object.method, object.params);
              return;
          }
        }
        if ("id" in object) {
          this.#callbacks.reject(object.id, `Protocol Error. Message is not in BiDi protocol format: '${message}'`, object.message);
        }
        debugError(object);
      }
      /**
       * Unbinds the connection, but keeps the transport open. Useful when the transport will
       * be reused by other connection e.g. with different protocol.
       * @internal
       */
      unbind() {
        if (this.#closed) {
          return;
        }
        this.#closed = true;
        this.#transport.onmessage = () => {
        };
        this.#transport.onclose = () => {
        };
        this.#callbacks.clear();
      }
      /**
       * Unbinds the connection and closes the transport.
       */
      dispose() {
        this.unbind();
        this.#transport.close();
      }
      getPendingProtocolErrors() {
        return this.#callbacks.getPendingProtocolErrors();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js
async function connectBidiOverCdp(cdp) {
  const transportBiDi = new NoOpTransport();
  const cdpConnectionAdapter = new CdpConnectionAdapter(cdp);
  const pptrTransport = {
    send(message) {
      transportBiDi.emitMessage(JSON.parse(message));
    },
    close() {
      bidiServer.close();
      cdpConnectionAdapter.close();
      cdp.dispose();
    },
    onmessage(_message) {
    }
  };
  transportBiDi.on("bidiResponse", (message) => {
    pptrTransport.onmessage(JSON.stringify(message));
  });
  const pptrBiDiConnection = new BidiConnection(cdp.url(), pptrTransport, cdp.delay, cdp.timeout);
  const bidiServer = await BidiMapper.BidiServer.createAndStart(
    transportBiDi,
    cdpConnectionAdapter,
    cdpConnectionAdapter.browserClient(),
    /* selfTargetId= */
    "",
    void 0,
    bidiServerLogger
  );
  return pptrBiDiConnection;
}
var BidiMapper, bidiServerLogger, CdpConnectionAdapter, CDPClientAdapter, NoOpTransport;
var init_BidiOverCdp = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js"() {
    BidiMapper = __toESM(require_BidiMapper(), 1);
    init_Debug();
    init_Errors();
    init_Connection();
    bidiServerLogger = (prefix, ...args) => {
      debug(`bidi:${prefix}`)(args);
    };
    CdpConnectionAdapter = class {
      #cdp;
      #adapters = /* @__PURE__ */ new Map();
      #browserCdpConnection;
      constructor(cdp) {
        this.#cdp = cdp;
        this.#browserCdpConnection = new CDPClientAdapter(cdp);
      }
      browserClient() {
        return this.#browserCdpConnection;
      }
      getCdpClient(id) {
        const session = this.#cdp.session(id);
        if (!session) {
          throw new Error(`Unknown CDP session with id ${id}`);
        }
        if (!this.#adapters.has(session)) {
          const adapter = new CDPClientAdapter(session, id, this.#browserCdpConnection);
          this.#adapters.set(session, adapter);
          return adapter;
        }
        return this.#adapters.get(session);
      }
      close() {
        this.#browserCdpConnection.close();
        for (const adapter of this.#adapters.values()) {
          adapter.close();
        }
      }
    };
    CDPClientAdapter = class extends BidiMapper.EventEmitter {
      #closed = false;
      #client;
      sessionId = void 0;
      #browserClient;
      constructor(client, sessionId, browserClient) {
        super();
        this.#client = client;
        this.sessionId = sessionId;
        this.#browserClient = browserClient;
        this.#client.on("*", this.#forwardMessage);
      }
      browserClient() {
        return this.#browserClient;
      }
      #forwardMessage = (method, event) => {
        this.emit(method, event);
      };
      async sendCommand(method, ...params) {
        if (this.#closed) {
          return;
        }
        try {
          return await this.#client.send(method, ...params);
        } catch (err) {
          if (this.#closed) {
            return;
          }
          throw err;
        }
      }
      close() {
        this.#client.off("*", this.#forwardMessage);
        this.#closed = true;
      }
      isCloseError(error) {
        return error instanceof TargetCloseError;
      }
    };
    NoOpTransport = class extends BidiMapper.EventEmitter {
      #onMessage = async (_m) => {
        return;
      };
      emitMessage(message) {
        void this.#onMessage(message);
      }
      setOnMessage(onMessage) {
        this.#onMessage = onMessage;
      }
      async sendMessage(message) {
        this.emit("bidiResponse", message);
      }
      close() {
        this.#onMessage = async (_m) => {
          return;
        };
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js
var __runInitializers8, __esDecorate8, Navigation;
var init_Navigation = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js"() {
    init_EventEmitter();
    init_decorators();
    init_disposable();
    __runInitializers8 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate8 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    Navigation = (() => {
      var _a3;
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _dispose_decorators;
      return class Navigation2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate8(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(context2) {
          const navigation = new Navigation2(context2);
          navigation.#initialize();
          return navigation;
        }
        #request = __runInitializers8(this, _instanceExtraInitializers);
        #navigation;
        #browsingContext;
        #disposables = new DisposableStack();
        #id;
        constructor(context2) {
          super();
          this.#browsingContext = context2;
        }
        #initialize() {
          const browsingContextEmitter = this.#disposables.use(new EventEmitter(this.#browsingContext));
          browsingContextEmitter.once("closed", () => {
            this.emit("failed", {
              url: this.#browsingContext.url,
              timestamp: /* @__PURE__ */ new Date()
            });
            this.dispose();
          });
          browsingContextEmitter.on("request", ({ request }) => {
            if (request.navigation === void 0 || // If a request with a navigation ID comes in, then the navigation ID is
            // for this navigation.
            !this.#matches(request.navigation)) {
              return;
            }
            this.#request = request;
            this.emit("request", request);
            const requestEmitter = this.#disposables.use(new EventEmitter(this.#request));
            requestEmitter.on("redirect", (request2) => {
              this.#request = request2;
            });
          });
          const sessionEmitter = this.#disposables.use(new EventEmitter(this.#session));
          sessionEmitter.on("browsingContext.navigationStarted", (info) => {
            if (info.context !== this.#browsingContext.id || this.#navigation !== void 0) {
              return;
            }
            this.#navigation = Navigation2.from(this.#browsingContext);
          });
          for (const eventName of [
            "browsingContext.domContentLoaded",
            "browsingContext.load"
          ]) {
            sessionEmitter.on(eventName, (info) => {
              if (info.context !== this.#browsingContext.id || info.navigation === null || !this.#matches(info.navigation)) {
                return;
              }
              this.dispose();
            });
          }
          for (const [eventName, event] of [
            ["browsingContext.fragmentNavigated", "fragment"],
            ["browsingContext.navigationFailed", "failed"],
            ["browsingContext.navigationAborted", "aborted"]
          ]) {
            sessionEmitter.on(eventName, (info) => {
              if (info.context !== this.#browsingContext.id || // Note we don't check if `navigation` is null since `null` means the
              // fragment navigated.
              !this.#matches(info.navigation)) {
                return;
              }
              this.emit(event, {
                url: info.url,
                timestamp: new Date(info.timestamp)
              });
              this.dispose();
            });
          }
        }
        #matches(navigation) {
          if (this.#navigation !== void 0 && !this.#navigation.disposed) {
            return false;
          }
          if (this.#id === void 0) {
            this.#id = navigation;
            return true;
          }
          return this.#id === navigation;
        }
        get #session() {
          return this.#browsingContext.userContext.browser.session;
        }
        get disposed() {
          return this.#disposables.disposed;
        }
        get request() {
          return this.#request;
        }
        get navigation() {
          return this.#navigation;
        }
        dispose() {
          this[disposeSymbol]();
        }
        [(_dispose_decorators = [inertIfDisposed], disposeSymbol)]() {
          this.#disposables.dispose();
          super[disposeSymbol]();
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js
var __runInitializers9, __esDecorate9, _a, Realm2, WindowRealm, DedicatedWorkerRealm, SharedWorkerRealm;
var init_Realm2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js"() {
    init_EventEmitter();
    init_decorators();
    init_disposable();
    __runInitializers9 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate9 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    Realm2 = (() => {
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _dispose_decorators;
      let _disown_decorators;
      let _callFunction_decorators;
      let _evaluate_decorators;
      let _resolveExecutionContextId_decorators;
      return class Realm extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate9(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate9(this, null, _disown_decorators, { kind: "method", name: "disown", static: false, private: false, access: { has: (obj) => "disown" in obj, get: (obj) => obj.disown }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate9(this, null, _callFunction_decorators, { kind: "method", name: "callFunction", static: false, private: false, access: { has: (obj) => "callFunction" in obj, get: (obj) => obj.callFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate9(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate9(this, null, _resolveExecutionContextId_decorators, { kind: "method", name: "resolveExecutionContextId", static: false, private: false, access: { has: (obj) => "resolveExecutionContextId" in obj, get: (obj) => obj.resolveExecutionContextId }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #reason = __runInitializers9(this, _instanceExtraInitializers);
        disposables = new DisposableStack();
        id;
        origin;
        executionContextId;
        constructor(id, origin) {
          super();
          this.id = id;
          this.origin = origin;
        }
        get disposed() {
          return this.#reason !== void 0;
        }
        get target() {
          return { realm: this.id };
        }
        dispose(reason) {
          this.#reason = reason;
          this[disposeSymbol]();
        }
        async disown(handles) {
          await this.session.send("script.disown", {
            target: this.target,
            handles
          });
        }
        async callFunction(functionDeclaration, awaitPromise, options = {}) {
          const { result } = await this.session.send("script.callFunction", {
            functionDeclaration,
            awaitPromise,
            target: this.target,
            ...options
          });
          return result;
        }
        async evaluate(expression, awaitPromise, options = {}) {
          const { result } = await this.session.send("script.evaluate", {
            expression,
            awaitPromise,
            target: this.target,
            ...options
          });
          return result;
        }
        async resolveExecutionContextId() {
          if (!this.executionContextId) {
            const { result } = await this.session.connection.send("goog:cdp.resolveRealm", { realm: this.id });
            this.executionContextId = result.executionContextId;
          }
          return this.executionContextId;
        }
        [(_dispose_decorators = [inertIfDisposed], _disown_decorators = [throwIfDisposed((realm) => {
          return realm.#reason;
        })], _callFunction_decorators = [throwIfDisposed((realm) => {
          return realm.#reason;
        })], _evaluate_decorators = [throwIfDisposed((realm) => {
          return realm.#reason;
        })], _resolveExecutionContextId_decorators = [throwIfDisposed((realm) => {
          return realm.#reason;
        })], disposeSymbol)]() {
          this.#reason ??= "Realm already destroyed, probably because all associated browsing contexts closed.";
          this.emit("destroyed", { reason: this.#reason });
          this.disposables.dispose();
          super[disposeSymbol]();
        }
      };
    })();
    WindowRealm = class extends Realm2 {
      static from(context2, sandbox) {
        const realm = new WindowRealm(context2, sandbox);
        realm.#initialize();
        return realm;
      }
      browsingContext;
      sandbox;
      #workers = /* @__PURE__ */ new Map();
      constructor(context2, sandbox) {
        super("", "");
        this.browsingContext = context2;
        this.sandbox = sandbox;
      }
      #initialize() {
        const browsingContextEmitter = this.disposables.use(new EventEmitter(this.browsingContext));
        browsingContextEmitter.on("closed", ({ reason }) => {
          this.dispose(reason);
        });
        const sessionEmitter = this.disposables.use(new EventEmitter(this.session));
        sessionEmitter.on("script.realmCreated", (info) => {
          if (info.type !== "window" || info.context !== this.browsingContext.id || info.sandbox !== this.sandbox) {
            return;
          }
          this.id = info.realm;
          this.origin = info.origin;
          this.executionContextId = void 0;
          this.emit("updated", this);
        });
        sessionEmitter.on("script.realmCreated", (info) => {
          if (info.type !== "dedicated-worker") {
            return;
          }
          if (!info.owners.includes(this.id)) {
            return;
          }
          const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
          this.#workers.set(realm.id, realm);
          const realmEmitter = this.disposables.use(new EventEmitter(realm));
          realmEmitter.once("destroyed", () => {
            realmEmitter.removeAllListeners();
            this.#workers.delete(realm.id);
          });
          this.emit("worker", realm);
        });
      }
      get session() {
        return this.browsingContext.userContext.browser.session;
      }
      get target() {
        return { context: this.browsingContext.id, sandbox: this.sandbox };
      }
    };
    DedicatedWorkerRealm = class extends Realm2 {
      static from(owner, id, origin) {
        const realm = new _a(owner, id, origin);
        realm.#initialize();
        return realm;
      }
      #workers = /* @__PURE__ */ new Map();
      owners;
      constructor(owner, id, origin) {
        super(id, origin);
        this.owners = /* @__PURE__ */ new Set([owner]);
      }
      #initialize() {
        const sessionEmitter = this.disposables.use(new EventEmitter(this.session));
        sessionEmitter.on("script.realmDestroyed", (info) => {
          if (info.realm !== this.id) {
            return;
          }
          this.dispose("Realm already destroyed.");
        });
        sessionEmitter.on("script.realmCreated", (info) => {
          if (info.type !== "dedicated-worker") {
            return;
          }
          if (!info.owners.includes(this.id)) {
            return;
          }
          const realm = _a.from(this, info.realm, info.origin);
          this.#workers.set(realm.id, realm);
          const realmEmitter = this.disposables.use(new EventEmitter(realm));
          realmEmitter.once("destroyed", () => {
            this.#workers.delete(realm.id);
          });
          this.emit("worker", realm);
        });
      }
      get session() {
        return this.owners.values().next().value.session;
      }
    };
    _a = DedicatedWorkerRealm;
    SharedWorkerRealm = class extends Realm2 {
      static from(browser, id, origin) {
        const realm = new SharedWorkerRealm(browser, id, origin);
        realm.#initialize();
        return realm;
      }
      #workers = /* @__PURE__ */ new Map();
      browser;
      constructor(browser, id, origin) {
        super(id, origin);
        this.browser = browser;
      }
      #initialize() {
        const sessionEmitter = this.disposables.use(new EventEmitter(this.session));
        sessionEmitter.on("script.realmDestroyed", (info) => {
          if (info.realm !== this.id) {
            return;
          }
          this.dispose("Realm already destroyed.");
        });
        sessionEmitter.on("script.realmCreated", (info) => {
          if (info.type !== "dedicated-worker") {
            return;
          }
          if (!info.owners.includes(this.id)) {
            return;
          }
          const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
          this.#workers.set(realm.id, realm);
          const realmEmitter = this.disposables.use(new EventEmitter(realm));
          realmEmitter.once("destroyed", () => {
            this.#workers.delete(realm.id);
          });
          this.emit("worker", realm);
        });
      }
      get session() {
        return this.browser.session;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js
var __runInitializers10, __esDecorate10, Request;
var init_Request = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js"() {
    init_EventEmitter();
    init_decorators();
    init_disposable();
    __runInitializers10 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate10 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    Request = (() => {
      var _a3;
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _dispose_decorators;
      return class Request2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate10(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browsingContext, event) {
          const request = new Request2(browsingContext, event);
          request.#initialize();
          return request;
        }
        #error = __runInitializers10(this, _instanceExtraInitializers);
        #redirect;
        #response;
        #browsingContext;
        #disposables = new DisposableStack();
        #event;
        constructor(browsingContext, event) {
          super();
          this.#browsingContext = browsingContext;
          this.#event = event;
        }
        #initialize() {
          const browsingContextEmitter = this.#disposables.use(new EventEmitter(this.#browsingContext));
          browsingContextEmitter.once("closed", ({ reason }) => {
            this.#error = reason;
            this.emit("error", this.#error);
            this.dispose();
          });
          const sessionEmitter = this.#disposables.use(new EventEmitter(this.#session));
          sessionEmitter.on("network.beforeRequestSent", (event) => {
            if (event.context !== this.#browsingContext.id || event.request.request !== this.id || event.redirectCount !== this.#event.redirectCount + 1) {
              return;
            }
            this.#redirect = Request2.from(this.#browsingContext, event);
            this.emit("redirect", this.#redirect);
            this.dispose();
          });
          sessionEmitter.on("network.authRequired", (event) => {
            if (event.context !== this.#browsingContext.id || event.request.request !== this.id || // Don't try to authenticate for events that are not blocked
            !event.isBlocked) {
              return;
            }
            this.emit("authenticate", void 0);
          });
          sessionEmitter.on("network.fetchError", (event) => {
            if (event.context !== this.#browsingContext.id || event.request.request !== this.id || this.#event.redirectCount !== event.redirectCount) {
              return;
            }
            this.#error = event.errorText;
            this.emit("error", this.#error);
            this.dispose();
          });
          sessionEmitter.on("network.responseCompleted", (event) => {
            if (event.context !== this.#browsingContext.id || event.request.request !== this.id || this.#event.redirectCount !== event.redirectCount) {
              return;
            }
            this.#response = event.response;
            this.#event.request.timings = event.request.timings;
            this.emit("success", this.#response);
            if (this.#response.status >= 300 && this.#response.status < 400) {
              return;
            }
            this.dispose();
          });
        }
        get #session() {
          return this.#browsingContext.userContext.browser.session;
        }
        get disposed() {
          return this.#disposables.disposed;
        }
        get error() {
          return this.#error;
        }
        get headers() {
          return this.#event.request.headers;
        }
        get id() {
          return this.#event.request.request;
        }
        get initiator() {
          return this.#event.initiator;
        }
        get method() {
          return this.#event.request.method;
        }
        get navigation() {
          return this.#event.navigation ?? void 0;
        }
        get redirect() {
          return this.#redirect;
        }
        get lastRedirect() {
          let redirect = this.#redirect;
          while (redirect) {
            if (redirect && !redirect.#redirect) {
              return redirect;
            }
            redirect = redirect.#redirect;
          }
          return redirect;
        }
        get response() {
          return this.#response;
        }
        get url() {
          return this.#event.request.url;
        }
        get isBlocked() {
          return this.#event.isBlocked;
        }
        get resourceType() {
          return this.#event.request["goog:resourceType"] ?? void 0;
        }
        get postData() {
          return this.#event.request["goog:postData"] ?? void 0;
        }
        get hasPostData() {
          return this.#event.request["goog:hasPostData"] ?? false;
        }
        async continueRequest({ url, method, headers, cookies, body }) {
          await this.#session.send("network.continueRequest", {
            request: this.id,
            url,
            method,
            headers,
            body,
            cookies
          });
        }
        async failRequest() {
          await this.#session.send("network.failRequest", {
            request: this.id
          });
        }
        async provideResponse({ statusCode, reasonPhrase, headers, body }) {
          await this.#session.send("network.provideResponse", {
            request: this.id,
            statusCode,
            reasonPhrase,
            headers,
            body
          });
        }
        async continueWithAuth(parameters) {
          if (parameters.action === "provideCredentials") {
            await this.#session.send("network.continueWithAuth", {
              request: this.id,
              action: parameters.action,
              credentials: parameters.credentials
            });
          } else {
            await this.#session.send("network.continueWithAuth", {
              request: this.id,
              action: parameters.action
            });
          }
        }
        dispose() {
          this[disposeSymbol]();
        }
        [(_dispose_decorators = [inertIfDisposed], disposeSymbol)]() {
          this.#disposables.dispose();
          super[disposeSymbol]();
        }
        timing() {
          return this.#event.request.timings;
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js
var __runInitializers11, __esDecorate11, UserPrompt;
var init_UserPrompt = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js"() {
    init_EventEmitter();
    init_decorators();
    init_disposable();
    __runInitializers11 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate11 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    UserPrompt = (() => {
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _dispose_decorators;
      let _handle_decorators;
      return class UserPrompt2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate11(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate11(this, null, _handle_decorators, { kind: "method", name: "handle", static: false, private: false, access: { has: (obj) => "handle" in obj, get: (obj) => obj.handle }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browsingContext, info) {
          const userPrompt = new UserPrompt2(browsingContext, info);
          userPrompt.#initialize();
          return userPrompt;
        }
        #reason = __runInitializers11(this, _instanceExtraInitializers);
        #result;
        #disposables = new DisposableStack();
        browsingContext;
        info;
        constructor(context2, info) {
          super();
          this.browsingContext = context2;
          this.info = info;
        }
        #initialize() {
          const browserContextEmitter = this.#disposables.use(new EventEmitter(this.browsingContext));
          browserContextEmitter.once("closed", ({ reason }) => {
            this.dispose(`User prompt already closed: ${reason}`);
          });
          const sessionEmitter = this.#disposables.use(new EventEmitter(this.#session));
          sessionEmitter.on("browsingContext.userPromptClosed", (parameters) => {
            if (parameters.context !== this.browsingContext.id) {
              return;
            }
            this.#result = parameters;
            this.emit("handled", parameters);
            this.dispose("User prompt already handled.");
          });
        }
        get #session() {
          return this.browsingContext.userContext.browser.session;
        }
        get closed() {
          return this.#reason !== void 0;
        }
        get disposed() {
          return this.closed;
        }
        get handled() {
          if (this.info.handler === "accept" || this.info.handler === "dismiss") {
            return true;
          }
          return this.#result !== void 0;
        }
        get result() {
          return this.#result;
        }
        dispose(reason) {
          this.#reason = reason;
          this[disposeSymbol]();
        }
        async handle(options = {}) {
          await this.#session.send("browsingContext.handleUserPrompt", {
            ...options,
            context: this.info.context
          });
          return this.#result;
        }
        [(_dispose_decorators = [inertIfDisposed], _handle_decorators = [throwIfDisposed((prompt) => {
          return prompt.#reason;
        })], disposeSymbol)]() {
          this.#reason ??= "User prompt already closed, probably because the associated browsing context was destroyed.";
          this.emit("closed", { reason: this.#reason });
          this.#disposables.dispose();
          super[disposeSymbol]();
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js
var __runInitializers12, __esDecorate12, BrowsingContext;
var init_BrowsingContext = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js"() {
    init_EventEmitter();
    init_decorators();
    init_disposable();
    init_Navigation();
    init_Realm2();
    init_Request();
    init_UserPrompt();
    __runInitializers12 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate12 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    BrowsingContext = (() => {
      var _a3;
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _dispose_decorators;
      let _activate_decorators;
      let _captureScreenshot_decorators;
      let _close_decorators;
      let _traverseHistory_decorators;
      let _navigate_decorators;
      let _reload_decorators;
      let _setCacheBehavior_decorators;
      let _print_decorators;
      let _handleUserPrompt_decorators;
      let _setViewport_decorators;
      let _performActions_decorators;
      let _releaseActions_decorators;
      let _createWindowRealm_decorators;
      let _addPreloadScript_decorators;
      let _addIntercept_decorators;
      let _removePreloadScript_decorators;
      let _getCookies_decorators;
      let _setCookie_decorators;
      let _setFiles_decorators;
      let _subscribe_decorators;
      let _addInterception_decorators;
      let _deleteCookie_decorators;
      let _locateNodes_decorators;
      return class BrowsingContext2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _deleteCookie_decorators = [throwIfDisposed((context2) => {
            return context2.#reason;
          })];
          _locateNodes_decorators = [throwIfDisposed((context2) => {
            return context2.#reason;
          })];
          __esDecorate12(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _activate_decorators, { kind: "method", name: "activate", static: false, private: false, access: { has: (obj) => "activate" in obj, get: (obj) => obj.activate }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _captureScreenshot_decorators, { kind: "method", name: "captureScreenshot", static: false, private: false, access: { has: (obj) => "captureScreenshot" in obj, get: (obj) => obj.captureScreenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: (obj) => "close" in obj, get: (obj) => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _traverseHistory_decorators, { kind: "method", name: "traverseHistory", static: false, private: false, access: { has: (obj) => "traverseHistory" in obj, get: (obj) => obj.traverseHistory }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _navigate_decorators, { kind: "method", name: "navigate", static: false, private: false, access: { has: (obj) => "navigate" in obj, get: (obj) => obj.navigate }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _reload_decorators, { kind: "method", name: "reload", static: false, private: false, access: { has: (obj) => "reload" in obj, get: (obj) => obj.reload }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _setCacheBehavior_decorators, { kind: "method", name: "setCacheBehavior", static: false, private: false, access: { has: (obj) => "setCacheBehavior" in obj, get: (obj) => obj.setCacheBehavior }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _print_decorators, { kind: "method", name: "print", static: false, private: false, access: { has: (obj) => "print" in obj, get: (obj) => obj.print }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _handleUserPrompt_decorators, { kind: "method", name: "handleUserPrompt", static: false, private: false, access: { has: (obj) => "handleUserPrompt" in obj, get: (obj) => obj.handleUserPrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _setViewport_decorators, { kind: "method", name: "setViewport", static: false, private: false, access: { has: (obj) => "setViewport" in obj, get: (obj) => obj.setViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _performActions_decorators, { kind: "method", name: "performActions", static: false, private: false, access: { has: (obj) => "performActions" in obj, get: (obj) => obj.performActions }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _releaseActions_decorators, { kind: "method", name: "releaseActions", static: false, private: false, access: { has: (obj) => "releaseActions" in obj, get: (obj) => obj.releaseActions }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _createWindowRealm_decorators, { kind: "method", name: "createWindowRealm", static: false, private: false, access: { has: (obj) => "createWindowRealm" in obj, get: (obj) => obj.createWindowRealm }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: (obj) => "addPreloadScript" in obj, get: (obj) => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _addIntercept_decorators, { kind: "method", name: "addIntercept", static: false, private: false, access: { has: (obj) => "addIntercept" in obj, get: (obj) => obj.addIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: (obj) => "removePreloadScript" in obj, get: (obj) => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: (obj) => "getCookies" in obj, get: (obj) => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: (obj) => "setCookie" in obj, get: (obj) => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: (obj) => "setFiles" in obj, get: (obj) => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: (obj) => "subscribe" in obj, get: (obj) => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _addInterception_decorators, { kind: "method", name: "addInterception", static: false, private: false, access: { has: (obj) => "addInterception" in obj, get: (obj) => obj.addInterception }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _deleteCookie_decorators, { kind: "method", name: "deleteCookie", static: false, private: false, access: { has: (obj) => "deleteCookie" in obj, get: (obj) => obj.deleteCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate12(this, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: (obj) => "locateNodes" in obj, get: (obj) => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(userContext, parent, id, url, originalOpener) {
          const browsingContext = new BrowsingContext2(userContext, parent, id, url, originalOpener);
          browsingContext.#initialize();
          return browsingContext;
        }
        #navigation = __runInitializers12(this, _instanceExtraInitializers);
        #reason;
        #url;
        #children = /* @__PURE__ */ new Map();
        #disposables = new DisposableStack();
        #realms = /* @__PURE__ */ new Map();
        #requests = /* @__PURE__ */ new Map();
        defaultRealm;
        id;
        parent;
        userContext;
        originalOpener;
        constructor(context2, parent, id, url, originalOpener) {
          super();
          this.#url = url;
          this.id = id;
          this.parent = parent;
          this.userContext = context2;
          this.originalOpener = originalOpener;
          this.defaultRealm = this.#createWindowRealm();
        }
        #initialize() {
          const userContextEmitter = this.#disposables.use(new EventEmitter(this.userContext));
          userContextEmitter.once("closed", ({ reason }) => {
            this.dispose(`Browsing context already closed: ${reason}`);
          });
          const sessionEmitter = this.#disposables.use(new EventEmitter(this.#session));
          sessionEmitter.on("browsingContext.contextCreated", (info) => {
            if (info.parent !== this.id) {
              return;
            }
            const browsingContext = BrowsingContext2.from(this.userContext, this, info.context, info.url, info.originalOpener);
            this.#children.set(info.context, browsingContext);
            const browsingContextEmitter = this.#disposables.use(new EventEmitter(browsingContext));
            browsingContextEmitter.once("closed", () => {
              browsingContextEmitter.removeAllListeners();
              this.#children.delete(browsingContext.id);
            });
            this.emit("browsingcontext", { browsingContext });
          });
          sessionEmitter.on("browsingContext.contextDestroyed", (info) => {
            if (info.context !== this.id) {
              return;
            }
            this.dispose("Browsing context already closed.");
          });
          sessionEmitter.on("browsingContext.historyUpdated", (info) => {
            if (info.context !== this.id) {
              return;
            }
            this.#url = info.url;
            this.emit("historyUpdated", void 0);
          });
          sessionEmitter.on("browsingContext.domContentLoaded", (info) => {
            if (info.context !== this.id) {
              return;
            }
            this.#url = info.url;
            this.emit("DOMContentLoaded", void 0);
          });
          sessionEmitter.on("browsingContext.load", (info) => {
            if (info.context !== this.id) {
              return;
            }
            this.#url = info.url;
            this.emit("load", void 0);
          });
          sessionEmitter.on("browsingContext.navigationStarted", (info) => {
            if (info.context !== this.id) {
              return;
            }
            for (const [id, request] of this.#requests) {
              if (request.disposed) {
                this.#requests.delete(id);
              }
            }
            if (this.#navigation !== void 0 && !this.#navigation.disposed) {
              return;
            }
            this.#navigation = Navigation.from(this);
            const navigationEmitter = this.#disposables.use(new EventEmitter(this.#navigation));
            for (const eventName of ["fragment", "failed", "aborted"]) {
              navigationEmitter.once(eventName, ({ url }) => {
                navigationEmitter[disposeSymbol]();
                this.#url = url;
              });
            }
            this.emit("navigation", { navigation: this.#navigation });
          });
          sessionEmitter.on("network.beforeRequestSent", (event) => {
            if (event.context !== this.id) {
              return;
            }
            if (this.#requests.has(event.request.request)) {
              return;
            }
            const request = Request.from(this, event);
            this.#requests.set(request.id, request);
            this.emit("request", { request });
          });
          sessionEmitter.on("log.entryAdded", (entry) => {
            if (entry.source.context !== this.id) {
              return;
            }
            this.emit("log", { entry });
          });
          sessionEmitter.on("browsingContext.userPromptOpened", (info) => {
            if (info.context !== this.id) {
              return;
            }
            const userPrompt = UserPrompt.from(this, info);
            this.emit("userprompt", { userPrompt });
          });
        }
        get #session() {
          return this.userContext.browser.session;
        }
        get children() {
          return this.#children.values();
        }
        get closed() {
          return this.#reason !== void 0;
        }
        get disposed() {
          return this.closed;
        }
        get realms() {
          const self2 = this;
          return function* () {
            yield self2.defaultRealm;
            yield* self2.#realms.values();
          }();
        }
        get top() {
          let context2 = this;
          for (let { parent } = context2; parent; { parent } = context2) {
            context2 = parent;
          }
          return context2;
        }
        get url() {
          return this.#url;
        }
        #createWindowRealm(sandbox) {
          const realm = WindowRealm.from(this, sandbox);
          realm.on("worker", (realm2) => {
            this.emit("worker", { realm: realm2 });
          });
          return realm;
        }
        dispose(reason) {
          this.#reason = reason;
          for (const context2 of this.#children.values()) {
            context2.dispose("Parent browsing context was disposed");
          }
          this[disposeSymbol]();
        }
        async activate() {
          await this.#session.send("browsingContext.activate", {
            context: this.id
          });
        }
        async captureScreenshot(options = {}) {
          const { result: { data } } = await this.#session.send("browsingContext.captureScreenshot", {
            context: this.id,
            ...options
          });
          return data;
        }
        async close(promptUnload) {
          await Promise.all([...this.#children.values()].map(async (child) => {
            await child.close(promptUnload);
          }));
          await this.#session.send("browsingContext.close", {
            context: this.id,
            promptUnload
          });
        }
        async traverseHistory(delta) {
          await this.#session.send("browsingContext.traverseHistory", {
            context: this.id,
            delta
          });
        }
        async navigate(url, wait) {
          await this.#session.send("browsingContext.navigate", {
            context: this.id,
            url,
            wait
          });
        }
        async reload(options = {}) {
          await this.#session.send("browsingContext.reload", {
            context: this.id,
            ...options
          });
        }
        async setCacheBehavior(cacheBehavior) {
          await this.#session.send("network.setCacheBehavior", {
            contexts: [this.id],
            cacheBehavior
          });
        }
        async print(options = {}) {
          const { result: { data } } = await this.#session.send("browsingContext.print", {
            context: this.id,
            ...options
          });
          return data;
        }
        async handleUserPrompt(options = {}) {
          await this.#session.send("browsingContext.handleUserPrompt", {
            context: this.id,
            ...options
          });
        }
        async setViewport(options = {}) {
          await this.#session.send("browsingContext.setViewport", {
            context: this.id,
            ...options
          });
        }
        async performActions(actions) {
          await this.#session.send("input.performActions", {
            context: this.id,
            actions
          });
        }
        async releaseActions() {
          await this.#session.send("input.releaseActions", {
            context: this.id
          });
        }
        createWindowRealm(sandbox) {
          return this.#createWindowRealm(sandbox);
        }
        async addPreloadScript(functionDeclaration, options = {}) {
          return await this.userContext.browser.addPreloadScript(functionDeclaration, {
            ...options,
            contexts: [this]
          });
        }
        async addIntercept(options) {
          const { result: { intercept } } = await this.userContext.browser.session.send("network.addIntercept", {
            ...options,
            contexts: [this.id]
          });
          return intercept;
        }
        async removePreloadScript(script) {
          await this.userContext.browser.removePreloadScript(script);
        }
        async getCookies(options = {}) {
          const { result: { cookies } } = await this.#session.send("storage.getCookies", {
            ...options,
            partition: {
              type: "context",
              context: this.id
            }
          });
          return cookies;
        }
        async setCookie(cookie) {
          await this.#session.send("storage.setCookie", {
            cookie,
            partition: {
              type: "context",
              context: this.id
            }
          });
        }
        async setFiles(element, files) {
          await this.#session.send("input.setFiles", {
            context: this.id,
            element,
            files
          });
        }
        async subscribe(events) {
          await this.#session.subscribe(events, [this.id]);
        }
        async addInterception(events) {
          await this.#session.subscribe(events, [this.id]);
        }
        [(_dispose_decorators = [inertIfDisposed], _activate_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _captureScreenshot_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _close_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _traverseHistory_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _navigate_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _reload_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _setCacheBehavior_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _print_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _handleUserPrompt_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _setViewport_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _performActions_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _releaseActions_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _createWindowRealm_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _addPreloadScript_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _addIntercept_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _removePreloadScript_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _getCookies_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _setCookie_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _setFiles_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _subscribe_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _addInterception_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], disposeSymbol)]() {
          this.#reason ??= "Browsing context already closed, probably because the user context closed.";
          this.emit("closed", { reason: this.#reason });
          this.#disposables.dispose();
          super[disposeSymbol]();
        }
        async deleteCookie(...cookieFilters) {
          await Promise.all(cookieFilters.map(async (filter2) => {
            await this.#session.send("storage.deleteCookies", {
              filter: filter2,
              partition: {
                type: "context",
                context: this.id
              }
            });
          }));
        }
        async locateNodes(locator, startNodes) {
          const result = await this.#session.send("browsingContext.locateNodes", {
            context: this.id,
            locator,
            startNodes: startNodes.length ? startNodes : void 0
          });
          return result.result.nodes;
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js
var __runInitializers13, __esDecorate13, UserContext;
var init_UserContext = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js"() {
    init_EventEmitter();
    init_assert();
    init_decorators();
    init_disposable();
    init_BrowsingContext();
    __runInitializers13 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate13 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    UserContext = (() => {
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _dispose_decorators;
      let _createBrowsingContext_decorators;
      let _remove_decorators;
      let _getCookies_decorators;
      let _setCookie_decorators;
      let _setPermissions_decorators;
      return class UserContext2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate13(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate13(this, null, _createBrowsingContext_decorators, { kind: "method", name: "createBrowsingContext", static: false, private: false, access: { has: (obj) => "createBrowsingContext" in obj, get: (obj) => obj.createBrowsingContext }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate13(this, null, _remove_decorators, { kind: "method", name: "remove", static: false, private: false, access: { has: (obj) => "remove" in obj, get: (obj) => obj.remove }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate13(this, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: (obj) => "getCookies" in obj, get: (obj) => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate13(this, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: (obj) => "setCookie" in obj, get: (obj) => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate13(this, null, _setPermissions_decorators, { kind: "method", name: "setPermissions", static: false, private: false, access: { has: (obj) => "setPermissions" in obj, get: (obj) => obj.setPermissions }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static DEFAULT = "default";
        static create(browser, id) {
          const context2 = new UserContext2(browser, id);
          context2.#initialize();
          return context2;
        }
        #reason = __runInitializers13(this, _instanceExtraInitializers);
        // Note these are only top-level contexts.
        #browsingContexts = /* @__PURE__ */ new Map();
        #disposables = new DisposableStack();
        #id;
        browser;
        constructor(browser, id) {
          super();
          this.#id = id;
          this.browser = browser;
        }
        #initialize() {
          const browserEmitter = this.#disposables.use(new EventEmitter(this.browser));
          browserEmitter.once("closed", ({ reason }) => {
            this.dispose(`User context was closed: ${reason}`);
          });
          browserEmitter.once("disconnected", ({ reason }) => {
            this.dispose(`User context was closed: ${reason}`);
          });
          const sessionEmitter = this.#disposables.use(new EventEmitter(this.#session));
          sessionEmitter.on("browsingContext.contextCreated", (info) => {
            if (info.parent) {
              return;
            }
            if (info.userContext !== this.#id) {
              return;
            }
            const browsingContext = BrowsingContext.from(this, void 0, info.context, info.url, info.originalOpener);
            this.#browsingContexts.set(browsingContext.id, browsingContext);
            const browsingContextEmitter = this.#disposables.use(new EventEmitter(browsingContext));
            browsingContextEmitter.on("closed", () => {
              browsingContextEmitter.removeAllListeners();
              this.#browsingContexts.delete(browsingContext.id);
            });
            this.emit("browsingcontext", { browsingContext });
          });
        }
        get #session() {
          return this.browser.session;
        }
        get browsingContexts() {
          return this.#browsingContexts.values();
        }
        get closed() {
          return this.#reason !== void 0;
        }
        get disposed() {
          return this.closed;
        }
        get id() {
          return this.#id;
        }
        dispose(reason) {
          this.#reason = reason;
          this[disposeSymbol]();
        }
        async createBrowsingContext(type, options = {}) {
          const { result: { context: contextId } } = await this.#session.send("browsingContext.create", {
            type,
            ...options,
            referenceContext: options.referenceContext?.id,
            userContext: this.#id
          });
          const browsingContext = this.#browsingContexts.get(contextId);
          assert(browsingContext, "The WebDriver BiDi implementation is failing to create a browsing context correctly.");
          return browsingContext;
        }
        async remove() {
          try {
            await this.#session.send("browser.removeUserContext", {
              userContext: this.#id
            });
          } finally {
            this.dispose("User context already closed.");
          }
        }
        async getCookies(options = {}, sourceOrigin = void 0) {
          const { result: { cookies } } = await this.#session.send("storage.getCookies", {
            ...options,
            partition: {
              type: "storageKey",
              userContext: this.#id,
              sourceOrigin
            }
          });
          return cookies;
        }
        async setCookie(cookie, sourceOrigin) {
          await this.#session.send("storage.setCookie", {
            cookie,
            partition: {
              type: "storageKey",
              sourceOrigin,
              userContext: this.id
            }
          });
        }
        async setPermissions(origin, descriptor, state) {
          await this.#session.send("permissions.setPermission", {
            origin,
            descriptor,
            state,
            userContext: this.#id
          });
        }
        [(_dispose_decorators = [inertIfDisposed], _createBrowsingContext_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _remove_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _getCookies_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _setCookie_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], _setPermissions_decorators = [throwIfDisposed((context2) => {
          return context2.#reason;
        })], disposeSymbol)]() {
          this.#reason ??= "User context already closed, probably because the browser disconnected/closed.";
          this.emit("closed", { reason: this.#reason });
          this.#disposables.dispose();
          super[disposeSymbol]();
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js
var _deserializeNumber, deserializeNumber_fn, _deserializeTuple, deserializeTuple_fn, BidiDeserializer;
var init_Deserializer = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js"() {
    init_util();
    BidiDeserializer = class {
      static deserialize(result) {
        if (!result) {
          debugError("Service did not produce a result.");
          return void 0;
        }
        switch (result.type) {
          case "array":
            return result.value?.map((value) => {
              return this.deserialize(value);
            });
          case "set":
            return result.value?.reduce((acc, value) => {
              return acc.add(this.deserialize(value));
            }, /* @__PURE__ */ new Set());
          case "object":
            return result.value?.reduce((acc, tuple) => {
              const { key, value } = __privateMethod(this, _deserializeTuple, deserializeTuple_fn).call(this, tuple);
              acc[key] = value;
              return acc;
            }, {});
          case "map":
            return result.value?.reduce((acc, tuple) => {
              const { key, value } = __privateMethod(this, _deserializeTuple, deserializeTuple_fn).call(this, tuple);
              return acc.set(key, value);
            }, /* @__PURE__ */ new Map());
          case "promise":
            return {};
          case "regexp":
            return new RegExp(result.value.pattern, result.value.flags);
          case "date":
            return new Date(result.value);
          case "undefined":
            return void 0;
          case "null":
            return null;
          case "number":
            return __privateMethod(this, _deserializeNumber, deserializeNumber_fn).call(this, result.value);
          case "bigint":
            return BigInt(result.value);
          case "boolean":
            return Boolean(result.value);
          case "string":
            return result.value;
        }
        debugError(`Deserialization of type ${result.type} not supported.`);
        return void 0;
      }
    };
    _deserializeNumber = new WeakSet();
    deserializeNumber_fn = function(value) {
      switch (value) {
        case "-0":
          return -0;
        case "NaN":
          return NaN;
        case "Infinity":
          return Infinity;
        case "-Infinity":
          return -Infinity;
        default:
          return value;
      }
    };
    _deserializeTuple = new WeakSet();
    deserializeTuple_fn = function([serializedKey, serializedValue]) {
      const key = typeof serializedKey === "string" ? serializedKey : this.deserialize(serializedKey);
      const value = this.deserialize(serializedValue);
      return { key, value };
    };
    __privateAdd(BidiDeserializer, _deserializeNumber);
    __privateAdd(BidiDeserializer, _deserializeTuple);
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js
var BidiDialog;
var init_Dialog2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js"() {
    init_Dialog();
    BidiDialog = class extends Dialog {
      static from(prompt) {
        return new BidiDialog(prompt);
      }
      #prompt;
      constructor(prompt) {
        super(prompt.info.type, prompt.info.message, prompt.info.defaultValue);
        this.#prompt = prompt;
        this.handled = prompt.handled;
      }
      async handle(options) {
        await this.#prompt.handle({
          accept: options.accept,
          userText: options.text
        });
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js
var BidiJSHandle;
var init_JSHandle2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js"() {
    init_JSHandle();
    init_Errors();
    init_Deserializer();
    BidiJSHandle = class extends JSHandle {
      static from(value, realm) {
        return new BidiJSHandle(value, realm);
      }
      #remoteValue;
      realm;
      #disposed = false;
      constructor(value, realm) {
        super();
        this.#remoteValue = value;
        this.realm = realm;
      }
      get disposed() {
        return this.#disposed;
      }
      async jsonValue() {
        return await this.evaluate((value) => {
          return value;
        });
      }
      asElement() {
        return null;
      }
      async dispose() {
        if (this.#disposed) {
          return;
        }
        this.#disposed = true;
        await this.realm.destroyHandles([this]);
      }
      get isPrimitiveValue() {
        switch (this.#remoteValue.type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean":
          case "undefined":
          case "null":
            return true;
          default:
            return false;
        }
      }
      toString() {
        if (this.isPrimitiveValue) {
          return "JSHandle:" + BidiDeserializer.deserialize(this.#remoteValue);
        }
        return "JSHandle@" + this.#remoteValue.type;
      }
      get id() {
        return "handle" in this.#remoteValue ? this.#remoteValue.handle : void 0;
      }
      remoteValue() {
        return this.#remoteValue;
      }
      remoteObject() {
        throw new UnsupportedOperation("Not available in WebDriver BiDi");
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js
var __runInitializers14, __esDecorate14, __addDisposableResource14, __disposeResources14, BidiElementHandle;
var init_ElementHandle2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js"() {
    init_ElementHandle();
    init_Errors();
    init_environment();
    init_AsyncIterableUtil();
    init_decorators();
    init_JSHandle2();
    __runInitializers14 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate14 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __addDisposableResource14 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources14 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    BidiElementHandle = (() => {
      let _classSuper = ElementHandle;
      let _instanceExtraInitializers = [];
      let _autofill_decorators;
      let _contentFrame_decorators;
      return class BidiElementHandle2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _autofill_decorators = [throwIfDisposed()];
          _contentFrame_decorators = [throwIfDisposed(), bindIsolatedHandle];
          __esDecorate14(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate14(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #backendNodeId = __runInitializers14(this, _instanceExtraInitializers);
        static from(value, realm) {
          return new BidiElementHandle2(value, realm);
        }
        constructor(value, realm) {
          super(BidiJSHandle.from(value, realm));
        }
        get realm() {
          return this.handle.realm;
        }
        get frame() {
          return this.realm.environment;
        }
        remoteValue() {
          return this.handle.remoteValue();
        }
        async autofill(data) {
          const client = this.frame.client;
          const nodeInfo = await client.send("DOM.describeNode", {
            objectId: this.handle.id
          });
          const fieldId = nodeInfo.node.backendNodeId;
          const frameId = this.frame._id;
          await client.send("Autofill.trigger", {
            fieldId,
            frameId,
            card: data.creditCard
          });
        }
        async contentFrame() {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource14(env_1, await this.evaluateHandle((element) => {
              if (element instanceof HTMLIFrameElement || element instanceof HTMLFrameElement) {
                return element.contentWindow;
              }
              return;
            }), false);
            const value = handle.remoteValue();
            if (value.type === "window") {
              return this.frame.page().frames().find((frame) => {
                return frame._id === value.value.context;
              }) ?? null;
            }
            return null;
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources14(env_1);
          }
        }
        async uploadFile(...files) {
          const path = environment.value.path;
          if (path) {
            files = files.map((file) => {
              if (path.win32.isAbsolute(file) || path.posix.isAbsolute(file)) {
                return file;
              } else {
                return path.resolve(file);
              }
            });
          }
          await this.frame.setFiles(this, files);
        }
        async *queryAXTree(name, role) {
          const results = await this.frame.locateNodes(this, {
            type: "accessibility",
            value: {
              role,
              name
            }
          });
          return yield* AsyncIterableUtil.map(results, (node) => {
            return Promise.resolve(BidiElementHandle2.from(node, this.realm));
          });
        }
        async backendNodeId() {
          if (!this.frame.page().browser().cdpSupported) {
            throw new UnsupportedOperation();
          }
          if (this.#backendNodeId) {
            return this.#backendNodeId;
          }
          const { node } = await this.frame.client.send("DOM.describeNode", {
            objectId: this.handle.id
          });
          this.#backendNodeId = node.backendNodeId;
          return this.#backendNodeId;
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js
var Bidi, __addDisposableResource15, __disposeResources15, ExposableFunction;
var init_ExposedFunction = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js"() {
    Bidi = __toESM(require_protocol(), 1);
    init_EventEmitter();
    init_util();
    init_disposable();
    init_Function();
    init_ElementHandle2();
    init_JSHandle2();
    __addDisposableResource15 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources15 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    ExposableFunction = class {
      static async from(frame, name, apply, isolate = false) {
        const func = new ExposableFunction(frame, name, apply, isolate);
        await func.#initialize();
        return func;
      }
      #frame;
      name;
      #apply;
      #isolate;
      #channel;
      #scripts = [];
      #disposables = new DisposableStack();
      constructor(frame, name, apply, isolate = false) {
        this.#frame = frame;
        this.name = name;
        this.#apply = apply;
        this.#isolate = isolate;
        this.#channel = `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}`;
      }
      async #initialize() {
        const connection = this.#connection;
        const channel = {
          type: "channel",
          value: {
            channel: this.#channel,
            ownership: "root"
          }
        };
        const connectionEmitter = this.#disposables.use(new EventEmitter(connection));
        connectionEmitter.on(Bidi.ChromiumBidi.Script.EventNames.Message, this.#handleMessage);
        const functionDeclaration = stringifyFunction(interpolateFunction((callback) => {
          Object.assign(globalThis, {
            [PLACEHOLDER("name")]: function(...args) {
              return new Promise((resolve, reject) => {
                callback([resolve, reject, args]);
              });
            }
          });
        }, { name: JSON.stringify(this.name) }));
        const frames = [this.#frame];
        for (const frame of frames) {
          frames.push(...frame.childFrames());
        }
        await Promise.all(frames.map(async (frame) => {
          const realm = this.#isolate ? frame.isolatedRealm() : frame.mainRealm();
          try {
            const [script] = await Promise.all([
              frame.browsingContext.addPreloadScript(functionDeclaration, {
                arguments: [channel],
                sandbox: realm.sandbox
              }),
              realm.realm.callFunction(functionDeclaration, false, {
                arguments: [channel]
              })
            ]);
            this.#scripts.push([frame, script]);
          } catch (error) {
            debugError(error);
          }
        }));
      }
      get #connection() {
        return this.#frame.page().browser().connection;
      }
      #handleMessage = async (params) => {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          if (params.channel !== this.#channel) {
            return;
          }
          const realm = this.#getRealm(params.source);
          if (!realm) {
            return;
          }
          const dataHandle = __addDisposableResource15(env_1, BidiJSHandle.from(params.data, realm), false);
          const argsHandle = __addDisposableResource15(env_1, await dataHandle.evaluateHandle(([, , args2]) => {
            return args2;
          }), false);
          const stack = __addDisposableResource15(env_1, new DisposableStack(), false);
          const args = [];
          for (const [index, handle] of await argsHandle.getProperties()) {
            stack.use(handle);
            if (handle instanceof BidiElementHandle) {
              args[+index] = handle;
              stack.use(handle);
              continue;
            }
            args[+index] = handle.jsonValue();
          }
          let result;
          try {
            result = await this.#apply(...await Promise.all(args));
          } catch (error) {
            try {
              if (error instanceof Error) {
                await dataHandle.evaluate(([, reject], name, message, stack2) => {
                  const error2 = new Error(message);
                  error2.name = name;
                  if (stack2) {
                    error2.stack = stack2;
                  }
                  reject(error2);
                }, error.name, error.message, error.stack);
              } else {
                await dataHandle.evaluate(([, reject], error2) => {
                  reject(error2);
                }, error);
              }
            } catch (error2) {
              debugError(error2);
            }
            return;
          }
          try {
            await dataHandle.evaluate(([resolve], result2) => {
              resolve(result2);
            }, result);
          } catch (error) {
            debugError(error);
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources15(env_1);
        }
      };
      #getRealm(source2) {
        const frame = this.#findFrame(source2.context);
        if (!frame) {
          return;
        }
        return frame.realm(source2.realm);
      }
      #findFrame(id) {
        const frames = [this.#frame];
        for (const frame of frames) {
          if (frame._id === id) {
            return frame;
          }
          frames.push(...frame.childFrames());
        }
        return;
      }
      [Symbol.dispose]() {
        void this[Symbol.asyncDispose]().catch(debugError);
      }
      async [Symbol.asyncDispose]() {
        this.#disposables.dispose();
        await Promise.all(this.#scripts.map(async ([frame, script]) => {
          const realm = this.#isolate ? frame.isolatedRealm() : frame.mainRealm();
          try {
            await Promise.all([
              realm.evaluate((name) => {
                delete globalThis[name];
              }, this.name),
              ...frame.childFrames().map((childFrame) => {
                return childFrame.evaluate((name) => {
                  delete globalThis[name];
                }, this.name);
              }),
              frame.browsingContext.removePreloadScript(script)
            ]);
          } catch (error) {
            debugError(error);
          }
        }));
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js
var __runInitializers15, __esDecorate15, BidiHTTPResponse;
var init_HTTPResponse2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js"() {
    init_HTTPResponse();
    init_Errors();
    init_SecurityDetails();
    init_decorators();
    __runInitializers15 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate15 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    BidiHTTPResponse = (() => {
      let _classSuper = HTTPResponse;
      let _instanceExtraInitializers = [];
      let _remoteAddress_decorators;
      return class BidiHTTPResponse2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _remoteAddress_decorators = [invokeAtMostOnceForArguments];
          __esDecorate15(this, null, _remoteAddress_decorators, { kind: "method", name: "remoteAddress", static: false, private: false, access: { has: (obj) => "remoteAddress" in obj, get: (obj) => obj.remoteAddress }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(data, request, cdpSupported) {
          const response = new BidiHTTPResponse2(data, request, cdpSupported);
          response.#initialize();
          return response;
        }
        #data = __runInitializers15(this, _instanceExtraInitializers);
        #request;
        #securityDetails;
        #cdpSupported = false;
        constructor(data, request, cdpSupported) {
          super();
          this.#data = data;
          this.#request = request;
          this.#cdpSupported = cdpSupported;
          const securityDetails = data["goog:securityDetails"];
          if (cdpSupported && securityDetails) {
            this.#securityDetails = new SecurityDetails(securityDetails);
          }
        }
        #initialize() {
          if (this.#data.fromCache) {
            this.#request._fromMemoryCache = true;
            this.#request.frame()?.page().trustedEmitter.emit("requestservedfromcache", this.#request);
          }
          this.#request.frame()?.page().trustedEmitter.emit("response", this);
        }
        remoteAddress() {
          return {
            ip: "",
            port: -1
          };
        }
        url() {
          return this.#data.url;
        }
        status() {
          return this.#data.status;
        }
        statusText() {
          return this.#data.statusText;
        }
        headers() {
          const headers = {};
          for (const header of this.#data.headers) {
            if (header.value.type === "string") {
              headers[header.name.toLowerCase()] = header.value.value;
            }
          }
          return headers;
        }
        request() {
          return this.#request;
        }
        fromCache() {
          return this.#data.fromCache;
        }
        timing() {
          const bidiTiming = this.#request.timing();
          return {
            requestTime: bidiTiming.requestTime,
            proxyStart: -1,
            proxyEnd: -1,
            dnsStart: bidiTiming.dnsStart,
            dnsEnd: bidiTiming.dnsEnd,
            connectStart: bidiTiming.connectStart,
            connectEnd: bidiTiming.connectEnd,
            sslStart: bidiTiming.tlsStart,
            sslEnd: -1,
            workerStart: -1,
            workerReady: -1,
            workerFetchStart: -1,
            workerRespondWithSettled: -1,
            workerRouterEvaluationStart: -1,
            workerCacheLookupStart: -1,
            sendStart: bidiTiming.requestStart,
            sendEnd: -1,
            pushStart: -1,
            pushEnd: -1,
            receiveHeadersStart: bidiTiming.responseStart,
            receiveHeadersEnd: bidiTiming.responseEnd
          };
        }
        frame() {
          return this.#request.frame();
        }
        fromServiceWorker() {
          return false;
        }
        securityDetails() {
          if (!this.#cdpSupported) {
            throw new UnsupportedOperation();
          }
          return this.#securityDetails ?? null;
        }
        content() {
          throw new UnsupportedOperation();
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js
function getBidiHeaders(rawHeaders) {
  const headers = [];
  for (const [name, value] of Object.entries(rawHeaders ?? [])) {
    if (!Object.is(value, void 0)) {
      const values = Array.isArray(value) ? value : [value];
      for (const value2 of values) {
        headers.push({
          name: name.toLowerCase(),
          value: {
            type: "string",
            value: String(value2)
          }
        });
      }
    }
  }
  return headers;
}
var _a2, requests, BidiHTTPRequest;
var init_HTTPRequest2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js"() {
    init_HTTPRequest();
    init_Errors();
    init_encoding();
    init_HTTPResponse2();
    requests = /* @__PURE__ */ new WeakMap();
    BidiHTTPRequest = class extends HTTPRequest {
      static from(bidiRequest, frame, redirect) {
        const request = new _a2(bidiRequest, frame, redirect);
        request.#initialize();
        return request;
      }
      #redirectChain;
      #response = null;
      id;
      #frame;
      #request;
      constructor(request, frame, redirect) {
        super();
        requests.set(request, this);
        this.interception.enabled = request.isBlocked;
        this.#request = request;
        this.#frame = frame;
        this.#redirectChain = redirect ? redirect.#redirectChain : [];
        this.id = request.id;
      }
      get client() {
        return this.#frame.client;
      }
      #initialize() {
        this.#request.on("redirect", (request) => {
          const httpRequest = _a2.from(request, this.#frame, this);
          this.#redirectChain.push(this);
          request.once("success", () => {
            this.#frame.page().trustedEmitter.emit("requestfinished", httpRequest);
          });
          request.once("error", () => {
            this.#frame.page().trustedEmitter.emit("requestfailed", httpRequest);
          });
          void httpRequest.finalizeInterceptions();
        });
        this.#request.once("success", (data) => {
          this.#response = BidiHTTPResponse.from(data, this, this.#frame.page().browser().cdpSupported);
        });
        this.#request.on("authenticate", this.#handleAuthentication);
        this.#frame.page().trustedEmitter.emit("request", this);
        if (this.#hasInternalHeaderOverwrite) {
          this.interception.handlers.push(async () => {
            await this.continue({
              headers: this.headers()
            }, 0);
          });
        }
      }
      url() {
        return this.#request.url;
      }
      resourceType() {
        if (!this.#frame.page().browser().cdpSupported) {
          throw new UnsupportedOperation();
        }
        return (this.#request.resourceType || "other").toLowerCase();
      }
      method() {
        return this.#request.method;
      }
      postData() {
        if (!this.#frame.page().browser().cdpSupported) {
          throw new UnsupportedOperation();
        }
        return this.#request.postData;
      }
      hasPostData() {
        if (!this.#frame.page().browser().cdpSupported) {
          throw new UnsupportedOperation();
        }
        return this.#request.hasPostData;
      }
      async fetchPostData() {
        throw new UnsupportedOperation();
      }
      get #hasInternalHeaderOverwrite() {
        return Boolean(Object.keys(this.#extraHTTPHeaders).length || Object.keys(this.#userAgentHeaders).length);
      }
      get #extraHTTPHeaders() {
        return this.#frame?.page()._extraHTTPHeaders ?? {};
      }
      get #userAgentHeaders() {
        return this.#frame?.page()._userAgentHeaders ?? {};
      }
      headers() {
        const headers = {};
        for (const header of this.#request.headers) {
          headers[header.name.toLowerCase()] = header.value.value;
        }
        return {
          ...headers,
          ...this.#extraHTTPHeaders,
          ...this.#userAgentHeaders
        };
      }
      response() {
        return this.#response;
      }
      failure() {
        if (this.#request.error === void 0) {
          return null;
        }
        return { errorText: this.#request.error };
      }
      isNavigationRequest() {
        return this.#request.navigation !== void 0;
      }
      initiator() {
        return {
          ...this.#request.initiator,
          type: this.#request.initiator?.type ?? "other"
        };
      }
      redirectChain() {
        return this.#redirectChain.slice();
      }
      frame() {
        return this.#frame;
      }
      async continue(overrides, priority) {
        return await super.continue({
          headers: this.#hasInternalHeaderOverwrite ? this.headers() : void 0,
          ...overrides
        }, priority);
      }
      async _continue(overrides = {}) {
        const headers = getBidiHeaders(overrides.headers);
        this.interception.handled = true;
        return await this.#request.continueRequest({
          url: overrides.url,
          method: overrides.method,
          body: overrides.postData ? {
            type: "base64",
            value: stringToBase64(overrides.postData)
          } : void 0,
          headers: headers.length > 0 ? headers : void 0
        }).catch((error) => {
          this.interception.handled = false;
          return handleError(error);
        });
      }
      async _abort() {
        this.interception.handled = true;
        return await this.#request.failRequest().catch((error) => {
          this.interception.handled = false;
          throw error;
        });
      }
      async _respond(response, _priority) {
        this.interception.handled = true;
        let parsedBody;
        if (response.body) {
          parsedBody = HTTPRequest.getResponse(response.body);
        }
        const headers = getBidiHeaders(response.headers);
        const hasContentLength = headers.some((header) => {
          return header.name === "content-length";
        });
        if (response.contentType) {
          headers.push({
            name: "content-type",
            value: {
              type: "string",
              value: response.contentType
            }
          });
        }
        if (parsedBody?.contentLength && !hasContentLength) {
          headers.push({
            name: "content-length",
            value: {
              type: "string",
              value: String(parsedBody.contentLength)
            }
          });
        }
        const status = response.status || 200;
        return await this.#request.provideResponse({
          statusCode: status,
          headers: headers.length > 0 ? headers : void 0,
          reasonPhrase: STATUS_TEXTS[status],
          body: parsedBody?.base64 ? {
            type: "base64",
            value: parsedBody?.base64
          } : void 0
        }).catch((error) => {
          this.interception.handled = false;
          throw error;
        });
      }
      #authenticationHandled = false;
      #handleAuthentication = async () => {
        if (!this.#frame) {
          return;
        }
        const credentials = this.#frame.page()._credentials;
        if (credentials && !this.#authenticationHandled) {
          this.#authenticationHandled = true;
          void this.#request.continueWithAuth({
            action: "provideCredentials",
            credentials: {
              type: "password",
              username: credentials.username,
              password: credentials.password
            }
          });
        } else {
          void this.#request.continueWithAuth({
            action: "cancel"
          });
        }
      };
      timing() {
        return this.#request.timing();
      }
    };
    _a2 = BidiHTTPRequest;
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js
var UnserializableError, _serializeNumber, serializeNumber_fn, _serializeObject, serializeObject_fn, BidiSerializer;
var init_Serializer = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js"() {
    init_util();
    UnserializableError = class extends Error {
    };
    BidiSerializer = class {
      static serialize(arg) {
        switch (typeof arg) {
          case "symbol":
          case "function":
            throw new UnserializableError(`Unable to serializable ${typeof arg}`);
          case "object":
            return __privateMethod(this, _serializeObject, serializeObject_fn).call(this, arg);
          case "undefined":
            return {
              type: "undefined"
            };
          case "number":
            return __privateMethod(this, _serializeNumber, serializeNumber_fn).call(this, arg);
          case "bigint":
            return {
              type: "bigint",
              value: arg.toString()
            };
          case "string":
            return {
              type: "string",
              value: arg
            };
          case "boolean":
            return {
              type: "boolean",
              value: arg
            };
        }
      }
    };
    _serializeNumber = new WeakSet();
    serializeNumber_fn = function(arg) {
      let value;
      if (Object.is(arg, -0)) {
        value = "-0";
      } else if (Object.is(arg, Infinity)) {
        value = "Infinity";
      } else if (Object.is(arg, -Infinity)) {
        value = "-Infinity";
      } else if (Object.is(arg, NaN)) {
        value = "NaN";
      } else {
        value = arg;
      }
      return {
        type: "number",
        value
      };
    };
    _serializeObject = new WeakSet();
    serializeObject_fn = function(arg) {
      if (arg === null) {
        return {
          type: "null"
        };
      } else if (Array.isArray(arg)) {
        const parsedArray = arg.map((subArg) => {
          return this.serialize(subArg);
        });
        return {
          type: "array",
          value: parsedArray
        };
      } else if (isPlainObject(arg)) {
        try {
          JSON.stringify(arg);
        } catch (error) {
          if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
            error.message += " Recursive objects are not allowed.";
          }
          throw error;
        }
        const parsedObject = [];
        for (const key in arg) {
          parsedObject.push([this.serialize(key), this.serialize(arg[key])]);
        }
        return {
          type: "object",
          value: parsedObject
        };
      } else if (isRegExp(arg)) {
        return {
          type: "regexp",
          value: {
            pattern: arg.source,
            flags: arg.flags
          }
        };
      } else if (isDate(arg)) {
        return {
          type: "date",
          value: arg.toISOString()
        };
      }
      throw new UnserializableError("Custom object serialization not possible. Use plain objects instead.");
    };
    __privateAdd(BidiSerializer, _serializeNumber);
    __privateAdd(BidiSerializer, _serializeObject);
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js
function createEvaluationError2(details) {
  if (details.exception.type !== "error") {
    return BidiDeserializer.deserialize(details.exception);
  }
  const [name = "", ...parts] = details.text.split(": ");
  const message = parts.join(": ");
  const error = new Error(message);
  error.name = name;
  const stackLines = [];
  if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
    for (const frame of details.stackTrace.callFrames.reverse()) {
      if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
        const url = PuppeteerURL.parse(frame.url);
        stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
      } else {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
      }
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [details.text, ...stackLines].join("\n");
  return error;
}
function rewriteNavigationError(message, ms) {
  return (error) => {
    if (error instanceof ProtocolError) {
      error.message += ` at ${message}`;
    } else if (error instanceof TimeoutError) {
      error.message = `Navigation timeout of ${ms} ms exceeded`;
    }
    throw error;
  };
}
var init_util2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js"() {
    init_Errors();
    init_util();
    init_Deserializer();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js
var __addDisposableResource16, __disposeResources16, BidiRealm, BidiFrameRealm, BidiWorkerRealm;
var init_Realm3 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js"() {
    init_Realm();
    init_AriaQueryHandler();
    init_LazyArg();
    init_ScriptInjector();
    init_util();
    init_AsyncIterableUtil();
    init_Function();
    init_Deserializer();
    init_ElementHandle2();
    init_ExposedFunction();
    init_JSHandle2();
    init_Serializer();
    init_util2();
    __addDisposableResource16 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources16 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    BidiRealm = class extends Realm {
      realm;
      constructor(realm, timeoutSettings) {
        super(timeoutSettings);
        this.realm = realm;
      }
      initialize() {
        this.realm.on("destroyed", ({ reason }) => {
          this.taskManager.terminateAll(new Error(reason));
          this.dispose();
        });
        this.realm.on("updated", () => {
          this.internalPuppeteerUtil = void 0;
          void this.taskManager.rerunAll();
        });
      }
      internalPuppeteerUtil;
      get puppeteerUtil() {
        const promise = Promise.resolve();
        scriptInjector.inject((script) => {
          if (this.internalPuppeteerUtil) {
            void this.internalPuppeteerUtil.then((handle) => {
              void handle.dispose();
            });
          }
          this.internalPuppeteerUtil = promise.then(() => {
            return this.evaluateHandle(script);
          });
        }, !this.internalPuppeteerUtil);
        return this.internalPuppeteerUtil;
      }
      async evaluateHandle(pageFunction, ...args) {
        return await this.#evaluate(false, pageFunction, ...args);
      }
      async evaluate(pageFunction, ...args) {
        return await this.#evaluate(true, pageFunction, ...args);
      }
      async #evaluate(returnByValue, pageFunction, ...args) {
        const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
        let responsePromise;
        const resultOwnership = returnByValue ? "none" : "root";
        const serializationOptions = returnByValue ? {} : {
          maxObjectDepth: 0,
          maxDomDepth: 0
        };
        if (isString(pageFunction)) {
          const expression = SOURCE_URL_REGEX.test(pageFunction) ? pageFunction : `${pageFunction}
${sourceUrlComment}
`;
          responsePromise = this.realm.evaluate(expression, true, {
            resultOwnership,
            userActivation: true,
            serializationOptions
          });
        } else {
          let functionDeclaration = stringifyFunction(pageFunction);
          functionDeclaration = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
          responsePromise = this.realm.callFunction(
            functionDeclaration,
            /* awaitPromise= */
            true,
            {
              // LazyArgs are used only internally and should not affect the order
              // evaluate calls for the public APIs.
              arguments: args.some((arg) => {
                return arg instanceof LazyArg;
              }) ? await Promise.all(args.map((arg) => {
                return this.serializeAsync(arg);
              })) : args.map((arg) => {
                return this.serialize(arg);
              }),
              resultOwnership,
              userActivation: true,
              serializationOptions
            }
          );
        }
        const result = await responsePromise;
        if ("type" in result && result.type === "exception") {
          throw createEvaluationError2(result.exceptionDetails);
        }
        return returnByValue ? BidiDeserializer.deserialize(result.result) : this.createHandle(result.result);
      }
      createHandle(result) {
        if ((result.type === "node" || result.type === "window") && this instanceof BidiFrameRealm) {
          return BidiElementHandle.from(result, this);
        }
        return BidiJSHandle.from(result, this);
      }
      async serializeAsync(arg) {
        if (arg instanceof LazyArg) {
          arg = await arg.get(this);
        }
        return this.serialize(arg);
      }
      serialize(arg) {
        if (arg instanceof BidiJSHandle || arg instanceof BidiElementHandle) {
          if (arg.realm !== this) {
            if (!(arg.realm instanceof BidiFrameRealm) || !(this instanceof BidiFrameRealm)) {
              throw new Error("Trying to evaluate JSHandle from different global types. Usually this means you're using a handle from a worker in a page or vice versa.");
            }
            if (arg.realm.environment !== this.environment) {
              throw new Error("Trying to evaluate JSHandle from different frames. Usually this means you're using a handle from a page on a different page.");
            }
          }
          if (arg.disposed) {
            throw new Error("JSHandle is disposed!");
          }
          return arg.remoteValue();
        }
        return BidiSerializer.serialize(arg);
      }
      async destroyHandles(handles) {
        if (this.disposed) {
          return;
        }
        const handleIds = handles.map(({ id }) => {
          return id;
        }).filter((id) => {
          return id !== void 0;
        });
        if (handleIds.length === 0) {
          return;
        }
        await this.realm.disown(handleIds).catch((error) => {
          debugError(error);
        });
      }
      async adoptHandle(handle) {
        return await this.evaluateHandle((node) => {
          return node;
        }, handle);
      }
      async transferHandle(handle) {
        if (handle.realm === this) {
          return handle;
        }
        const transferredHandle = this.adoptHandle(handle);
        await handle.dispose();
        return await transferredHandle;
      }
    };
    BidiFrameRealm = class extends BidiRealm {
      static from(realm, frame) {
        const frameRealm = new BidiFrameRealm(realm, frame);
        frameRealm.#initialize();
        return frameRealm;
      }
      #frame;
      constructor(realm, frame) {
        super(realm, frame.timeoutSettings);
        this.#frame = frame;
      }
      #initialize() {
        super.initialize();
        this.realm.on("updated", () => {
          this.environment.clearDocumentHandle();
          this.#bindingsInstalled = false;
        });
      }
      #bindingsInstalled = false;
      get puppeteerUtil() {
        let promise = Promise.resolve();
        if (!this.#bindingsInstalled) {
          promise = Promise.all([
            ExposableFunction.from(this.environment, "__ariaQuerySelector", ARIAQueryHandler.queryOne, !!this.sandbox),
            ExposableFunction.from(this.environment, "__ariaQuerySelectorAll", async (element, selector) => {
              const results = ARIAQueryHandler.queryAll(element, selector);
              return await element.realm.evaluateHandle((...elements) => {
                return elements;
              }, ...await AsyncIterableUtil.collect(results));
            }, !!this.sandbox)
          ]);
          this.#bindingsInstalled = true;
        }
        return promise.then(() => {
          return super.puppeteerUtil;
        });
      }
      get sandbox() {
        return this.realm.sandbox;
      }
      get environment() {
        return this.#frame;
      }
      async adoptBackendNode(backendNodeId) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const { object } = await this.#frame.client.send("DOM.resolveNode", {
            backendNodeId,
            executionContextId: await this.realm.resolveExecutionContextId()
          });
          const handle = __addDisposableResource16(env_1, BidiElementHandle.from({
            handle: object.objectId,
            type: "node"
          }, this), false);
          return await handle.evaluateHandle((element) => {
            return element;
          });
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources16(env_1);
        }
      }
    };
    BidiWorkerRealm = class extends BidiRealm {
      static from(realm, worker) {
        const workerRealm = new BidiWorkerRealm(realm, worker);
        workerRealm.initialize();
        return workerRealm;
      }
      #worker;
      constructor(realm, frame) {
        super(realm, frame.timeoutSettings);
        this.#worker = frame;
      }
      get environment() {
        return this.#worker;
      }
      async adoptBackendNode() {
        throw new Error("Cannot adopt DOM nodes into a worker.");
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js
var BidiWebWorker;
var init_WebWorker2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js"() {
    init_WebWorker();
    init_Errors();
    init_Realm3();
    BidiWebWorker = class extends WebWorker {
      static from(frame, realm) {
        const worker = new BidiWebWorker(frame, realm);
        return worker;
      }
      #frame;
      #realm;
      constructor(frame, realm) {
        super(realm.origin);
        this.#frame = frame;
        this.#realm = BidiWorkerRealm.from(realm, this);
      }
      get frame() {
        return this.#frame;
      }
      mainRealm() {
        return this.#realm;
      }
      get client() {
        throw new UnsupportedOperation();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js
function convertConsoleMessageLevel2(method) {
  switch (method) {
    case "group":
      return "startGroup";
    case "groupCollapsed":
      return "startGroupCollapsed";
    case "groupEnd":
      return "endGroup";
    default:
      return method;
  }
}
function isConsoleLogEntry(event) {
  return event.type === "console";
}
function isJavaScriptLogEntry(event) {
  return event.type === "javascript";
}
function getStackTraceLocations(stackTrace) {
  const stackTraceLocations = [];
  if (stackTrace) {
    for (const callFrame of stackTrace.callFrames) {
      stackTraceLocations.push({
        url: callFrame.url,
        lineNumber: callFrame.lineNumber,
        columnNumber: callFrame.columnNumber
      });
    }
  }
  return stackTraceLocations;
}
var __runInitializers16, __esDecorate16, __setFunctionName3, BidiFrame;
var init_Frame2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js"() {
    init_rxjs();
    init_Frame();
    init_Accessibility();
    init_ConsoleMessage();
    init_Errors();
    init_util();
    init_ErrorLike();
    init_CDPSession2();
    init_Deserializer();
    init_Dialog2();
    init_ExposedFunction();
    init_HTTPRequest2();
    init_JSHandle2();
    init_Realm3();
    init_util2();
    init_WebWorker2();
    __runInitializers16 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate16 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __setFunctionName3 = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    BidiFrame = (() => {
      var _a3;
      let _classSuper = Frame;
      let _instanceExtraInitializers = [];
      let _goto_decorators;
      let _setContent_decorators;
      let _waitForNavigation_decorators;
      let _private_waitForLoad$_decorators;
      let _private_waitForLoad$_descriptor;
      let _private_waitForNetworkIdle$_decorators;
      let _private_waitForNetworkIdle$_descriptor;
      let _setFiles_decorators;
      let _locateNodes_decorators;
      return class BidiFrame2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _goto_decorators = [throwIfDetached];
          _setContent_decorators = [throwIfDetached];
          _waitForNavigation_decorators = [throwIfDetached];
          _private_waitForLoad$_decorators = [throwIfDetached];
          _private_waitForNetworkIdle$_decorators = [throwIfDetached];
          _setFiles_decorators = [throwIfDetached];
          _locateNodes_decorators = [throwIfDetached];
          __esDecorate16(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate16(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate16(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate16(this, _private_waitForLoad$_descriptor = { value: __setFunctionName3(function(options = {}) {
            let { waitUntil = "load" } = options;
            const { timeout: ms = this.timeoutSettings.navigationTimeout() } = options;
            if (!Array.isArray(waitUntil)) {
              waitUntil = [waitUntil];
            }
            const events = /* @__PURE__ */ new Set();
            for (const lifecycleEvent of waitUntil) {
              switch (lifecycleEvent) {
                case "load": {
                  events.add("load");
                  break;
                }
                case "domcontentloaded": {
                  events.add("DOMContentLoaded");
                  break;
                }
              }
            }
            if (events.size === 0) {
              return of(void 0);
            }
            return combineLatest([...events].map((event) => {
              return fromEmitterEvent(this.browsingContext, event);
            })).pipe(map(() => {
            }), first(), raceWith(timeout(ms), this.#detached$().pipe(map(() => {
              throw new Error("Frame detached.");
            }))));
          }, "#waitForLoad$") }, _private_waitForLoad$_decorators, { kind: "method", name: "#waitForLoad$", static: false, private: true, access: { has: (obj) => #waitForLoad$ in obj, get: (obj) => obj.#waitForLoad$ }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate16(this, _private_waitForNetworkIdle$_descriptor = { value: __setFunctionName3(function(options = {}) {
            let { waitUntil = "load" } = options;
            if (!Array.isArray(waitUntil)) {
              waitUntil = [waitUntil];
            }
            let concurrency = Infinity;
            for (const event of waitUntil) {
              switch (event) {
                case "networkidle0": {
                  concurrency = Math.min(0, concurrency);
                  break;
                }
                case "networkidle2": {
                  concurrency = Math.min(2, concurrency);
                  break;
                }
              }
            }
            if (concurrency === Infinity) {
              return of(void 0);
            }
            return this.page().waitForNetworkIdle$({
              idleTime: 500,
              timeout: options.timeout ?? this.timeoutSettings.timeout(),
              concurrency
            });
          }, "#waitForNetworkIdle$") }, _private_waitForNetworkIdle$_decorators, { kind: "method", name: "#waitForNetworkIdle$", static: false, private: true, access: { has: (obj) => #waitForNetworkIdle$ in obj, get: (obj) => obj.#waitForNetworkIdle$ }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate16(this, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: (obj) => "setFiles" in obj, get: (obj) => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate16(this, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: (obj) => "locateNodes" in obj, get: (obj) => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(parent, browsingContext) {
          const frame = new BidiFrame2(parent, browsingContext);
          frame.#initialize();
          return frame;
        }
        #parent = __runInitializers16(this, _instanceExtraInitializers);
        browsingContext;
        #frames = /* @__PURE__ */ new WeakMap();
        realms;
        _id;
        client;
        accessibility;
        constructor(parent, browsingContext) {
          super();
          this.#parent = parent;
          this.browsingContext = browsingContext;
          this._id = browsingContext.id;
          this.client = new BidiCdpSession(this);
          this.realms = {
            default: BidiFrameRealm.from(this.browsingContext.defaultRealm, this),
            internal: BidiFrameRealm.from(this.browsingContext.createWindowRealm(`__puppeteer_internal_${Math.ceil(Math.random() * 1e4)}`), this)
          };
          this.accessibility = new Accessibility(this.realms.default, this._id);
        }
        #initialize() {
          for (const browsingContext of this.browsingContext.children) {
            this.#createFrameTarget(browsingContext);
          }
          this.browsingContext.on("browsingcontext", ({ browsingContext }) => {
            this.#createFrameTarget(browsingContext);
          });
          this.browsingContext.on("closed", () => {
            for (const session of BidiCdpSession.sessions.values()) {
              if (session.frame === this) {
                session.onClose();
              }
            }
            this.page().trustedEmitter.emit("framedetached", this);
          });
          this.browsingContext.on("request", ({ request }) => {
            const httpRequest = BidiHTTPRequest.from(request, this);
            request.once("success", () => {
              this.page().trustedEmitter.emit("requestfinished", httpRequest);
            });
            request.once("error", () => {
              this.page().trustedEmitter.emit("requestfailed", httpRequest);
            });
            void httpRequest.finalizeInterceptions();
          });
          this.browsingContext.on("navigation", ({ navigation }) => {
            navigation.once("fragment", () => {
              this.page().trustedEmitter.emit("framenavigated", this);
            });
          });
          this.browsingContext.on("load", () => {
            this.page().trustedEmitter.emit("load", void 0);
          });
          this.browsingContext.on("DOMContentLoaded", () => {
            this._hasStartedLoading = true;
            this.page().trustedEmitter.emit("domcontentloaded", void 0);
            this.page().trustedEmitter.emit("framenavigated", this);
          });
          this.browsingContext.on("userprompt", ({ userPrompt }) => {
            this.page().trustedEmitter.emit("dialog", BidiDialog.from(userPrompt));
          });
          this.browsingContext.on("log", ({ entry }) => {
            if (this._id !== entry.source.context) {
              return;
            }
            if (isConsoleLogEntry(entry)) {
              const args = entry.args.map((arg) => {
                return this.mainRealm().createHandle(arg);
              });
              const text = args.reduce((value, arg) => {
                const parsedValue = arg instanceof BidiJSHandle && arg.isPrimitiveValue ? BidiDeserializer.deserialize(arg.remoteValue()) : arg.toString();
                return `${value} ${parsedValue}`;
              }, "").slice(1);
              this.page().trustedEmitter.emit("console", new ConsoleMessage(convertConsoleMessageLevel2(entry.method), text, args, getStackTraceLocations(entry.stackTrace), this));
            } else if (isJavaScriptLogEntry(entry)) {
              const error = new Error(entry.text ?? "");
              const messageHeight = error.message.split("\n").length;
              const messageLines = error.stack.split("\n").splice(0, messageHeight);
              const stackLines = [];
              if (entry.stackTrace) {
                for (const frame of entry.stackTrace.callFrames) {
                  stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
                  if (stackLines.length >= Error.stackTraceLimit) {
                    break;
                  }
                }
              }
              error.stack = [...messageLines, ...stackLines].join("\n");
              this.page().trustedEmitter.emit("pageerror", error);
            } else {
              debugError(`Unhandled LogEntry with type "${entry.type}", text "${entry.text}" and level "${entry.level}"`);
            }
          });
          this.browsingContext.on("worker", ({ realm }) => {
            const worker = BidiWebWorker.from(this, realm);
            realm.on("destroyed", () => {
              this.page().trustedEmitter.emit("workerdestroyed", worker);
            });
            this.page().trustedEmitter.emit("workercreated", worker);
          });
        }
        #createFrameTarget(browsingContext) {
          const frame = BidiFrame2.from(this, browsingContext);
          this.#frames.set(browsingContext, frame);
          this.page().trustedEmitter.emit("frameattached", frame);
          browsingContext.on("closed", () => {
            this.#frames.delete(browsingContext);
          });
          return frame;
        }
        get timeoutSettings() {
          return this.page()._timeoutSettings;
        }
        mainRealm() {
          return this.realms.default;
        }
        isolatedRealm() {
          return this.realms.internal;
        }
        realm(id) {
          for (const realm of Object.values(this.realms)) {
            if (realm.realm.id === id) {
              return realm;
            }
          }
          return;
        }
        page() {
          let parent = this.#parent;
          while (parent instanceof BidiFrame2) {
            parent = parent.#parent;
          }
          return parent;
        }
        url() {
          return this.browsingContext.url;
        }
        parentFrame() {
          if (this.#parent instanceof BidiFrame2) {
            return this.#parent;
          }
          return null;
        }
        childFrames() {
          return [...this.browsingContext.children].map((child) => {
            return this.#frames.get(child);
          });
        }
        #detached$() {
          return defer(() => {
            if (this.detached) {
              return of(this);
            }
            return fromEmitterEvent(
              this.page().trustedEmitter,
              "framedetached"
              /* PageEvent.FrameDetached */
            ).pipe(filter((detachedFrame) => {
              return detachedFrame === this;
            }));
          });
        }
        async goto(url, options = {}) {
          const [response] = await Promise.all([
            this.waitForNavigation(options),
            // Some implementations currently only report errors when the
            // readiness=interactive.
            //
            // Related: https://bugzilla.mozilla.org/show_bug.cgi?id=1846601
            this.browsingContext.navigate(
              url,
              "interactive"
              /* Bidi.BrowsingContext.ReadinessState.Interactive */
            ).catch((error) => {
              if (isErrorLike(error) && error.message.includes("net::ERR_HTTP_RESPONSE_CODE_FAILURE")) {
                return;
              }
              if (error.message.includes("navigation canceled")) {
                return;
              }
              if (error.message.includes("Navigation was aborted by another navigation")) {
                return;
              }
              throw error;
            })
          ]).catch(rewriteNavigationError(url, options.timeout ?? this.timeoutSettings.navigationTimeout()));
          return response;
        }
        async setContent(html, options = {}) {
          await Promise.all([
            this.setFrameContent(html),
            firstValueFrom(combineLatest([
              this.#waitForLoad$(options),
              this.#waitForNetworkIdle$(options)
            ]))
          ]);
        }
        async waitForNavigation(options = {}) {
          const { timeout: ms = this.timeoutSettings.navigationTimeout(), signal } = options;
          const frames = this.childFrames().map((frame) => {
            return frame.#detached$();
          });
          return await firstValueFrom(combineLatest([
            race(fromEmitterEvent(this.browsingContext, "navigation"), fromEmitterEvent(this.browsingContext, "historyUpdated").pipe(map(() => {
              return { navigation: null };
            }))).pipe(first()).pipe(switchMap(({ navigation }) => {
              if (navigation === null) {
                return of(null);
              }
              return this.#waitForLoad$(options).pipe(delayWhen(() => {
                if (frames.length === 0) {
                  return of(void 0);
                }
                return combineLatest(frames);
              }), raceWith(fromEmitterEvent(navigation, "fragment"), fromEmitterEvent(navigation, "failed"), fromEmitterEvent(navigation, "aborted")), switchMap(() => {
                if (navigation.request) {
                  let requestFinished$ = function(request) {
                    if (navigation === null) {
                      return of(null);
                    }
                    if (request.response || request.error) {
                      return of(navigation);
                    }
                    if (request.redirect) {
                      return requestFinished$(request.redirect);
                    }
                    return fromEmitterEvent(request, "success").pipe(raceWith(fromEmitterEvent(request, "error")), raceWith(fromEmitterEvent(request, "redirect"))).pipe(switchMap(() => {
                      return requestFinished$(request);
                    }));
                  };
                  return requestFinished$(navigation.request);
                }
                return of(navigation);
              }));
            })),
            this.#waitForNetworkIdle$(options)
          ]).pipe(map(([navigation]) => {
            if (!navigation) {
              return null;
            }
            const request = navigation.request;
            if (!request) {
              return null;
            }
            const lastRequest = request.lastRedirect ?? request;
            const httpRequest = requests.get(lastRequest);
            return httpRequest.response();
          }), raceWith(timeout(ms), fromAbortSignal(signal), this.#detached$().pipe(map(() => {
            throw new TargetCloseError("Frame detached.");
          })))));
        }
        waitForDevicePrompt() {
          throw new UnsupportedOperation();
        }
        get detached() {
          return this.browsingContext.closed;
        }
        #exposedFunctions = /* @__PURE__ */ new Map();
        async exposeFunction(name, apply) {
          if (this.#exposedFunctions.has(name)) {
            throw new Error(`Failed to add page binding with name ${name}: globalThis['${name}'] already exists!`);
          }
          const exposable = await ExposableFunction.from(this, name, apply);
          this.#exposedFunctions.set(name, exposable);
        }
        async removeExposedFunction(name) {
          const exposedFunction = this.#exposedFunctions.get(name);
          if (!exposedFunction) {
            throw new Error(`Failed to remove page binding with name ${name}: window['${name}'] does not exists!`);
          }
          this.#exposedFunctions.delete(name);
          await exposedFunction[Symbol.asyncDispose]();
        }
        async createCDPSession() {
          if (!this.page().browser().cdpSupported) {
            throw new UnsupportedOperation();
          }
          const cdpConnection = this.page().browser().cdpConnection;
          return await cdpConnection._createSession({ targetId: this._id });
        }
        get #waitForLoad$() {
          return _private_waitForLoad$_descriptor.value;
        }
        get #waitForNetworkIdle$() {
          return _private_waitForNetworkIdle$_descriptor.value;
        }
        async setFiles(element, files) {
          await this.browsingContext.setFiles(
            // SAFETY: ElementHandles are always remote references.
            element.remoteValue(),
            files
          );
        }
        async locateNodes(element, locator) {
          return await this.browsingContext.locateNodes(
            locator,
            // SAFETY: ElementHandles are always remote references.
            [element.remoteValue()]
          );
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js
var SourceActionsType, ActionType, getBidiKeyValue, BidiKeyboard, getBidiButton, BidiMouse, BidiTouchHandle, BidiTouchscreen;
var init_Input2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js"() {
    init_Input();
    init_Errors();
    init_Errors();
    (function(SourceActionsType2) {
      SourceActionsType2["None"] = "none";
      SourceActionsType2["Key"] = "key";
      SourceActionsType2["Pointer"] = "pointer";
      SourceActionsType2["Wheel"] = "wheel";
    })(SourceActionsType || (SourceActionsType = {}));
    (function(ActionType2) {
      ActionType2["Pause"] = "pause";
      ActionType2["KeyDown"] = "keyDown";
      ActionType2["KeyUp"] = "keyUp";
      ActionType2["PointerUp"] = "pointerUp";
      ActionType2["PointerDown"] = "pointerDown";
      ActionType2["PointerMove"] = "pointerMove";
      ActionType2["Scroll"] = "scroll";
    })(ActionType || (ActionType = {}));
    getBidiKeyValue = (key) => {
      switch (key) {
        case "\r":
        case "\n":
          key = "Enter";
          break;
      }
      if ([...key].length === 1) {
        return key;
      }
      switch (key) {
        case "Cancel":
          return "\uE001";
        case "Help":
          return "\uE002";
        case "Backspace":
          return "\uE003";
        case "Tab":
          return "\uE004";
        case "Clear":
          return "\uE005";
        case "Enter":
          return "\uE007";
        case "Shift":
        case "ShiftLeft":
          return "\uE008";
        case "Control":
        case "ControlLeft":
          return "\uE009";
        case "Alt":
        case "AltLeft":
          return "\uE00A";
        case "Pause":
          return "\uE00B";
        case "Escape":
          return "\uE00C";
        case "PageUp":
          return "\uE00E";
        case "PageDown":
          return "\uE00F";
        case "End":
          return "\uE010";
        case "Home":
          return "\uE011";
        case "ArrowLeft":
          return "\uE012";
        case "ArrowUp":
          return "\uE013";
        case "ArrowRight":
          return "\uE014";
        case "ArrowDown":
          return "\uE015";
        case "Insert":
          return "\uE016";
        case "Delete":
          return "\uE017";
        case "NumpadEqual":
          return "\uE019";
        case "Numpad0":
          return "\uE01A";
        case "Numpad1":
          return "\uE01B";
        case "Numpad2":
          return "\uE01C";
        case "Numpad3":
          return "\uE01D";
        case "Numpad4":
          return "\uE01E";
        case "Numpad5":
          return "\uE01F";
        case "Numpad6":
          return "\uE020";
        case "Numpad7":
          return "\uE021";
        case "Numpad8":
          return "\uE022";
        case "Numpad9":
          return "\uE023";
        case "NumpadMultiply":
          return "\uE024";
        case "NumpadAdd":
          return "\uE025";
        case "NumpadSubtract":
          return "\uE027";
        case "NumpadDecimal":
          return "\uE028";
        case "NumpadDivide":
          return "\uE029";
        case "F1":
          return "\uE031";
        case "F2":
          return "\uE032";
        case "F3":
          return "\uE033";
        case "F4":
          return "\uE034";
        case "F5":
          return "\uE035";
        case "F6":
          return "\uE036";
        case "F7":
          return "\uE037";
        case "F8":
          return "\uE038";
        case "F9":
          return "\uE039";
        case "F10":
          return "\uE03A";
        case "F11":
          return "\uE03B";
        case "F12":
          return "\uE03C";
        case "Meta":
        case "MetaLeft":
          return "\uE03D";
        case "ShiftRight":
          return "\uE050";
        case "ControlRight":
          return "\uE051";
        case "AltRight":
          return "\uE052";
        case "MetaRight":
          return "\uE053";
        case "Digit0":
          return "0";
        case "Digit1":
          return "1";
        case "Digit2":
          return "2";
        case "Digit3":
          return "3";
        case "Digit4":
          return "4";
        case "Digit5":
          return "5";
        case "Digit6":
          return "6";
        case "Digit7":
          return "7";
        case "Digit8":
          return "8";
        case "Digit9":
          return "9";
        case "KeyA":
          return "a";
        case "KeyB":
          return "b";
        case "KeyC":
          return "c";
        case "KeyD":
          return "d";
        case "KeyE":
          return "e";
        case "KeyF":
          return "f";
        case "KeyG":
          return "g";
        case "KeyH":
          return "h";
        case "KeyI":
          return "i";
        case "KeyJ":
          return "j";
        case "KeyK":
          return "k";
        case "KeyL":
          return "l";
        case "KeyM":
          return "m";
        case "KeyN":
          return "n";
        case "KeyO":
          return "o";
        case "KeyP":
          return "p";
        case "KeyQ":
          return "q";
        case "KeyR":
          return "r";
        case "KeyS":
          return "s";
        case "KeyT":
          return "t";
        case "KeyU":
          return "u";
        case "KeyV":
          return "v";
        case "KeyW":
          return "w";
        case "KeyX":
          return "x";
        case "KeyY":
          return "y";
        case "KeyZ":
          return "z";
        case "Semicolon":
          return ";";
        case "Equal":
          return "=";
        case "Comma":
          return ",";
        case "Minus":
          return "-";
        case "Period":
          return ".";
        case "Slash":
          return "/";
        case "Backquote":
          return "`";
        case "BracketLeft":
          return "[";
        case "Backslash":
          return "\\";
        case "BracketRight":
          return "]";
        case "Quote":
          return '"';
        default:
          throw new Error(`Unknown key: "${key}"`);
      }
    };
    BidiKeyboard = class extends Keyboard {
      #page;
      constructor(page) {
        super();
        this.#page = page;
      }
      async down(key, _options) {
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Key,
            id: "__puppeteer_keyboard",
            actions: [
              {
                type: ActionType.KeyDown,
                value: getBidiKeyValue(key)
              }
            ]
          }
        ]);
      }
      async up(key) {
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Key,
            id: "__puppeteer_keyboard",
            actions: [
              {
                type: ActionType.KeyUp,
                value: getBidiKeyValue(key)
              }
            ]
          }
        ]);
      }
      async press(key, options = {}) {
        const { delay = 0 } = options;
        const actions = [
          {
            type: ActionType.KeyDown,
            value: getBidiKeyValue(key)
          }
        ];
        if (delay > 0) {
          actions.push({
            type: ActionType.Pause,
            duration: delay
          });
        }
        actions.push({
          type: ActionType.KeyUp,
          value: getBidiKeyValue(key)
        });
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Key,
            id: "__puppeteer_keyboard",
            actions
          }
        ]);
      }
      async type(text, options = {}) {
        const { delay = 0 } = options;
        const values = [...text].map(getBidiKeyValue);
        const actions = [];
        if (delay <= 0) {
          for (const value of values) {
            actions.push({
              type: ActionType.KeyDown,
              value
            }, {
              type: ActionType.KeyUp,
              value
            });
          }
        } else {
          for (const value of values) {
            actions.push({
              type: ActionType.KeyDown,
              value
            }, {
              type: ActionType.Pause,
              duration: delay
            }, {
              type: ActionType.KeyUp,
              value
            });
          }
        }
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Key,
            id: "__puppeteer_keyboard",
            actions
          }
        ]);
      }
      async sendCharacter(char) {
        if ([...char].length > 1) {
          throw new Error("Cannot send more than 1 character.");
        }
        const frame = await this.#page.focusedFrame();
        await frame.isolatedRealm().evaluate(async (char2) => {
          document.execCommand("insertText", false, char2);
        }, char);
      }
    };
    getBidiButton = (button) => {
      switch (button) {
        case MouseButton.Left:
          return 0;
        case MouseButton.Middle:
          return 1;
        case MouseButton.Right:
          return 2;
        case MouseButton.Back:
          return 3;
        case MouseButton.Forward:
          return 4;
      }
    };
    BidiMouse = class extends Mouse {
      #page;
      #lastMovePoint = { x: 0, y: 0 };
      constructor(page) {
        super();
        this.#page = page;
      }
      async reset() {
        this.#lastMovePoint = { x: 0, y: 0 };
        await this.#page.mainFrame().browsingContext.releaseActions();
      }
      async move(x, y, options = {}) {
        const from2 = this.#lastMovePoint;
        const to = {
          x: Math.round(x),
          y: Math.round(y)
        };
        const actions = [];
        const steps = options.steps ?? 0;
        for (let i = 0; i < steps; ++i) {
          actions.push({
            type: ActionType.PointerMove,
            x: from2.x + (to.x - from2.x) * (i / steps),
            y: from2.y + (to.y - from2.y) * (i / steps),
            origin: options.origin
          });
        }
        actions.push({
          type: ActionType.PointerMove,
          ...to,
          origin: options.origin
        });
        this.#lastMovePoint = to;
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Pointer,
            id: "__puppeteer_mouse",
            actions
          }
        ]);
      }
      async down(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Pointer,
            id: "__puppeteer_mouse",
            actions: [
              {
                type: ActionType.PointerDown,
                button: getBidiButton(options.button ?? MouseButton.Left)
              }
            ]
          }
        ]);
      }
      async up(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Pointer,
            id: "__puppeteer_mouse",
            actions: [
              {
                type: ActionType.PointerUp,
                button: getBidiButton(options.button ?? MouseButton.Left)
              }
            ]
          }
        ]);
      }
      async click(x, y, options = {}) {
        const actions = [
          {
            type: ActionType.PointerMove,
            x: Math.round(x),
            y: Math.round(y),
            origin: options.origin
          }
        ];
        const pointerDownAction = {
          type: ActionType.PointerDown,
          button: getBidiButton(options.button ?? MouseButton.Left)
        };
        const pointerUpAction = {
          type: ActionType.PointerUp,
          button: pointerDownAction.button
        };
        for (let i = 1; i < (options.count ?? 1); ++i) {
          actions.push(pointerDownAction, pointerUpAction);
        }
        actions.push(pointerDownAction);
        if (options.delay) {
          actions.push({
            type: ActionType.Pause,
            duration: options.delay
          });
        }
        actions.push(pointerUpAction);
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Pointer,
            id: "__puppeteer_mouse",
            actions
          }
        ]);
      }
      async wheel(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Wheel,
            id: "__puppeteer_wheel",
            actions: [
              {
                type: ActionType.Scroll,
                ...this.#lastMovePoint ?? {
                  x: 0,
                  y: 0
                },
                deltaX: options.deltaX ?? 0,
                deltaY: options.deltaY ?? 0
              }
            ]
          }
        ]);
      }
      drag() {
        throw new UnsupportedOperation();
      }
      dragOver() {
        throw new UnsupportedOperation();
      }
      dragEnter() {
        throw new UnsupportedOperation();
      }
      drop() {
        throw new UnsupportedOperation();
      }
      dragAndDrop() {
        throw new UnsupportedOperation();
      }
    };
    BidiTouchHandle = class {
      #started = false;
      #x;
      #y;
      #bidiId;
      #page;
      #touchScreen;
      #properties;
      constructor(page, touchScreen, id, x, y, properties) {
        this.#page = page;
        this.#touchScreen = touchScreen;
        this.#x = Math.round(x);
        this.#y = Math.round(y);
        this.#properties = properties;
        this.#bidiId = `${"__puppeteer_finger"}_${id}`;
      }
      async start(options = {}) {
        if (this.#started) {
          throw new TouchError("Touch has already started");
        }
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Pointer,
            id: this.#bidiId,
            parameters: {
              pointerType: "touch"
            },
            actions: [
              {
                type: ActionType.PointerMove,
                x: this.#x,
                y: this.#y,
                origin: options.origin
              },
              {
                ...this.#properties,
                type: ActionType.PointerDown,
                button: 0
              }
            ]
          }
        ]);
        this.#started = true;
      }
      move(x, y) {
        const newX = Math.round(x);
        const newY = Math.round(y);
        return this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Pointer,
            id: this.#bidiId,
            parameters: {
              pointerType: "touch"
            },
            actions: [
              {
                ...this.#properties,
                type: ActionType.PointerMove,
                x: newX,
                y: newY
              }
            ]
          }
        ]);
      }
      async end() {
        await this.#page.mainFrame().browsingContext.performActions([
          {
            type: SourceActionsType.Pointer,
            id: this.#bidiId,
            parameters: {
              pointerType: "touch"
            },
            actions: [
              {
                type: ActionType.PointerUp,
                button: 0
              }
            ]
          }
        ]);
        this.#touchScreen.removeHandle(this);
      }
    };
    BidiTouchscreen = class extends Touchscreen {
      #page;
      constructor(page) {
        super();
        this.#page = page;
      }
      async touchStart(x, y, options = {}) {
        const id = this.idGenerator();
        const properties = {
          width: 0.5 * 2,
          // 2 times default touch radius.
          height: 0.5 * 2,
          // 2 times default touch radius.
          pressure: 0.5,
          altitudeAngle: Math.PI / 2
        };
        const touch = new BidiTouchHandle(this.#page, this, id, x, y, properties);
        await touch.start(options);
        this.touches.push(touch);
        return touch;
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js
function evaluationExpression(fun, ...args) {
  return `() => {${evaluationString(fun, ...args)}}`;
}
function testUrlMatchCookieHostname(cookie, normalizedUrl) {
  const cookieDomain = cookie.domain.toLowerCase();
  const urlHostname = normalizedUrl.hostname.toLowerCase();
  if (cookieDomain === urlHostname) {
    return true;
  }
  return cookieDomain.startsWith(".") && urlHostname.endsWith(cookieDomain);
}
function testUrlMatchCookiePath(cookie, normalizedUrl) {
  const uriPath = normalizedUrl.pathname;
  const cookiePath = cookie.path;
  if (uriPath === cookiePath) {
    return true;
  }
  if (uriPath.startsWith(cookiePath)) {
    if (cookiePath.endsWith("/")) {
      return true;
    }
    if (uriPath[cookiePath.length] === "/") {
      return true;
    }
  }
  return false;
}
function testUrlMatchCookie(cookie, url) {
  const normalizedUrl = new URL(url);
  assert(cookie !== void 0);
  if (!testUrlMatchCookieHostname(cookie, normalizedUrl)) {
    return false;
  }
  return testUrlMatchCookiePath(cookie, normalizedUrl);
}
function bidiToPuppeteerCookie(bidiCookie, returnCompositePartitionKey = false) {
  const partitionKey = bidiCookie[CDP_SPECIFIC_PREFIX + "partitionKey"];
  function getParitionKey() {
    if (typeof partitionKey === "string") {
      return { partitionKey };
    }
    if (typeof partitionKey === "object" && partitionKey !== null) {
      if (returnCompositePartitionKey) {
        return {
          partitionKey: {
            sourceOrigin: partitionKey.topLevelSite,
            hasCrossSiteAncestor: partitionKey.hasCrossSiteAncestor ?? false
          }
        };
      }
      return {
        // TODO: a breaking change in Puppeteer is required to change
        // partitionKey type and report the composite partition key.
        partitionKey: partitionKey.topLevelSite
      };
    }
    return {};
  }
  return {
    name: bidiCookie.name,
    // Presents binary value as base64 string.
    value: bidiCookie.value.value,
    domain: bidiCookie.domain,
    path: bidiCookie.path,
    size: bidiCookie.size,
    httpOnly: bidiCookie.httpOnly,
    secure: bidiCookie.secure,
    sameSite: convertCookiesSameSiteBiDiToCdp(bidiCookie.sameSite),
    expires: bidiCookie.expiry ?? -1,
    session: bidiCookie.expiry === void 0 || bidiCookie.expiry <= 0,
    // Extending with CDP-specific properties with `goog:` prefix.
    ...cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, "sameParty", "sourceScheme", "partitionKeyOpaque", "priority"),
    ...getParitionKey()
  };
}
function cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, ...propertyNames) {
  const result = {};
  for (const property of propertyNames) {
    if (bidiCookie[CDP_SPECIFIC_PREFIX + property] !== void 0) {
      result[property] = bidiCookie[CDP_SPECIFIC_PREFIX + property];
    }
  }
  return result;
}
function cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookieParam, ...propertyNames) {
  const result = {};
  for (const property of propertyNames) {
    if (cookieParam[property] !== void 0) {
      result[CDP_SPECIFIC_PREFIX + property] = cookieParam[property];
    }
  }
  return result;
}
function convertCookiesSameSiteBiDiToCdp(sameSite) {
  return sameSite === "strict" ? "Strict" : sameSite === "lax" ? "Lax" : "None";
}
function convertCookiesSameSiteCdpToBiDi(sameSite) {
  return sameSite === "Strict" ? "strict" : sameSite === "Lax" ? "lax" : "none";
}
function convertCookiesExpiryCdpToBiDi(expiry) {
  return [void 0, -1].includes(expiry) ? void 0 : expiry;
}
function convertCookiesPartitionKeyFromPuppeteerToBiDi(partitionKey) {
  if (partitionKey === void 0 || typeof partitionKey === "string") {
    return partitionKey;
  }
  if (partitionKey.hasCrossSiteAncestor) {
    throw new UnsupportedOperation("WebDriver BiDi does not support `hasCrossSiteAncestor` yet.");
  }
  return partitionKey.sourceOrigin;
}
var __esDecorate17, __runInitializers17, __addDisposableResource17, __disposeResources17, BidiPage, CDP_SPECIFIC_PREFIX;
var init_Page2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js"() {
    init_rxjs();
    init_Page();
    init_Coverage();
    init_EmulationManager();
    init_Tracing();
    init_Errors();
    init_EventEmitter();
    init_util();
    init_assert();
    init_decorators();
    init_encoding();
    init_ErrorLike();
    init_Frame2();
    init_Input2();
    init_util2();
    __esDecorate17 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers17 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __addDisposableResource17 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources17 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    BidiPage = (() => {
      let _classSuper = Page;
      let _trustedEmitter_decorators;
      let _trustedEmitter_initializers = [];
      let _trustedEmitter_extraInitializers = [];
      return class BidiPage2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _trustedEmitter_decorators = [bubble()];
          __esDecorate17(this, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: (obj) => "trustedEmitter" in obj, get: (obj) => obj.trustedEmitter, set: (obj, value) => {
            obj.trustedEmitter = value;
          } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browserContext, browsingContext) {
          const page = new BidiPage2(browserContext, browsingContext);
          page.#initialize();
          return page;
        }
        #trustedEmitter_accessor_storage = __runInitializers17(this, _trustedEmitter_initializers, new EventEmitter());
        get trustedEmitter() {
          return this.#trustedEmitter_accessor_storage;
        }
        set trustedEmitter(value) {
          this.#trustedEmitter_accessor_storage = value;
        }
        #browserContext = __runInitializers17(this, _trustedEmitter_extraInitializers);
        #frame;
        #viewport = null;
        #workers = /* @__PURE__ */ new Set();
        keyboard;
        mouse;
        touchscreen;
        tracing;
        coverage;
        #cdpEmulationManager;
        #emulatedNetworkConditions;
        _client() {
          return this.#frame.client;
        }
        constructor(browserContext, browsingContext) {
          super();
          this.#browserContext = browserContext;
          this.#frame = BidiFrame.from(this, browsingContext);
          this.#cdpEmulationManager = new EmulationManager(this.#frame.client);
          this.tracing = new Tracing(this.#frame.client);
          this.coverage = new Coverage(this.#frame.client);
          this.keyboard = new BidiKeyboard(this);
          this.mouse = new BidiMouse(this);
          this.touchscreen = new BidiTouchscreen(this);
        }
        #initialize() {
          this.#frame.browsingContext.on("closed", () => {
            this.trustedEmitter.emit("close", void 0);
            this.trustedEmitter.removeAllListeners();
          });
          this.trustedEmitter.on("workercreated", (worker) => {
            this.#workers.add(worker);
          });
          this.trustedEmitter.on("workerdestroyed", (worker) => {
            this.#workers.delete(worker);
          });
        }
        /**
         * @internal
         */
        _userAgentHeaders = {};
        #userAgentInterception;
        #userAgentPreloadScript;
        async setUserAgent(userAgent, userAgentMetadata) {
          if (!this.#browserContext.browser().cdpSupported && userAgentMetadata) {
            throw new UnsupportedOperation("Current Browser does not support `userAgentMetadata`");
          } else if (this.#browserContext.browser().cdpSupported && userAgentMetadata) {
            return await this._client().send("Network.setUserAgentOverride", {
              userAgent,
              userAgentMetadata
            });
          }
          const enable = userAgent !== "";
          userAgent = userAgent ?? await this.#browserContext.browser().userAgent();
          this._userAgentHeaders = enable ? {
            "User-Agent": userAgent
          } : {};
          this.#userAgentInterception = await this.#toggleInterception([
            "beforeRequestSent"
            /* Bidi.Network.InterceptPhase.BeforeRequestSent */
          ], this.#userAgentInterception, enable);
          const changeUserAgent = (userAgent2) => {
            Object.defineProperty(navigator, "userAgent", {
              value: userAgent2,
              configurable: true
            });
          };
          const frames = [this.#frame];
          for (const frame of frames) {
            frames.push(...frame.childFrames());
          }
          if (this.#userAgentPreloadScript) {
            await this.removeScriptToEvaluateOnNewDocument(this.#userAgentPreloadScript);
          }
          const [evaluateToken] = await Promise.all([
            enable ? this.evaluateOnNewDocument(changeUserAgent, userAgent) : void 0,
            // When we disable the UserAgent we want to
            // evaluate the original value in all Browsing Contexts
            ...frames.map((frame) => {
              return frame.evaluate(changeUserAgent, userAgent);
            })
          ]);
          this.#userAgentPreloadScript = evaluateToken?.identifier;
        }
        async setBypassCSP(enabled) {
          await this._client().send("Page.setBypassCSP", { enabled });
        }
        async queryObjects(prototypeHandle) {
          assert(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
          assert(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
          const response = await this.#frame.client.send("Runtime.queryObjects", {
            prototypeObjectId: prototypeHandle.id
          });
          return this.#frame.mainRealm().createHandle({
            type: "array",
            handle: response.objects.objectId
          });
        }
        browser() {
          return this.browserContext().browser();
        }
        browserContext() {
          return this.#browserContext;
        }
        mainFrame() {
          return this.#frame;
        }
        async focusedFrame() {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource17(env_1, await this.mainFrame().isolatedRealm().evaluateHandle(() => {
              let win = window;
              while (win.document.activeElement instanceof win.HTMLIFrameElement || win.document.activeElement instanceof win.HTMLFrameElement) {
                if (win.document.activeElement.contentWindow === null) {
                  break;
                }
                win = win.document.activeElement.contentWindow;
              }
              return win;
            }), false);
            const value = handle.remoteValue();
            assert(value.type === "window");
            const frame = this.frames().find((frame2) => {
              return frame2._id === value.value.context;
            });
            assert(frame);
            return frame;
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources17(env_1);
          }
        }
        frames() {
          const frames = [this.#frame];
          for (const frame of frames) {
            frames.push(...frame.childFrames());
          }
          return frames;
        }
        isClosed() {
          return this.#frame.detached;
        }
        async close(options) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const _guard = __addDisposableResource17(env_2, await this.#browserContext.waitForScreenshotOperations(), false);
            try {
              await this.#frame.browsingContext.close(options?.runBeforeUnload);
            } catch {
              return;
            }
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            __disposeResources17(env_2);
          }
        }
        async reload(options = {}) {
          const [response] = await Promise.all([
            this.#frame.waitForNavigation(options),
            this.#frame.browsingContext.reload()
          ]).catch(rewriteNavigationError(this.url(), options.timeout ?? this._timeoutSettings.navigationTimeout()));
          return response;
        }
        setDefaultNavigationTimeout(timeout2) {
          this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
        }
        setDefaultTimeout(timeout2) {
          this._timeoutSettings.setDefaultTimeout(timeout2);
        }
        getDefaultTimeout() {
          return this._timeoutSettings.timeout();
        }
        getDefaultNavigationTimeout() {
          return this._timeoutSettings.navigationTimeout();
        }
        isJavaScriptEnabled() {
          return this.#cdpEmulationManager.javascriptEnabled;
        }
        async setGeolocation(options) {
          return await this.#cdpEmulationManager.setGeolocation(options);
        }
        async setJavaScriptEnabled(enabled) {
          return await this.#cdpEmulationManager.setJavaScriptEnabled(enabled);
        }
        async emulateMediaType(type) {
          return await this.#cdpEmulationManager.emulateMediaType(type);
        }
        async emulateCPUThrottling(factor) {
          return await this.#cdpEmulationManager.emulateCPUThrottling(factor);
        }
        async emulateMediaFeatures(features) {
          return await this.#cdpEmulationManager.emulateMediaFeatures(features);
        }
        async emulateTimezone(timezoneId) {
          return await this.#cdpEmulationManager.emulateTimezone(timezoneId);
        }
        async emulateIdleState(overrides) {
          return await this.#cdpEmulationManager.emulateIdleState(overrides);
        }
        async emulateVisionDeficiency(type) {
          return await this.#cdpEmulationManager.emulateVisionDeficiency(type);
        }
        async setViewport(viewport) {
          if (!this.browser().cdpSupported) {
            await this.#frame.browsingContext.setViewport({
              viewport: viewport?.width && viewport?.height ? {
                width: viewport.width,
                height: viewport.height
              } : null,
              devicePixelRatio: viewport?.deviceScaleFactor ? viewport.deviceScaleFactor : null
            });
            this.#viewport = viewport;
            return;
          }
          const needsReload = await this.#cdpEmulationManager.emulateViewport(viewport);
          this.#viewport = viewport;
          if (needsReload) {
            await this.reload();
          }
        }
        viewport() {
          return this.#viewport;
        }
        async pdf(options = {}) {
          const { timeout: ms = this._timeoutSettings.timeout(), path = void 0 } = options;
          const { printBackground: background, margin, landscape, width, height, pageRanges: ranges, scale, preferCSSPageSize } = parsePDFOptions(options, "cm");
          const pageRanges = ranges ? ranges.split(", ") : [];
          await firstValueFrom(from(this.mainFrame().isolatedRealm().evaluate(() => {
            return document.fonts.ready;
          })).pipe(raceWith(timeout(ms))));
          const data = await firstValueFrom(from(this.#frame.browsingContext.print({
            background,
            margin,
            orientation: landscape ? "landscape" : "portrait",
            page: {
              width,
              height
            },
            pageRanges,
            scale,
            shrinkToFit: !preferCSSPageSize
          })).pipe(raceWith(timeout(ms))));
          const typedArray = stringToTypedArray(data, true);
          await this._maybeWriteTypedArrayToFile(path, typedArray);
          return typedArray;
        }
        async createPDFStream(options) {
          const typedArray = await this.pdf(options);
          return new ReadableStream({
            start(controller) {
              controller.enqueue(typedArray);
              controller.close();
            }
          });
        }
        async _screenshot(options) {
          const { clip, type, captureBeyondViewport, quality } = options;
          if (options.omitBackground !== void 0 && options.omitBackground) {
            throw new UnsupportedOperation(`BiDi does not support 'omitBackground'.`);
          }
          if (options.optimizeForSpeed !== void 0 && options.optimizeForSpeed) {
            throw new UnsupportedOperation(`BiDi does not support 'optimizeForSpeed'.`);
          }
          if (options.fromSurface !== void 0 && !options.fromSurface) {
            throw new UnsupportedOperation(`BiDi does not support 'fromSurface'.`);
          }
          if (clip !== void 0 && clip.scale !== void 0 && clip.scale !== 1) {
            throw new UnsupportedOperation(`BiDi does not support 'scale' in 'clip'.`);
          }
          let box;
          if (clip) {
            if (captureBeyondViewport) {
              box = clip;
            } else {
              const [pageLeft, pageTop] = await this.evaluate(() => {
                if (!window.visualViewport) {
                  throw new Error("window.visualViewport is not supported.");
                }
                return [
                  window.visualViewport.pageLeft,
                  window.visualViewport.pageTop
                ];
              });
              box = {
                ...clip,
                x: clip.x - pageLeft,
                y: clip.y - pageTop
              };
            }
          }
          const data = await this.#frame.browsingContext.captureScreenshot({
            origin: captureBeyondViewport ? "document" : "viewport",
            format: {
              type: `image/${type}`,
              ...quality !== void 0 ? { quality: quality / 100 } : {}
            },
            ...box ? { clip: { type: "box", ...box } } : {}
          });
          return data;
        }
        async createCDPSession() {
          return await this.#frame.createCDPSession();
        }
        async bringToFront() {
          await this.#frame.browsingContext.activate();
        }
        async evaluateOnNewDocument(pageFunction, ...args) {
          const expression = evaluationExpression(pageFunction, ...args);
          const script = await this.#frame.browsingContext.addPreloadScript(expression);
          return { identifier: script };
        }
        async removeScriptToEvaluateOnNewDocument(id) {
          await this.#frame.browsingContext.removePreloadScript(id);
        }
        async exposeFunction(name, pptrFunction) {
          return await this.mainFrame().exposeFunction(name, "default" in pptrFunction ? pptrFunction.default : pptrFunction);
        }
        isDragInterceptionEnabled() {
          return false;
        }
        async setCacheEnabled(enabled) {
          if (!this.#browserContext.browser().cdpSupported) {
            await this.#frame.browsingContext.setCacheBehavior(enabled ? "default" : "bypass");
            return;
          }
          await this._client().send("Network.setCacheDisabled", {
            cacheDisabled: !enabled
          });
        }
        async cookies(...urls) {
          const normalizedUrls = (urls.length ? urls : [this.url()]).map((url) => {
            return new URL(url);
          });
          const cookies = await this.#frame.browsingContext.getCookies();
          return cookies.map((cookie) => {
            return bidiToPuppeteerCookie(cookie);
          }).filter((cookie) => {
            return normalizedUrls.some((url) => {
              return testUrlMatchCookie(cookie, url);
            });
          });
        }
        isServiceWorkerBypassed() {
          throw new UnsupportedOperation();
        }
        target() {
          throw new UnsupportedOperation();
        }
        waitForFileChooser() {
          throw new UnsupportedOperation();
        }
        workers() {
          return [...this.#workers];
        }
        #userInterception;
        async setRequestInterception(enable) {
          this.#userInterception = await this.#toggleInterception([
            "beforeRequestSent"
            /* Bidi.Network.InterceptPhase.BeforeRequestSent */
          ], this.#userInterception, enable);
        }
        /**
         * @internal
         */
        _extraHTTPHeaders = {};
        #extraHeadersInterception;
        async setExtraHTTPHeaders(headers) {
          const extraHTTPHeaders = {};
          for (const [key, value] of Object.entries(headers)) {
            assert(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
            extraHTTPHeaders[key.toLowerCase()] = value;
          }
          this._extraHTTPHeaders = extraHTTPHeaders;
          this.#extraHeadersInterception = await this.#toggleInterception([
            "beforeRequestSent"
            /* Bidi.Network.InterceptPhase.BeforeRequestSent */
          ], this.#extraHeadersInterception, Boolean(Object.keys(this._extraHTTPHeaders).length));
        }
        /**
         * @internal
         */
        _credentials = null;
        #authInterception;
        async authenticate(credentials) {
          this.#authInterception = await this.#toggleInterception([
            "authRequired"
            /* Bidi.Network.InterceptPhase.AuthRequired */
          ], this.#authInterception, Boolean(credentials));
          this._credentials = credentials;
        }
        async #toggleInterception(phases, interception, expected) {
          if (expected && !interception) {
            return await this.#frame.browsingContext.addIntercept({
              phases
            });
          } else if (!expected && interception) {
            await this.#frame.browsingContext.userContext.browser.removeIntercept(interception);
            return;
          }
          return interception;
        }
        setDragInterception() {
          throw new UnsupportedOperation();
        }
        setBypassServiceWorker() {
          throw new UnsupportedOperation();
        }
        async setOfflineMode(enabled) {
          if (!this.#browserContext.browser().cdpSupported) {
            throw new UnsupportedOperation();
          }
          if (!this.#emulatedNetworkConditions) {
            this.#emulatedNetworkConditions = {
              offline: false,
              upload: -1,
              download: -1,
              latency: 0
            };
          }
          this.#emulatedNetworkConditions.offline = enabled;
          return await this.#applyNetworkConditions();
        }
        async emulateNetworkConditions(networkConditions) {
          if (!this.#browserContext.browser().cdpSupported) {
            throw new UnsupportedOperation();
          }
          if (!this.#emulatedNetworkConditions) {
            this.#emulatedNetworkConditions = {
              offline: false,
              upload: -1,
              download: -1,
              latency: 0
            };
          }
          this.#emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;
          this.#emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;
          this.#emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;
          return await this.#applyNetworkConditions();
        }
        async #applyNetworkConditions() {
          if (!this.#emulatedNetworkConditions) {
            return;
          }
          await this._client().send("Network.emulateNetworkConditions", {
            offline: this.#emulatedNetworkConditions.offline,
            latency: this.#emulatedNetworkConditions.latency,
            uploadThroughput: this.#emulatedNetworkConditions.upload,
            downloadThroughput: this.#emulatedNetworkConditions.download
          });
        }
        async setCookie(...cookies) {
          const pageURL = this.url();
          const pageUrlStartsWithHTTP = pageURL.startsWith("http");
          for (const cookie of cookies) {
            let cookieUrl = cookie.url || "";
            if (!cookieUrl && pageUrlStartsWithHTTP) {
              cookieUrl = pageURL;
            }
            assert(cookieUrl !== "about:blank", `Blank page can not have cookie "${cookie.name}"`);
            assert(!String.prototype.startsWith.call(cookieUrl || "", "data:"), `Data URL page can not have cookie "${cookie.name}"`);
            assert(cookie.partitionKey === void 0 || typeof cookie.partitionKey === "string", "BiDi only allows domain partition keys");
            const normalizedUrl = URL.canParse(cookieUrl) ? new URL(cookieUrl) : void 0;
            const domain = cookie.domain ?? normalizedUrl?.hostname;
            assert(domain !== void 0, `At least one of the url and domain needs to be specified`);
            const bidiCookie = {
              domain,
              name: cookie.name,
              value: {
                type: "string",
                value: cookie.value
              },
              ...cookie.path !== void 0 ? { path: cookie.path } : {},
              ...cookie.httpOnly !== void 0 ? { httpOnly: cookie.httpOnly } : {},
              ...cookie.secure !== void 0 ? { secure: cookie.secure } : {},
              ...cookie.sameSite !== void 0 ? { sameSite: convertCookiesSameSiteCdpToBiDi(cookie.sameSite) } : {},
              ...{ expiry: convertCookiesExpiryCdpToBiDi(cookie.expires) },
              // Chrome-specific properties.
              ...cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookie, "sameParty", "sourceScheme", "priority", "url")
            };
            if (cookie.partitionKey !== void 0) {
              await this.browserContext().userContext.setCookie(bidiCookie, cookie.partitionKey);
            } else {
              await this.#frame.browsingContext.setCookie(bidiCookie);
            }
          }
        }
        async deleteCookie(...cookies) {
          await Promise.all(cookies.map(async (deleteCookieRequest) => {
            const cookieUrl = deleteCookieRequest.url ?? this.url();
            const normalizedUrl = URL.canParse(cookieUrl) ? new URL(cookieUrl) : void 0;
            const domain = deleteCookieRequest.domain ?? normalizedUrl?.hostname;
            assert(domain !== void 0, `At least one of the url and domain needs to be specified`);
            const filter2 = {
              domain,
              name: deleteCookieRequest.name,
              ...deleteCookieRequest.path !== void 0 ? { path: deleteCookieRequest.path } : {}
            };
            await this.#frame.browsingContext.deleteCookie(filter2);
          }));
        }
        async removeExposedFunction(name) {
          await this.#frame.removeExposedFunction(name);
        }
        metrics() {
          throw new UnsupportedOperation();
        }
        async goBack(options = {}) {
          return await this.#go(-1, options);
        }
        async goForward(options = {}) {
          return await this.#go(1, options);
        }
        async #go(delta, options) {
          const controller = new AbortController();
          try {
            const [response] = await Promise.all([
              this.waitForNavigation({
                ...options,
                signal: controller.signal
              }),
              this.#frame.browsingContext.traverseHistory(delta)
            ]);
            return response;
          } catch (error) {
            controller.abort();
            if (isErrorLike(error)) {
              if (error.message.includes("no such history entry")) {
                return null;
              }
            }
            throw error;
          }
        }
        waitForDevicePrompt() {
          throw new UnsupportedOperation();
        }
      };
    })();
    CDP_SPECIFIC_PREFIX = "goog:";
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js
var BidiBrowserTarget, BidiPageTarget, BidiFrameTarget, BidiWorkerTarget;
var init_Target2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js"() {
    init_Target();
    init_Errors();
    init_Page2();
    BidiBrowserTarget = class extends Target {
      #browser;
      constructor(browser) {
        super();
        this.#browser = browser;
      }
      asPage() {
        throw new UnsupportedOperation();
      }
      url() {
        return "";
      }
      createCDPSession() {
        throw new UnsupportedOperation();
      }
      type() {
        return TargetType.BROWSER;
      }
      browser() {
        return this.#browser;
      }
      browserContext() {
        return this.#browser.defaultBrowserContext();
      }
      opener() {
        throw new UnsupportedOperation();
      }
    };
    BidiPageTarget = class extends Target {
      #page;
      constructor(page) {
        super();
        this.#page = page;
      }
      async page() {
        return this.#page;
      }
      async asPage() {
        return BidiPage.from(this.browserContext(), this.#page.mainFrame().browsingContext);
      }
      url() {
        return this.#page.url();
      }
      createCDPSession() {
        return this.#page.createCDPSession();
      }
      type() {
        return TargetType.PAGE;
      }
      browser() {
        return this.browserContext().browser();
      }
      browserContext() {
        return this.#page.browserContext();
      }
      opener() {
        throw new UnsupportedOperation();
      }
    };
    BidiFrameTarget = class extends Target {
      #frame;
      #page;
      constructor(frame) {
        super();
        this.#frame = frame;
      }
      async page() {
        if (this.#page === void 0) {
          this.#page = BidiPage.from(this.browserContext(), this.#frame.browsingContext);
        }
        return this.#page;
      }
      async asPage() {
        return BidiPage.from(this.browserContext(), this.#frame.browsingContext);
      }
      url() {
        return this.#frame.url();
      }
      createCDPSession() {
        return this.#frame.createCDPSession();
      }
      type() {
        return TargetType.PAGE;
      }
      browser() {
        return this.browserContext().browser();
      }
      browserContext() {
        return this.#frame.page().browserContext();
      }
      opener() {
        throw new UnsupportedOperation();
      }
    };
    BidiWorkerTarget = class extends Target {
      #worker;
      constructor(worker) {
        super();
        this.#worker = worker;
      }
      async page() {
        throw new UnsupportedOperation();
      }
      async asPage() {
        throw new UnsupportedOperation();
      }
      url() {
        return this.#worker.url();
      }
      createCDPSession() {
        throw new UnsupportedOperation();
      }
      type() {
        return TargetType.OTHER;
      }
      browser() {
        return this.browserContext().browser();
      }
      browserContext() {
        return this.#worker.frame.page().browserContext();
      }
      opener() {
        throw new UnsupportedOperation();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js
var __esDecorate18, __runInitializers18, __addDisposableResource18, __disposeResources18, BidiBrowserContext;
var init_BrowserContext2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js"() {
    init_Browser();
    init_BrowserContext();
    init_EventEmitter();
    init_util();
    init_assert();
    init_decorators();
    init_UserContext();
    init_Page2();
    init_Target2();
    init_Target2();
    __esDecorate18 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers18 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __addDisposableResource18 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources18 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    BidiBrowserContext = (() => {
      let _classSuper = BrowserContext;
      let _trustedEmitter_decorators;
      let _trustedEmitter_initializers = [];
      let _trustedEmitter_extraInitializers = [];
      return class BidiBrowserContext2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _trustedEmitter_decorators = [bubble()];
          __esDecorate18(this, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: (obj) => "trustedEmitter" in obj, get: (obj) => obj.trustedEmitter, set: (obj, value) => {
            obj.trustedEmitter = value;
          } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browser, userContext, options) {
          const context2 = new BidiBrowserContext2(browser, userContext, options);
          context2.#initialize();
          return context2;
        }
        #trustedEmitter_accessor_storage = __runInitializers18(this, _trustedEmitter_initializers, new EventEmitter());
        get trustedEmitter() {
          return this.#trustedEmitter_accessor_storage;
        }
        set trustedEmitter(value) {
          this.#trustedEmitter_accessor_storage = value;
        }
        #browser = __runInitializers18(this, _trustedEmitter_extraInitializers);
        #defaultViewport;
        // This is public because of cookies.
        userContext;
        #pages = /* @__PURE__ */ new WeakMap();
        #targets = /* @__PURE__ */ new Map();
        #overrides = [];
        constructor(browser, userContext, options) {
          super();
          this.#browser = browser;
          this.userContext = userContext;
          this.#defaultViewport = options.defaultViewport;
        }
        #initialize() {
          for (const browsingContext of this.userContext.browsingContexts) {
            this.#createPage(browsingContext);
          }
          this.userContext.on("browsingcontext", ({ browsingContext }) => {
            const page = this.#createPage(browsingContext);
            if (browsingContext.originalOpener) {
              for (const context2 of this.userContext.browsingContexts) {
                if (context2.id === browsingContext.originalOpener) {
                  this.#pages.get(context2).trustedEmitter.emit("popup", page);
                }
              }
            }
          });
          this.userContext.on("closed", () => {
            this.trustedEmitter.removeAllListeners();
          });
        }
        #createPage(browsingContext) {
          const page = BidiPage.from(this, browsingContext);
          this.#pages.set(browsingContext, page);
          page.trustedEmitter.on("close", () => {
            this.#pages.delete(browsingContext);
          });
          const pageTarget = new BidiPageTarget(page);
          const pageTargets = /* @__PURE__ */ new Map();
          this.#targets.set(page, [pageTarget, pageTargets]);
          page.trustedEmitter.on("frameattached", (frame) => {
            const bidiFrame = frame;
            const target = new BidiFrameTarget(bidiFrame);
            pageTargets.set(bidiFrame, target);
            this.trustedEmitter.emit("targetcreated", target);
          });
          page.trustedEmitter.on("framenavigated", (frame) => {
            const bidiFrame = frame;
            const target = pageTargets.get(bidiFrame);
            if (target === void 0) {
              this.trustedEmitter.emit("targetchanged", pageTarget);
            } else {
              this.trustedEmitter.emit("targetchanged", target);
            }
          });
          page.trustedEmitter.on("framedetached", (frame) => {
            const bidiFrame = frame;
            const target = pageTargets.get(bidiFrame);
            if (target === void 0) {
              return;
            }
            pageTargets.delete(bidiFrame);
            this.trustedEmitter.emit("targetdestroyed", target);
          });
          page.trustedEmitter.on("workercreated", (worker) => {
            const bidiWorker = worker;
            const target = new BidiWorkerTarget(bidiWorker);
            pageTargets.set(bidiWorker, target);
            this.trustedEmitter.emit("targetcreated", target);
          });
          page.trustedEmitter.on("workerdestroyed", (worker) => {
            const bidiWorker = worker;
            const target = pageTargets.get(bidiWorker);
            if (target === void 0) {
              return;
            }
            pageTargets.delete(worker);
            this.trustedEmitter.emit("targetdestroyed", target);
          });
          page.trustedEmitter.on("close", () => {
            this.#targets.delete(page);
            this.trustedEmitter.emit("targetdestroyed", pageTarget);
          });
          this.trustedEmitter.emit("targetcreated", pageTarget);
          return page;
        }
        targets() {
          return [...this.#targets.values()].flatMap(([target, frames]) => {
            return [target, ...frames.values()];
          });
        }
        async newPage() {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const _guard = __addDisposableResource18(env_1, await this.waitForScreenshotOperations(), false);
            const context2 = await this.userContext.createBrowsingContext(
              "tab"
              /* Bidi.BrowsingContext.CreateType.Tab */
            );
            const page = this.#pages.get(context2);
            if (!page) {
              throw new Error("Page is not found");
            }
            if (this.#defaultViewport) {
              try {
                await page.setViewport(this.#defaultViewport);
              } catch {
              }
            }
            return page;
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources18(env_1);
          }
        }
        async close() {
          assert(this.userContext.id !== UserContext.DEFAULT, "Default BrowserContext cannot be closed!");
          try {
            await this.userContext.remove();
          } catch (error) {
            debugError(error);
          }
          this.#targets.clear();
        }
        browser() {
          return this.#browser;
        }
        async pages() {
          return [...this.userContext.browsingContexts].map((context2) => {
            return this.#pages.get(context2);
          });
        }
        async overridePermissions(origin, permissions) {
          const permissionsSet = new Set(permissions.map((permission) => {
            const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
            if (!protocolPermission) {
              throw new Error("Unknown permission: " + permission);
            }
            return permission;
          }));
          await Promise.all(Array.from(WEB_PERMISSION_TO_PROTOCOL_PERMISSION.keys()).map((permission) => {
            const result = this.userContext.setPermissions(
              origin,
              {
                name: permission
              },
              permissionsSet.has(permission) ? "granted" : "denied"
              /* Bidi.Permissions.PermissionState.Denied */
            );
            this.#overrides.push({ origin, permission });
            if (!permissionsSet.has(permission)) {
              return result.catch(debugError);
            }
            return result;
          }));
        }
        async clearPermissionOverrides() {
          const promises = this.#overrides.map(({ permission, origin }) => {
            return this.userContext.setPermissions(
              origin,
              {
                name: permission
              },
              "prompt"
              /* Bidi.Permissions.PermissionState.Prompt */
            ).catch(debugError);
          });
          this.#overrides = [];
          await Promise.all(promises);
        }
        get id() {
          if (this.userContext.id === UserContext.DEFAULT) {
            return void 0;
          }
          return this.userContext.id;
        }
        async cookies() {
          const cookies = await this.userContext.getCookies();
          return cookies.map((cookie) => {
            return bidiToPuppeteerCookie(cookie, true);
          });
        }
        async setCookie(...cookies) {
          await Promise.all(cookies.map(async (cookie) => {
            const bidiCookie = {
              domain: cookie.domain,
              name: cookie.name,
              value: {
                type: "string",
                value: cookie.value
              },
              ...cookie.path !== void 0 ? { path: cookie.path } : {},
              ...cookie.httpOnly !== void 0 ? { httpOnly: cookie.httpOnly } : {},
              ...cookie.secure !== void 0 ? { secure: cookie.secure } : {},
              ...cookie.sameSite !== void 0 ? { sameSite: convertCookiesSameSiteCdpToBiDi(cookie.sameSite) } : {},
              ...{ expiry: convertCookiesExpiryCdpToBiDi(cookie.expires) },
              // Chrome-specific properties.
              ...cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookie, "sameParty", "sourceScheme", "priority", "url")
            };
            return await this.userContext.setCookie(bidiCookie, convertCookiesPartitionKeyFromPuppeteerToBiDi(cookie.partitionKey));
          }));
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js
var __runInitializers19, __esDecorate19, __addDisposableResource19, __disposeResources19, Browser2;
var init_Browser2 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js"() {
    init_EventEmitter();
    init_decorators();
    init_disposable();
    init_Realm2();
    init_UserContext();
    __runInitializers19 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate19 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __addDisposableResource19 = function(env, value, async2) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async2) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async2)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async: async2 });
      } else if (async2) {
        env.stack.push({ async: true });
      }
      return value;
    };
    __disposeResources19 = function(SuppressedError2) {
      return function(env) {
        function fail(e) {
          env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
        }
        var r, s = 0;
        function next() {
          while (r = env.stack.pop()) {
            try {
              if (!r.async && s === 1)
                return s = 0, env.stack.push(r), Promise.resolve().then(next);
              if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async)
                  return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } else
                s |= 1;
            } catch (e) {
              fail(e);
            }
          }
          if (s === 1)
            return env.hasError ? Promise.reject(env.error) : Promise.resolve();
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
    }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    });
    Browser2 = (() => {
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _dispose_decorators;
      let _close_decorators;
      let _addPreloadScript_decorators;
      let _removeIntercept_decorators;
      let _removePreloadScript_decorators;
      let _createUserContext_decorators;
      return class Browser3 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate19(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate19(this, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: (obj) => "close" in obj, get: (obj) => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate19(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: (obj) => "addPreloadScript" in obj, get: (obj) => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate19(this, null, _removeIntercept_decorators, { kind: "method", name: "removeIntercept", static: false, private: false, access: { has: (obj) => "removeIntercept" in obj, get: (obj) => obj.removeIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate19(this, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: (obj) => "removePreloadScript" in obj, get: (obj) => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate19(this, null, _createUserContext_decorators, { kind: "method", name: "createUserContext", static: false, private: false, access: { has: (obj) => "createUserContext" in obj, get: (obj) => obj.createUserContext }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static async from(session) {
          const browser = new Browser3(session);
          await browser.#initialize();
          return browser;
        }
        #closed = (__runInitializers19(this, _instanceExtraInitializers), false);
        #reason;
        #disposables = new DisposableStack();
        #userContexts = /* @__PURE__ */ new Map();
        session;
        #sharedWorkers = /* @__PURE__ */ new Map();
        constructor(session) {
          super();
          this.session = session;
        }
        async #initialize() {
          const sessionEmitter = this.#disposables.use(new EventEmitter(this.session));
          sessionEmitter.once("ended", ({ reason }) => {
            this.dispose(reason);
          });
          sessionEmitter.on("script.realmCreated", (info) => {
            if (info.type !== "shared-worker") {
              return;
            }
            this.#sharedWorkers.set(info.realm, SharedWorkerRealm.from(this, info.realm, info.origin));
          });
          await this.#syncUserContexts();
          await this.#syncBrowsingContexts();
        }
        async #syncUserContexts() {
          const { result: { userContexts } } = await this.session.send("browser.getUserContexts", {});
          for (const context2 of userContexts) {
            this.#createUserContext(context2.userContext);
          }
        }
        async #syncBrowsingContexts() {
          const contextIds = /* @__PURE__ */ new Set();
          let contexts;
          {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
              const sessionEmitter = __addDisposableResource19(env_1, new EventEmitter(this.session), false);
              sessionEmitter.on("browsingContext.contextCreated", (info) => {
                contextIds.add(info.context);
              });
              const { result } = await this.session.send("browsingContext.getTree", {});
              contexts = result.contexts;
            } catch (e_1) {
              env_1.error = e_1;
              env_1.hasError = true;
            } finally {
              __disposeResources19(env_1);
            }
          }
          for (const info of contexts) {
            if (!contextIds.has(info.context)) {
              this.session.emit("browsingContext.contextCreated", info);
            }
            if (info.children) {
              contexts.push(...info.children);
            }
          }
        }
        #createUserContext(id) {
          const userContext = UserContext.create(this, id);
          this.#userContexts.set(userContext.id, userContext);
          const userContextEmitter = this.#disposables.use(new EventEmitter(userContext));
          userContextEmitter.once("closed", () => {
            userContextEmitter.removeAllListeners();
            this.#userContexts.delete(userContext.id);
          });
          return userContext;
        }
        get closed() {
          return this.#closed;
        }
        get defaultUserContext() {
          return this.#userContexts.get(UserContext.DEFAULT);
        }
        get disconnected() {
          return this.#reason !== void 0;
        }
        get disposed() {
          return this.disconnected;
        }
        get userContexts() {
          return this.#userContexts.values();
        }
        dispose(reason, closed = false) {
          this.#closed = closed;
          this.#reason = reason;
          this[disposeSymbol]();
        }
        async close() {
          try {
            await this.session.send("browser.close", {});
          } finally {
            this.dispose("Browser already closed.", true);
          }
        }
        async addPreloadScript(functionDeclaration, options = {}) {
          const { result: { script } } = await this.session.send("script.addPreloadScript", {
            functionDeclaration,
            ...options,
            contexts: options.contexts?.map((context2) => {
              return context2.id;
            })
          });
          return script;
        }
        async removeIntercept(intercept) {
          await this.session.send("network.removeIntercept", {
            intercept
          });
        }
        async removePreloadScript(script) {
          await this.session.send("script.removePreloadScript", {
            script
          });
        }
        async createUserContext() {
          const { result: { userContext: context2 } } = await this.session.send("browser.createUserContext", {});
          return this.#createUserContext(context2);
        }
        [(_dispose_decorators = [inertIfDisposed], _close_decorators = [throwIfDisposed((browser) => {
          return browser.#reason;
        })], _addPreloadScript_decorators = [throwIfDisposed((browser) => {
          return browser.#reason;
        })], _removeIntercept_decorators = [throwIfDisposed((browser) => {
          return browser.#reason;
        })], _removePreloadScript_decorators = [throwIfDisposed((browser) => {
          return browser.#reason;
        })], _createUserContext_decorators = [throwIfDisposed((browser) => {
          return browser.#reason;
        })], disposeSymbol)]() {
          this.#reason ??= "Browser was disconnected, probably because the session ended.";
          if (this.closed) {
            this.emit("closed", { reason: this.#reason });
          }
          this.emit("disconnected", { reason: this.#reason });
          this.#disposables.dispose();
          super[disposeSymbol]();
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js
var __runInitializers20, __esDecorate20, Session;
var init_Session = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js"() {
    init_EventEmitter();
    init_decorators();
    init_disposable();
    init_Browser2();
    __runInitializers20 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __esDecorate20 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    Session = (() => {
      let _classSuper = EventEmitter;
      let _instanceExtraInitializers = [];
      let _connection_decorators;
      let _connection_initializers = [];
      let _connection_extraInitializers = [];
      let _dispose_decorators;
      let _send_decorators;
      let _subscribe_decorators;
      let _addIntercepts_decorators;
      let _end_decorators;
      return class Session2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          __esDecorate20(this, null, _connection_decorators, { kind: "accessor", name: "connection", static: false, private: false, access: { has: (obj) => "connection" in obj, get: (obj) => obj.connection, set: (obj, value) => {
            obj.connection = value;
          } }, metadata: _metadata }, _connection_initializers, _connection_extraInitializers);
          __esDecorate20(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: (obj) => "dispose" in obj, get: (obj) => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate20(this, null, _send_decorators, { kind: "method", name: "send", static: false, private: false, access: { has: (obj) => "send" in obj, get: (obj) => obj.send }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate20(this, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: (obj) => "subscribe" in obj, get: (obj) => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate20(this, null, _addIntercepts_decorators, { kind: "method", name: "addIntercepts", static: false, private: false, access: { has: (obj) => "addIntercepts" in obj, get: (obj) => obj.addIntercepts }, metadata: _metadata }, null, _instanceExtraInitializers);
          __esDecorate20(this, null, _end_decorators, { kind: "method", name: "end", static: false, private: false, access: { has: (obj) => "end" in obj, get: (obj) => obj.end }, metadata: _metadata }, null, _instanceExtraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static async from(connection, capabilities) {
          const { result } = await connection.send("session.new", {
            capabilities
          });
          const session = new Session2(connection, result);
          await session.#initialize();
          return session;
        }
        #reason = __runInitializers20(this, _instanceExtraInitializers);
        #disposables = new DisposableStack();
        #info;
        browser;
        #connection_accessor_storage = __runInitializers20(this, _connection_initializers, void 0);
        get connection() {
          return this.#connection_accessor_storage;
        }
        set connection(value) {
          this.#connection_accessor_storage = value;
        }
        constructor(connection, info) {
          super();
          __runInitializers20(this, _connection_extraInitializers);
          this.#info = info;
          this.connection = connection;
        }
        async #initialize() {
          this.browser = await Browser2.from(this);
          const browserEmitter = this.#disposables.use(this.browser);
          browserEmitter.once("closed", ({ reason }) => {
            this.dispose(reason);
          });
          const seen = /* @__PURE__ */ new WeakSet();
          this.on("browsingContext.fragmentNavigated", (info) => {
            if (seen.has(info)) {
              return;
            }
            seen.add(info);
            this.emit("browsingContext.navigationStarted", info);
            this.emit("browsingContext.fragmentNavigated", info);
          });
        }
        get capabilities() {
          return this.#info.capabilities;
        }
        get disposed() {
          return this.ended;
        }
        get ended() {
          return this.#reason !== void 0;
        }
        get id() {
          return this.#info.sessionId;
        }
        dispose(reason) {
          this.#reason = reason;
          this[disposeSymbol]();
        }
        /**
         * Currently, there is a 1:1 relationship between the session and the
         * session. In the future, we might support multiple sessions and in that
         * case we always needs to make sure that the session for the right session
         * object is used, so we implement this method here, although it's not defined
         * in the spec.
         */
        async send(method, params) {
          return await this.connection.send(method, params);
        }
        async subscribe(events, contexts) {
          await this.send("session.subscribe", {
            events,
            contexts
          });
        }
        async addIntercepts(events, contexts) {
          await this.send("session.subscribe", {
            events,
            contexts
          });
        }
        async end() {
          try {
            await this.send("session.end", {});
          } finally {
            this.dispose(`Session already ended.`);
          }
        }
        [(_connection_decorators = [bubble()], _dispose_decorators = [inertIfDisposed], _send_decorators = [throwIfDisposed((session) => {
          return session.#reason;
        })], _subscribe_decorators = [throwIfDisposed((session) => {
          return session.#reason;
        })], _addIntercepts_decorators = [throwIfDisposed((session) => {
          return session.#reason;
        })], _end_decorators = [throwIfDisposed((session) => {
          return session.#reason;
        })], disposeSymbol)]() {
          this.#reason ??= "Session already destroyed, probably because the connection broke.";
          this.emit("ended", { reason: this.#reason });
          this.#disposables.dispose();
          super[disposeSymbol]();
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js
var __esDecorate21, __runInitializers21, __setFunctionName4, BidiBrowser;
var init_Browser3 = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js"() {
    init_Browser();
    init_EventEmitter();
    init_util();
    init_decorators();
    init_BrowserContext2();
    init_Session();
    init_Target2();
    __esDecorate21 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers21 = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
    };
    __setFunctionName4 = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    BidiBrowser = (() => {
      let _classSuper = Browser;
      let _private_trustedEmitter_decorators;
      let _private_trustedEmitter_initializers = [];
      let _private_trustedEmitter_extraInitializers = [];
      let _private_trustedEmitter_descriptor;
      return class BidiBrowser2 extends _classSuper {
        static {
          const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
          _private_trustedEmitter_decorators = [bubble()];
          __esDecorate21(this, _private_trustedEmitter_descriptor = { get: __setFunctionName4(function() {
            return this.#trustedEmitter_accessor_storage;
          }, "#trustedEmitter", "get"), set: __setFunctionName4(function(value) {
            this.#trustedEmitter_accessor_storage = value;
          }, "#trustedEmitter", "set") }, _private_trustedEmitter_decorators, { kind: "accessor", name: "#trustedEmitter", static: false, private: true, access: { has: (obj) => #trustedEmitter in obj, get: (obj) => obj.#trustedEmitter, set: (obj, value) => {
            obj.#trustedEmitter = value;
          } }, metadata: _metadata }, _private_trustedEmitter_initializers, _private_trustedEmitter_extraInitializers);
          if (_metadata)
            Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        protocol = "webDriverBiDi";
        static subscribeModules = [
          "browsingContext",
          "network",
          "log",
          "script"
        ];
        static subscribeCdpEvents = [
          // Coverage
          "goog:cdp.Debugger.scriptParsed",
          "goog:cdp.CSS.styleSheetAdded",
          "goog:cdp.Runtime.executionContextsCleared",
          // Tracing
          "goog:cdp.Tracing.tracingComplete",
          // TODO: subscribe to all CDP events in the future.
          "goog:cdp.Network.requestWillBeSent",
          "goog:cdp.Debugger.scriptParsed",
          "goog:cdp.Page.screencastFrame"
        ];
        static async create(opts) {
          const session = await Session.from(opts.connection, {
            firstMatch: opts.capabilities?.firstMatch,
            alwaysMatch: {
              ...opts.capabilities?.alwaysMatch,
              // Capabilities that come from Puppeteer's API take precedence.
              acceptInsecureCerts: opts.acceptInsecureCerts,
              unhandledPromptBehavior: {
                default: "ignore"
              },
              webSocketUrl: true,
              // Puppeteer with WebDriver BiDi does not support prerendering
              // yet because WebDriver BiDi behavior is not specified. See
              // https://github.com/w3c/webdriver-bidi/issues/321.
              "goog:prerenderingDisabled": true
            }
          });
          await session.subscribe(session.capabilities.browserName.toLocaleLowerCase().includes("firefox") ? BidiBrowser2.subscribeModules : [...BidiBrowser2.subscribeModules, ...BidiBrowser2.subscribeCdpEvents]);
          const browser = new BidiBrowser2(session.browser, opts);
          browser.#initialize();
          return browser;
        }
        #trustedEmitter_accessor_storage = __runInitializers21(this, _private_trustedEmitter_initializers, new EventEmitter());
        get #trustedEmitter() {
          return _private_trustedEmitter_descriptor.get.call(this);
        }
        set #trustedEmitter(value) {
          return _private_trustedEmitter_descriptor.set.call(this, value);
        }
        #process = __runInitializers21(this, _private_trustedEmitter_extraInitializers);
        #closeCallback;
        #browserCore;
        #defaultViewport;
        #browserContexts = /* @__PURE__ */ new WeakMap();
        #target = new BidiBrowserTarget(this);
        #cdpConnection;
        constructor(browserCore, opts) {
          super();
          this.#process = opts.process;
          this.#closeCallback = opts.closeCallback;
          this.#browserCore = browserCore;
          this.#defaultViewport = opts.defaultViewport;
          this.#cdpConnection = opts.cdpConnection;
        }
        #initialize() {
          for (const userContext of this.#browserCore.userContexts) {
            this.#createBrowserContext(userContext);
          }
          this.#browserCore.once("disconnected", () => {
            this.#trustedEmitter.emit("disconnected", void 0);
            this.#trustedEmitter.removeAllListeners();
          });
          this.#process?.once("close", () => {
            this.#browserCore.dispose("Browser process exited.", true);
            this.connection.dispose();
          });
        }
        get #browserName() {
          return this.#browserCore.session.capabilities.browserName;
        }
        get #browserVersion() {
          return this.#browserCore.session.capabilities.browserVersion;
        }
        get cdpSupported() {
          return this.#cdpConnection !== void 0;
        }
        get cdpConnection() {
          return this.#cdpConnection;
        }
        async userAgent() {
          return this.#browserCore.session.capabilities.userAgent;
        }
        #createBrowserContext(userContext) {
          const browserContext = BidiBrowserContext.from(this, userContext, {
            defaultViewport: this.#defaultViewport
          });
          this.#browserContexts.set(userContext, browserContext);
          browserContext.trustedEmitter.on("targetcreated", (target) => {
            this.#trustedEmitter.emit("targetcreated", target);
          });
          browserContext.trustedEmitter.on("targetchanged", (target) => {
            this.#trustedEmitter.emit("targetchanged", target);
          });
          browserContext.trustedEmitter.on("targetdestroyed", (target) => {
            this.#trustedEmitter.emit("targetdestroyed", target);
          });
          return browserContext;
        }
        get connection() {
          return this.#browserCore.session.connection;
        }
        wsEndpoint() {
          return this.connection.url;
        }
        async close() {
          if (this.connection.closed) {
            return;
          }
          try {
            await this.#browserCore.close();
            await this.#closeCallback?.call(null);
          } catch (error) {
            debugError(error);
          } finally {
            this.connection.dispose();
          }
        }
        get connected() {
          return !this.#browserCore.disconnected;
        }
        process() {
          return this.#process ?? null;
        }
        async createBrowserContext(_options) {
          const userContext = await this.#browserCore.createUserContext();
          return this.#createBrowserContext(userContext);
        }
        async version() {
          return `${this.#browserName}/${this.#browserVersion}`;
        }
        browserContexts() {
          return [...this.#browserCore.userContexts].map((context2) => {
            return this.#browserContexts.get(context2);
          });
        }
        defaultBrowserContext() {
          return this.#browserContexts.get(this.#browserCore.defaultUserContext);
        }
        newPage() {
          return this.defaultBrowserContext().newPage();
        }
        targets() {
          return [
            this.#target,
            ...this.browserContexts().flatMap((context2) => {
              return context2.targets();
            })
          ];
        }
        target() {
          return this.#target;
        }
        async disconnect() {
          try {
            await this.#browserCore.session.end();
          } catch (error) {
            debugError(error);
          } finally {
            this.connection.dispose();
          }
        }
        get debugInfo() {
          return {
            pendingProtocolErrors: this.connection.getPendingProtocolErrors()
          };
        }
      };
    })();
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js
var bidi_exports = {};
__export(bidi_exports, {
  BidiBrowser: () => BidiBrowser,
  BidiBrowserContext: () => BidiBrowserContext,
  BidiConnection: () => BidiConnection,
  BidiElementHandle: () => BidiElementHandle,
  BidiFrame: () => BidiFrame,
  BidiFrameRealm: () => BidiFrameRealm,
  BidiHTTPRequest: () => BidiHTTPRequest,
  BidiHTTPResponse: () => BidiHTTPResponse,
  BidiJSHandle: () => BidiJSHandle,
  BidiKeyboard: () => BidiKeyboard,
  BidiMouse: () => BidiMouse,
  BidiPage: () => BidiPage,
  BidiRealm: () => BidiRealm,
  BidiTouchscreen: () => BidiTouchscreen,
  BidiWorkerRealm: () => BidiWorkerRealm,
  bidiToPuppeteerCookie: () => bidiToPuppeteerCookie,
  cdpSpecificCookiePropertiesFromPuppeteerToBidi: () => cdpSpecificCookiePropertiesFromPuppeteerToBidi,
  connectBidiOverCdp: () => connectBidiOverCdp,
  convertCookiesExpiryCdpToBiDi: () => convertCookiesExpiryCdpToBiDi,
  convertCookiesPartitionKeyFromPuppeteerToBiDi: () => convertCookiesPartitionKeyFromPuppeteerToBiDi,
  convertCookiesSameSiteCdpToBiDi: () => convertCookiesSameSiteCdpToBiDi,
  requests: () => requests
});
var init_bidi = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js"() {
    init_BidiOverCdp();
    init_Browser3();
    init_BrowserContext2();
    init_Connection();
    init_ElementHandle2();
    init_Frame2();
    init_HTTPRequest2();
    init_HTTPResponse2();
    init_Input2();
    init_JSHandle2();
    init_Page2();
    init_Realm3();
  }
});

// node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/node/NodeWebSocketTransport.js
var NodeWebSocketTransport_exports = {};
__export(NodeWebSocketTransport_exports, {
  NodeWebSocketTransport: () => NodeWebSocketTransport
});
var import_ws, NodeWebSocketTransport;
var init_NodeWebSocketTransport = __esm({
  "node_modules/puppeteer-core/lib/esm/puppeteer/node/NodeWebSocketTransport.js"() {
    import_ws = __toESM(require_browser2(), 1);
    init_version();
    NodeWebSocketTransport = class {
      static create(url, headers) {
        return new Promise((resolve, reject) => {
          const ws = new import_ws.default(url, [], {
            followRedirects: true,
            perMessageDeflate: false,
            // @ts-expect-error https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketaddress-protocols-options
            allowSynchronousEvents: false,
            maxPayload: 256 * 1024 * 1024,
            // 256Mb
            headers: {
              "User-Agent": `Puppeteer ${packageVersion}`,
              ...headers
            }
          });
          ws.addEventListener("open", () => {
            return resolve(new NodeWebSocketTransport(ws));
          });
          ws.addEventListener("error", reject);
        });
      }
      #ws;
      onmessage;
      onclose;
      constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener("message", (event) => {
          if (this.onmessage) {
            this.onmessage.call(null, event.data);
          }
        });
        this.#ws.addEventListener("close", () => {
          if (this.onclose) {
            this.onclose.call(null);
          }
        });
        this.#ws.addEventListener("error", () => {
        });
      }
      send(message) {
        this.#ws.send(message);
      }
      close() {
        this.#ws.close();
      }
    };
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/api/api.js
init_Browser();
init_BrowserContext();
init_CDPSession();
init_Dialog();
init_ElementHandle();
init_Frame();
init_HTTPRequest();
init_HTTPResponse();
init_Input();
init_JSHandle();
init_Page();
init_Realm();
init_Target();
init_WebWorker();
init_locators();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/cdp.js
init_Accessibility();
init_AriaQueryHandler();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Binding.js
init_JSHandle();
init_util();
init_disposable();
init_ErrorLike();
var __addDisposableResource10 = function(env, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose, inner;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async2)
        inner = dispose;
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    if (inner)
      dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    env.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources10 = function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1)
            return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async)
              return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } else
            s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1)
        return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var Binding = class {
  #name;
  #fn;
  #initSource;
  constructor(name, fn, initSource) {
    this.#name = name;
    this.#fn = fn;
    this.#initSource = initSource;
  }
  get name() {
    return this.#name;
  }
  get initSource() {
    return this.#initSource;
  }
  /**
   * @param context - Context to run the binding in; the context should have
   * the binding added to it beforehand.
   * @param id - ID of the call. This should come from the CDP
   * `onBindingCalled` response.
   * @param args - Plain arguments from CDP.
   */
  async run(context2, id, args, isTrivial) {
    const stack = new DisposableStack();
    try {
      if (!isTrivial) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handles = __addDisposableResource10(env_1, await context2.evaluateHandle((name, seq) => {
            return globalThis[name].args.get(seq);
          }, this.#name, id), false);
          const properties = await handles.getProperties();
          for (const [index, handle] of properties) {
            if (index in args) {
              switch (handle.remoteObject().subtype) {
                case "node":
                  args[+index] = handle;
                  break;
                default:
                  stack.use(handle);
              }
            } else {
              stack.use(handle);
            }
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources10(env_1);
        }
      }
      await context2.evaluate((name, seq, result) => {
        const callbacks = globalThis[name].callbacks;
        callbacks.get(seq).resolve(result);
        callbacks.delete(seq);
      }, this.#name, id, await this.#fn(...args));
      for (const arg of args) {
        if (arg instanceof JSHandle) {
          stack.use(arg);
        }
      }
    } catch (error) {
      if (isErrorLike(error)) {
        await context2.evaluate((name, seq, message, stack2) => {
          const error2 = new Error(message);
          error2.stack = stack2;
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq).reject(error2);
          callbacks.delete(seq);
        }, this.#name, id, error.message, error.stack).catch(debugError);
      } else {
        await context2.evaluate((name, seq, error2) => {
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq).reject(error2);
          callbacks.delete(seq);
        }, this.#name, id, error).catch(debugError);
      }
    }
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Browser.js
init_Browser();
init_CDPSession();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserContext.js
init_Browser();
init_BrowserContext();
init_assert();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
init_rxjs();
init_CDPSession();
init_Page();
init_ConsoleMessage();
init_Errors();
init_EventEmitter();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/FileChooser.js
init_assert();
var FileChooser = class {
  #element;
  #multiple;
  #handled = false;
  /**
   * @internal
   */
  constructor(element, event) {
    this.#element = element;
    this.#multiple = event.mode !== "selectSingle";
  }
  /**
   * Whether file chooser allow for
   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
   * file selection.
   */
  isMultiple() {
    return this.#multiple;
  }
  /**
   * Accept the file chooser request with the given file paths.
   *
   * @remarks This will not validate whether the file paths exists. Also, if a
   * path is relative, then it is resolved against the
   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
   * For locals script connecting to remote chrome environments, paths must be
   * absolute.
   */
  async accept(paths) {
    assert(!this.#handled, "Cannot accept FileChooser which is already handled!");
    this.#handled = true;
    await this.#element.uploadFile(...paths);
  }
  /**
   * Closes the file chooser without selecting any files.
   */
  async cancel() {
    assert(!this.#handled, "Cannot cancel FileChooser which is already handled!");
    this.#handled = true;
    await this.#element.evaluate((element) => {
      element.dispatchEvent(new Event("cancel", { bubbles: true }));
    });
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManagerEvents.js
var NetworkManagerEvent;
(function(NetworkManagerEvent2) {
  NetworkManagerEvent2.Request = Symbol("NetworkManager.Request");
  NetworkManagerEvent2.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache");
  NetworkManagerEvent2.Response = Symbol("NetworkManager.Response");
  NetworkManagerEvent2.RequestFailed = Symbol("NetworkManager.RequestFailed");
  NetworkManagerEvent2.RequestFinished = Symbol("NetworkManager.RequestFinished");
})(NetworkManagerEvent || (NetworkManagerEvent = {}));

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
init_util();
init_assert();
init_Deferred();
init_disposable();
init_ErrorLike();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/CdpSession.js
init_CDPSession();
init_CallbackRegistry();
init_Errors();
init_assert();
init_ErrorLike();
var CdpCDPSession = class extends CDPSession {
  #sessionId;
  #targetType;
  #callbacks = new CallbackRegistry();
  #connection;
  #parentSessionId;
  #target;
  #rawErrors = false;
  #detached = false;
  /**
   * @internal
   */
  constructor(connection, targetType, sessionId, parentSessionId, rawErrors) {
    super();
    this.#connection = connection;
    this.#targetType = targetType;
    this.#sessionId = sessionId;
    this.#parentSessionId = parentSessionId;
    this.#rawErrors = rawErrors;
  }
  /**
   * Sets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  setTarget(target) {
    this.#target = target;
  }
  /**
   * Gets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  target() {
    assert(this.#target, "Target must exist");
    return this.#target;
  }
  connection() {
    return this.#connection;
  }
  get detached() {
    return this.#connection._closed || this.#detached;
  }
  parentSession() {
    if (!this.#parentSessionId) {
      return this;
    }
    const parent = this.#connection?.session(this.#parentSessionId);
    return parent ?? void 0;
  }
  send(method, params, options) {
    if (this.detached) {
      return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${this.#targetType} has been closed.`));
    }
    return this.#connection._rawSend(this.#callbacks, method, params, this.#sessionId, options);
  }
  /**
   * @internal
   */
  onMessage(object) {
    if (object.id) {
      if (object.error) {
        if (this.#rawErrors) {
          this.#callbacks.rejectRaw(object.id, object.error);
        } else {
          this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
        }
      } else {
        this.#callbacks.resolve(object.id, object.result);
      }
    } else {
      assert(!object.id);
      this.emit(object.method, object.params);
    }
  }
  /**
   * Detaches the cdpSession from the target. Once detached, the cdpSession object
   * won't emit any events and can't be used to send messages.
   */
  async detach() {
    if (this.detached) {
      throw new Error(`Session already detached. Most likely the ${this.#targetType} has been closed.`);
    }
    await this.#connection.send("Target.detachFromTarget", {
      sessionId: this.#sessionId
    });
    this.#detached = true;
  }
  /**
   * @internal
   */
  onClosed() {
    this.#callbacks.clear();
    this.#detached = true;
    this.emit(CDPSessionEvent.Disconnected, void 0);
  }
  /**
   * Returns the session's id.
   */
  id() {
    return this.#sessionId;
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    return this.#callbacks.getPendingProtocolErrors();
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Connection.js
init_CDPSession();
init_CallbackRegistry();
init_Debug();
init_Errors();
init_EventEmitter();
init_ErrorLike();
var debugProtocolSend = debug("puppeteer:protocol:SEND \u25BA");
var debugProtocolReceive = debug("puppeteer:protocol:RECV \u25C0");
var Connection = class extends EventEmitter {
  #url;
  #transport;
  #delay;
  #timeout;
  #sessions = /* @__PURE__ */ new Map();
  #closed = false;
  #manuallyAttached = /* @__PURE__ */ new Set();
  #callbacks;
  #rawErrors = false;
  constructor(url, transport, delay = 0, timeout2, rawErrors = false) {
    super();
    this.#rawErrors = rawErrors;
    this.#callbacks = new CallbackRegistry();
    this.#url = url;
    this.#delay = delay;
    this.#timeout = timeout2 ?? 18e4;
    this.#transport = transport;
    this.#transport.onmessage = this.onMessage.bind(this);
    this.#transport.onclose = this.#onClose.bind(this);
  }
  static fromSession(session) {
    return session.connection();
  }
  /**
   * @internal
   */
  get delay() {
    return this.#delay;
  }
  get timeout() {
    return this.#timeout;
  }
  /**
   * @internal
   */
  get _closed() {
    return this.#closed;
  }
  /**
   * @internal
   */
  get _sessions() {
    return this.#sessions;
  }
  /**
   * @internal
   */
  _session(sessionId) {
    return this.#sessions.get(sessionId) || null;
  }
  /**
   * @param sessionId - The session id
   * @returns The current CDP session if it exists
   */
  session(sessionId) {
    return this._session(sessionId);
  }
  url() {
    return this.#url;
  }
  send(method, params, options) {
    return this._rawSend(this.#callbacks, method, params, void 0, options);
  }
  /**
   * @internal
   */
  _rawSend(callbacks, method, params, sessionId, options) {
    if (this.#closed) {
      return Promise.reject(new Error("Protocol error: Connection closed."));
    }
    return callbacks.create(method, options?.timeout ?? this.#timeout, (id) => {
      const stringifiedMessage = JSON.stringify({
        method,
        params,
        id,
        sessionId
      });
      debugProtocolSend(stringifiedMessage);
      this.#transport.send(stringifiedMessage);
    });
  }
  /**
   * @internal
   */
  async closeBrowser() {
    await this.send("Browser.close");
  }
  /**
   * @internal
   */
  async onMessage(message) {
    if (this.#delay) {
      await new Promise((r) => {
        return setTimeout(r, this.#delay);
      });
    }
    debugProtocolReceive(message);
    const object = JSON.parse(message);
    if (object.method === "Target.attachedToTarget") {
      const sessionId = object.params.sessionId;
      const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId, this.#rawErrors);
      this.#sessions.set(sessionId, session);
      this.emit(CDPSessionEvent.SessionAttached, session);
      const parentSession = this.#sessions.get(object.sessionId);
      if (parentSession) {
        parentSession.emit(CDPSessionEvent.SessionAttached, session);
      }
    } else if (object.method === "Target.detachedFromTarget") {
      const session = this.#sessions.get(object.params.sessionId);
      if (session) {
        session.onClosed();
        this.#sessions.delete(object.params.sessionId);
        this.emit(CDPSessionEvent.SessionDetached, session);
        const parentSession = this.#sessions.get(object.sessionId);
        if (parentSession) {
          parentSession.emit(CDPSessionEvent.SessionDetached, session);
        }
      }
    }
    if (object.sessionId) {
      const session = this.#sessions.get(object.sessionId);
      if (session) {
        session.onMessage(object);
      }
    } else if (object.id) {
      if (object.error) {
        if (this.#rawErrors) {
          this.#callbacks.rejectRaw(object.id, object.error);
        } else {
          this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
        }
      } else {
        this.#callbacks.resolve(object.id, object.result);
      }
    } else {
      this.emit(object.method, object.params);
    }
  }
  #onClose() {
    if (this.#closed) {
      return;
    }
    this.#closed = true;
    this.#transport.onmessage = void 0;
    this.#transport.onclose = void 0;
    this.#callbacks.clear();
    for (const session of this.#sessions.values()) {
      session.onClosed();
    }
    this.#sessions.clear();
    this.emit(CDPSessionEvent.Disconnected, void 0);
  }
  dispose() {
    this.#onClose();
    this.#transport.close();
  }
  /**
   * @internal
   */
  isAutoAttached(targetId) {
    return !this.#manuallyAttached.has(targetId);
  }
  /**
   * @internal
   */
  async _createSession(targetInfo, isAutoAttachEmulated = true) {
    if (!isAutoAttachEmulated) {
      this.#manuallyAttached.add(targetInfo.targetId);
    }
    const { sessionId } = await this.send("Target.attachToTarget", {
      targetId: targetInfo.targetId,
      flatten: true
    });
    this.#manuallyAttached.delete(targetInfo.targetId);
    const session = this.#sessions.get(sessionId);
    if (!session) {
      throw new Error("CDPSession creation failed.");
    }
    return session;
  }
  /**
   * @param targetInfo - The target info
   * @returns The CDP session that is created
   */
  async createSession(targetInfo) {
    return await this._createSession(targetInfo, false);
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const result = [];
    result.push(...this.#callbacks.getPendingProtocolErrors());
    for (const session of this.#sessions.values()) {
      result.push(...session.getPendingProtocolErrors());
    }
    return result;
  }
};
function isTargetClosedError(error) {
  return error instanceof TargetCloseError;
}

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
init_Coverage();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Dialog.js
init_Dialog();
var CdpDialog = class extends Dialog {
  #client;
  constructor(client, type, message, defaultValue = "") {
    super(type, message, defaultValue);
    this.#client = client;
  }
  async handle(options) {
    await this.#client.send("Page.handleJavaScriptDialog", {
      accept: options.accept,
      promptText: options.text
    });
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
init_EmulationManager();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
init_CDPSession();
init_Frame();
init_EventEmitter();
init_util();
init_assert();
init_Deferred();
init_disposable();
init_ErrorLike();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/CdpPreloadScript.js
var CdpPreloadScript = class {
  /**
   * This is the ID of the preload script returned by
   * Page.addScriptToEvaluateOnNewDocument in the main frame.
   *
   * Sub-frames would get a different CDP ID because
   * addScriptToEvaluateOnNewDocument is called for each subframe. But
   * users only see this ID and subframe IDs are internal to Puppeteer.
   */
  #id;
  #source;
  #frameToId = /* @__PURE__ */ new WeakMap();
  constructor(mainFrame, id, source2) {
    this.#id = id;
    this.#source = source2;
    this.#frameToId.set(mainFrame, id);
  }
  get id() {
    return this.#id;
  }
  get source() {
    return this.#source;
  }
  getIdForFrame(frame) {
    return this.#frameToId.get(frame);
  }
  setIdForFrame(frame, identifier) {
    this.#frameToId.set(frame, identifier);
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js
init_assert();
init_Deferred();
var DeviceRequestPromptDevice = class {
  /**
   * Device id during a prompt.
   */
  id;
  /**
   * Device name as it appears in a prompt.
   */
  name;
  /**
   * @internal
   */
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }
};
var DeviceRequestPrompt = class {
  #client;
  #timeoutSettings;
  #id;
  #handled = false;
  #updateDevicesHandle = this.#updateDevices.bind(this);
  #waitForDevicePromises = /* @__PURE__ */ new Set();
  /**
   * Current list of selectable devices.
   */
  devices = [];
  /**
   * @internal
   */
  constructor(client, timeoutSettings, firstEvent) {
    this.#client = client;
    this.#timeoutSettings = timeoutSettings;
    this.#id = firstEvent.id;
    this.#client.on("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
    this.#client.on("Target.detachedFromTarget", () => {
      this.#client = null;
    });
    this.#updateDevices(firstEvent);
  }
  #updateDevices(event) {
    if (event.id !== this.#id) {
      return;
    }
    for (const rawDevice of event.devices) {
      if (this.devices.some((device) => {
        return device.id === rawDevice.id;
      })) {
        continue;
      }
      const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
      this.devices.push(newDevice);
      for (const waitForDevicePromise of this.#waitForDevicePromises) {
        if (waitForDevicePromise.filter(newDevice)) {
          waitForDevicePromise.promise.resolve(newDevice);
        }
      }
    }
  }
  /**
   * Resolve to the first device in the prompt matching a filter.
   */
  async waitForDevice(filter2, options = {}) {
    for (const device of this.devices) {
      if (filter2(device)) {
        return device;
      }
    }
    const { timeout: timeout2 = this.#timeoutSettings.timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout2}ms exceeded`,
      timeout: timeout2
    });
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        deferred.reject(options.signal?.reason);
      }, { once: true });
    }
    const handle = { filter: filter2, promise: deferred };
    this.#waitForDevicePromises.add(handle);
    try {
      return await deferred.valueOrThrow();
    } finally {
      this.#waitForDevicePromises.delete(handle);
    }
  }
  /**
   * Select a device in the prompt's list.
   */
  async select(device) {
    assert(this.#client !== null, "Cannot select device through detached session!");
    assert(this.devices.includes(device), "Cannot select unknown device!");
    assert(!this.#handled, "Cannot select DeviceRequestPrompt which is already handled!");
    this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
    this.#handled = true;
    return await this.#client.send("DeviceAccess.selectPrompt", {
      id: this.#id,
      deviceId: device.id
    });
  }
  /**
   * Cancel the prompt.
   */
  async cancel() {
    assert(this.#client !== null, "Cannot cancel prompt through detached session!");
    assert(!this.#handled, "Cannot cancel DeviceRequestPrompt which is already handled!");
    this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
    this.#handled = true;
    return await this.#client.send("DeviceAccess.cancelPrompt", { id: this.#id });
  }
};
var DeviceRequestPromptManager = class {
  #client;
  #timeoutSettings;
  #deviceRequestPromptDeferreds = /* @__PURE__ */ new Set();
  /**
   * @internal
   */
  constructor(client, timeoutSettings) {
    this.#client = client;
    this.#timeoutSettings = timeoutSettings;
    this.#client.on("DeviceAccess.deviceRequestPrompted", (event) => {
      this.#onDeviceRequestPrompted(event);
    });
    this.#client.on("Target.detachedFromTarget", () => {
      this.#client = null;
    });
  }
  /**
   * Wait for device prompt created by an action like calling WebBluetooth's
   * requestDevice.
   */
  async waitForDevicePrompt(options = {}) {
    assert(this.#client !== null, "Cannot wait for device prompt through detached session!");
    const needsEnable = this.#deviceRequestPromptDeferreds.size === 0;
    let enablePromise;
    if (needsEnable) {
      enablePromise = this.#client.send("DeviceAccess.enable");
    }
    const { timeout: timeout2 = this.#timeoutSettings.timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout2}ms exceeded`,
      timeout: timeout2
    });
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        deferred.reject(options.signal?.reason);
      }, { once: true });
    }
    this.#deviceRequestPromptDeferreds.add(deferred);
    try {
      const [result] = await Promise.all([
        deferred.valueOrThrow(),
        enablePromise
      ]);
      return result;
    } finally {
      this.#deviceRequestPromptDeferreds.delete(deferred);
    }
  }
  /**
   * @internal
   */
  #onDeviceRequestPrompted(event) {
    if (!this.#deviceRequestPromptDeferreds.size) {
      return;
    }
    assert(this.#client !== null);
    const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);
    for (const promise of this.#deviceRequestPromptDeferreds) {
      promise.resolve(devicePrompt);
    }
    this.#deviceRequestPromptDeferreds.clear();
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js
init_CDPSession();
init_EventEmitter();
init_LazyArg();
init_ScriptInjector();
init_util();
init_AsyncIterableUtil();
init_disposable();
init_Function();
init_Mutex();
init_AriaQueryHandler();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js
init_ElementHandle();
init_util();
init_environment();
init_assert();
init_AsyncIterableUtil();
init_decorators();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js
init_JSHandle();
init_util();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/utils.js
init_util();
init_assert();
function createEvaluationError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const messageHeight = message.split("\n").length;
  const error = new Error(message);
  error.name = name;
  const stackLines = error.stack.split("\n");
  const messageLines = stackLines.splice(0, messageHeight);
  stackLines.shift();
  if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
    for (const frame of details.stackTrace.callFrames.reverse()) {
      if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
        const url = PuppeteerURL.parse(frame.url);
        stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
      } else {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
      }
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
var getErrorDetails = (details) => {
  let name = "";
  let message;
  const lines = details.exception?.description?.split("\n    at ") ?? [];
  const size = Math.min(details.stackTrace?.callFrames.length ?? 0, lines.length - 1);
  lines.splice(-size, size);
  if (details.exception?.className) {
    name = details.exception.className;
  }
  message = lines.join("\n");
  if (name && message.startsWith(`${name}: `)) {
    message = message.slice(name.length + 2);
  }
  return { message, name };
};
function createClientError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const error = new Error(message);
  error.name = name;
  const messageHeight = error.message.split("\n").length;
  const messageLines = error.stack.split("\n").splice(0, messageHeight);
  const stackLines = [];
  if (details.stackTrace) {
    for (const frame of details.stackTrace.callFrames) {
      stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
function valueFromRemoteObject(remoteObject) {
  assert(!remoteObject.objectId, "Cannot extract value when objectId is given");
  if (remoteObject.unserializableValue) {
    if (remoteObject.type === "bigint") {
      return BigInt(remoteObject.unserializableValue.replace("n", ""));
    }
    switch (remoteObject.unserializableValue) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
    }
  }
  return remoteObject.value;
}
function addPageBinding(type, name, prefix) {
  if (globalThis[name]) {
    return;
  }
  Object.assign(globalThis, {
    [name](...args) {
      const callPuppeteer = globalThis[name];
      callPuppeteer.args ??= /* @__PURE__ */ new Map();
      callPuppeteer.callbacks ??= /* @__PURE__ */ new Map();
      const seq = (callPuppeteer.lastSeq ?? 0) + 1;
      callPuppeteer.lastSeq = seq;
      callPuppeteer.args.set(seq, args);
      globalThis[prefix + name](JSON.stringify({
        type,
        name,
        seq,
        args,
        isTrivial: !args.some((value) => {
          return value instanceof Node;
        })
      }));
      return new Promise((resolve, reject) => {
        callPuppeteer.callbacks.set(seq, {
          resolve(value) {
            callPuppeteer.args.delete(seq);
            resolve(value);
          },
          reject(value) {
            callPuppeteer.args.delete(seq);
            reject(value);
          }
        });
      });
    }
  });
}
var CDP_BINDING_PREFIX = "puppeteer_";
function pageBindingInitString(type, name) {
  return evaluationString(addPageBinding, type, name, CDP_BINDING_PREFIX);
}

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js
var CdpJSHandle = class extends JSHandle {
  #disposed = false;
  #remoteObject;
  #world;
  constructor(world, remoteObject) {
    super();
    this.#world = world;
    this.#remoteObject = remoteObject;
  }
  get disposed() {
    return this.#disposed;
  }
  get realm() {
    return this.#world;
  }
  get client() {
    return this.realm.environment.client;
  }
  async jsonValue() {
    if (!this.#remoteObject.objectId) {
      return valueFromRemoteObject(this.#remoteObject);
    }
    const value = await this.evaluate((object) => {
      return object;
    });
    if (value === void 0) {
      throw new Error("Could not serialize referenced object");
    }
    return value;
  }
  /**
   * Either `null` or the handle itself if the handle is an
   * instance of {@link ElementHandle}.
   */
  asElement() {
    return null;
  }
  async dispose() {
    if (this.#disposed) {
      return;
    }
    this.#disposed = true;
    await releaseObject(this.client, this.#remoteObject);
  }
  toString() {
    if (!this.#remoteObject.objectId) {
      return "JSHandle:" + valueFromRemoteObject(this.#remoteObject);
    }
    const type = this.#remoteObject.subtype || this.#remoteObject.type;
    return "JSHandle@" + type;
  }
  get id() {
    return this.#remoteObject.objectId;
  }
  remoteObject() {
    return this.#remoteObject;
  }
  async getProperties() {
    const response = await this.client.send("Runtime.getProperties", {
      objectId: this.#remoteObject.objectId,
      ownProperties: true
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.result) {
      if (!property.enumerable || !property.value) {
        continue;
      }
      result.set(property.name, this.#world.createCdpHandle(property.value));
    }
    return result;
  }
};
async function releaseObject(client, remoteObject) {
  if (!remoteObject.objectId) {
    return;
  }
  await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
    debugError(error);
  });
}

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js
var __runInitializers6 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var NON_ELEMENT_NODE_ROLES = /* @__PURE__ */ new Set(["StaticText", "InlineTextBox"]);
var CdpElementHandle = (() => {
  let _classSuper = ElementHandle;
  let _instanceExtraInitializers = [];
  let _contentFrame_decorators;
  let _scrollIntoView_decorators;
  let _uploadFile_decorators;
  let _autofill_decorators;
  return class CdpElementHandle extends _classSuper {
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _contentFrame_decorators = [throwIfDisposed()];
      _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _uploadFile_decorators = [throwIfDisposed(), bindIsolatedHandle];
      _autofill_decorators = [throwIfDisposed()];
      __esDecorate6(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate6(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate6(this, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: (obj) => "uploadFile" in obj, get: (obj) => obj.uploadFile }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate6(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata)
        Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    #backendNodeId = __runInitializers6(this, _instanceExtraInitializers);
    constructor(world, remoteObject) {
      super(new CdpJSHandle(world, remoteObject));
    }
    get realm() {
      return this.handle.realm;
    }
    get client() {
      return this.handle.client;
    }
    remoteObject() {
      return this.handle.remoteObject();
    }
    get #frameManager() {
      return this.frame._frameManager;
    }
    get frame() {
      return this.realm.environment;
    }
    async contentFrame() {
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      if (typeof nodeInfo.node.frameId !== "string") {
        return null;
      }
      return this.#frameManager.frame(nodeInfo.node.frameId);
    }
    async scrollIntoView() {
      await this.assertConnectedElement();
      try {
        await this.client.send("DOM.scrollIntoViewIfNeeded", {
          objectId: this.id
        });
      } catch (error) {
        debugError(error);
        await super.scrollIntoView();
      }
    }
    async uploadFile(...files) {
      const isMultiple = await this.evaluate((element) => {
        return element.multiple;
      });
      assert(files.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
      const path = environment.value.path;
      if (path) {
        files = files.map((filePath) => {
          if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {
            return filePath;
          } else {
            return path.resolve(filePath);
          }
        });
      }
      if (files.length === 0) {
        await this.evaluate((element) => {
          element.files = new DataTransfer().files;
          element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
          element.dispatchEvent(new Event("change", { bubbles: true }));
        });
        return;
      }
      const { node: { backendNodeId } } = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      await this.client.send("DOM.setFileInputFiles", {
        objectId: this.id,
        files,
        backendNodeId
      });
    }
    async autofill(data) {
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: this.handle.id
      });
      const fieldId = nodeInfo.node.backendNodeId;
      const frameId = this.frame._id;
      await this.client.send("Autofill.trigger", {
        fieldId,
        frameId,
        card: data.creditCard
      });
    }
    async *queryAXTree(name, role) {
      const { nodes } = await this.client.send("Accessibility.queryAXTree", {
        objectId: this.id,
        accessibleName: name,
        role
      });
      const results = nodes.filter((node) => {
        if (node.ignored) {
          return false;
        }
        if (!node.role) {
          return false;
        }
        if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {
          return false;
        }
        return true;
      });
      return yield* AsyncIterableUtil.map(results, (node) => {
        return this.realm.adoptBackendNode(node.backendDOMNodeId);
      });
    }
    async backendNodeId() {
      if (this.#backendNodeId) {
        return this.#backendNodeId;
      }
      const { node } = await this.client.send("DOM.describeNode", {
        objectId: this.handle.id
      });
      this.#backendNodeId = node.backendNodeId;
      return this.#backendNodeId;
    }
  };
})();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js
var __addDisposableResource11 = function(env, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose, inner;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async2)
        inner = dispose;
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    if (inner)
      dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    env.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources11 = function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1)
            return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async)
              return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } else
            s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1)
        return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var ariaQuerySelectorBinding = new Binding("__ariaQuerySelector", ARIAQueryHandler.queryOne, "");
var ariaQuerySelectorAllBinding = new Binding("__ariaQuerySelectorAll", async (element, selector) => {
  const results = ARIAQueryHandler.queryAll(element, selector);
  return await element.realm.evaluateHandle((...elements) => {
    return elements;
  }, ...await AsyncIterableUtil.collect(results));
}, "");
var ExecutionContext = class extends EventEmitter {
  #client;
  #world;
  #id;
  #name;
  #disposables = new DisposableStack();
  constructor(client, contextPayload, world) {
    super();
    this.#client = client;
    this.#world = world;
    this.#id = contextPayload.id;
    if (contextPayload.name) {
      this.#name = contextPayload.name;
    }
    const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
    clientEmitter.on("Runtime.bindingCalled", this.#onBindingCalled.bind(this));
    clientEmitter.on("Runtime.executionContextDestroyed", async (event) => {
      if (event.executionContextId === this.#id) {
        this[disposeSymbol]();
      }
    });
    clientEmitter.on("Runtime.executionContextsCleared", async () => {
      this[disposeSymbol]();
    });
    clientEmitter.on("Runtime.consoleAPICalled", this.#onConsoleAPI.bind(this));
    clientEmitter.on(CDPSessionEvent.Disconnected, () => {
      this[disposeSymbol]();
    });
  }
  // Contains mapping from functions that should be bound to Puppeteer functions.
  #bindings = /* @__PURE__ */ new Map();
  // If multiple waitFor are set up asynchronously, we need to wait for the
  // first one to set up the binding in the page before running the others.
  #mutex = new Mutex();
  async #addBinding(binding) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      if (this.#bindings.has(binding.name)) {
        return;
      }
      const _ = __addDisposableResource11(env_1, await this.#mutex.acquire(), false);
      try {
        await this.#client.send("Runtime.addBinding", this.#name ? {
          name: CDP_BINDING_PREFIX + binding.name,
          executionContextName: this.#name
        } : {
          name: CDP_BINDING_PREFIX + binding.name,
          executionContextId: this.#id
        });
        await this.evaluate(addPageBinding, "internal", binding.name, CDP_BINDING_PREFIX);
        this.#bindings.set(binding.name, binding);
      } catch (error) {
        if (error instanceof Error) {
          if (error.message.includes("Execution context was destroyed")) {
            return;
          }
          if (error.message.includes("Cannot find context with specified id")) {
            return;
          }
        }
        debugError(error);
      }
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources11(env_1);
    }
  }
  async #onBindingCalled(event) {
    if (event.executionContextId !== this.#id) {
      return;
    }
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      return;
    }
    const { type, name, seq, args, isTrivial } = payload;
    if (type !== "internal") {
      this.emit("bindingcalled", event);
      return;
    }
    if (!this.#bindings.has(name)) {
      this.emit("bindingcalled", event);
      return;
    }
    try {
      const binding = this.#bindings.get(name);
      await binding?.run(this, seq, args, isTrivial);
    } catch (err) {
      debugError(err);
    }
  }
  get id() {
    return this.#id;
  }
  #onConsoleAPI(event) {
    if (event.executionContextId !== this.#id) {
      return;
    }
    this.emit("consoleapicalled", event);
  }
  #bindingsInstalled = false;
  #puppeteerUtil;
  get puppeteerUtil() {
    let promise = Promise.resolve();
    if (!this.#bindingsInstalled) {
      promise = Promise.all([
        this.#addBindingWithoutThrowing(ariaQuerySelectorBinding),
        this.#addBindingWithoutThrowing(ariaQuerySelectorAllBinding)
      ]);
      this.#bindingsInstalled = true;
    }
    scriptInjector.inject((script) => {
      if (this.#puppeteerUtil) {
        void this.#puppeteerUtil.then((handle) => {
          void handle.dispose();
        });
      }
      this.#puppeteerUtil = promise.then(() => {
        return this.evaluateHandle(script);
      });
    }, !this.#puppeteerUtil);
    return this.#puppeteerUtil;
  }
  async #addBindingWithoutThrowing(binding) {
    try {
      await this.#addBinding(binding);
    } catch (err) {
      debugError(err);
    }
  }
  /**
   * Evaluates the given function.
   *
   * @example
   *
   * ```ts
   * const executionContext = await page.mainFrame().executionContext();
   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
   * console.log(result); // prints "56"
   * ```
   *
   * @example
   * A string can also be passed in instead of a function:
   *
   * ```ts
   * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const oneHandle = await executionContext.evaluateHandle(() => 1);
   * const twoHandle = await executionContext.evaluateHandle(() => 2);
   * const result = await executionContext.evaluate(
   *   (a, b) => a + b,
   *   oneHandle,
   *   twoHandle,
   * );
   * await oneHandle.dispose();
   * await twoHandle.dispose();
   * console.log(result); // prints '3'.
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns The result of evaluating the function. If the result is an object,
   * a vanilla object containing the serializable properties of the result is
   * returned.
   */
  async evaluate(pageFunction, ...args) {
    return await this.#evaluate(true, pageFunction, ...args);
  }
  /**
   * Evaluates the given function.
   *
   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
   * handle to the result of the function.
   *
   * This method may be better suited if the object cannot be serialized (e.g.
   * `Map`) and requires further manipulation.
   *
   * @example
   *
   * ```ts
   * const context = await page.mainFrame().executionContext();
   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
   *   () => Promise.resolve(self),
   * );
   * ```
   *
   * @example
   * A string can also be passed in instead of a function.
   *
   * ```ts
   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const bodyHandle: ElementHandle<HTMLBodyElement> =
   *   await context.evaluateHandle(() => {
   *     return document.body;
   *   });
   * const stringHandle: JSHandle<string> = await context.evaluateHandle(
   *   body => body.innerHTML,
   *   body,
   * );
   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
   * // Always dispose your garbage! :)
   * await bodyHandle.dispose();
   * await stringHandle.dispose();
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns A {@link JSHandle | handle} to the result of evaluating the
   * function. If the result is a `Node`, then this will return an
   * {@link ElementHandle | element handle}.
   */
  async evaluateHandle(pageFunction, ...args) {
    return await this.#evaluate(false, pageFunction, ...args);
  }
  async #evaluate(returnByValue, pageFunction, ...args) {
    const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
    if (isString(pageFunction)) {
      const contextId = this.#id;
      const expression = pageFunction;
      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}
${sourceUrlComment}
`;
      const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this.#client.send("Runtime.evaluate", {
        expression: expressionWithSourceUrl,
        contextId,
        returnByValue,
        awaitPromise: true,
        userGesture: true
      }).catch(rewriteError2);
      if (exceptionDetails2) {
        throw createEvaluationError(exceptionDetails2);
      }
      return returnByValue ? valueFromRemoteObject(remoteObject2) : this.#world.createCdpHandle(remoteObject2);
    }
    const functionDeclaration = stringifyFunction(pageFunction);
    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
    let callFunctionOnPromise;
    try {
      callFunctionOnPromise = this.#client.send("Runtime.callFunctionOn", {
        functionDeclaration: functionDeclarationWithSourceUrl,
        executionContextId: this.#id,
        // LazyArgs are used only internally and should not affect the order
        // evaluate calls for the public APIs.
        arguments: args.some((arg) => {
          return arg instanceof LazyArg;
        }) ? await Promise.all(args.map((arg) => {
          return convertArgumentAsync(this, arg);
        })) : args.map((arg) => {
          return convertArgument(this, arg);
        }),
        returnByValue,
        awaitPromise: true,
        userGesture: true
      });
    } catch (error) {
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
        error.message += " Recursive objects are not allowed.";
      }
      throw error;
    }
    const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError2);
    if (exceptionDetails) {
      throw createEvaluationError(exceptionDetails);
    }
    return returnByValue ? valueFromRemoteObject(remoteObject) : this.#world.createCdpHandle(remoteObject);
    async function convertArgumentAsync(context2, arg) {
      if (arg instanceof LazyArg) {
        arg = await arg.get(context2);
      }
      return convertArgument(context2, arg);
    }
    function convertArgument(context2, arg) {
      if (typeof arg === "bigint") {
        return { unserializableValue: `${arg.toString()}n` };
      }
      if (Object.is(arg, -0)) {
        return { unserializableValue: "-0" };
      }
      if (Object.is(arg, Infinity)) {
        return { unserializableValue: "Infinity" };
      }
      if (Object.is(arg, -Infinity)) {
        return { unserializableValue: "-Infinity" };
      }
      if (Object.is(arg, NaN)) {
        return { unserializableValue: "NaN" };
      }
      const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;
      if (objectHandle) {
        if (objectHandle.realm !== context2.#world) {
          throw new Error("JSHandles can be evaluated only in the context they were created!");
        }
        if (objectHandle.disposed) {
          throw new Error("JSHandle is disposed!");
        }
        if (objectHandle.remoteObject().unserializableValue) {
          return {
            unserializableValue: objectHandle.remoteObject().unserializableValue
          };
        }
        if (!objectHandle.remoteObject().objectId) {
          return { value: objectHandle.remoteObject().value };
        }
        return { objectId: objectHandle.remoteObject().objectId };
      }
      return { value: arg };
    }
  }
  [disposeSymbol]() {
    this.#disposables.dispose();
    this.emit("disposed", void 0);
  }
};
var rewriteError2 = (error) => {
  if (error.message.includes("Object reference chain is too long")) {
    return { result: { type: "undefined" } };
  }
  if (error.message.includes("Object couldn't be returned by value")) {
    return { result: { type: "undefined" } };
  }
  if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  }
  throw error;
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Frame.js
init_Frame();
init_Errors();
init_util();
init_Deferred();
init_disposable();
init_ErrorLike();
init_Accessibility();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManagerEvents.js
var FrameManagerEvent;
(function(FrameManagerEvent2) {
  FrameManagerEvent2.FrameAttached = Symbol("FrameManager.FrameAttached");
  FrameManagerEvent2.FrameNavigated = Symbol("FrameManager.FrameNavigated");
  FrameManagerEvent2.FrameDetached = Symbol("FrameManager.FrameDetached");
  FrameManagerEvent2.FrameSwapped = Symbol("FrameManager.FrameSwapped");
  FrameManagerEvent2.LifecycleEvent = Symbol("FrameManager.LifecycleEvent");
  FrameManagerEvent2.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument");
  FrameManagerEvent2.ConsoleApiCalled = Symbol("FrameManager.ConsoleApiCalled");
  FrameManagerEvent2.BindingCalled = Symbol("FrameManager.BindingCalled");
})(FrameManagerEvent || (FrameManagerEvent = {}));

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorld.js
init_rxjs();
init_Realm();
init_EventEmitter();
init_util();
init_disposable();
var IsolatedWorld = class extends Realm {
  #context;
  #emitter = new EventEmitter();
  #frameOrWorker;
  constructor(frameOrWorker, timeoutSettings) {
    super(timeoutSettings);
    this.#frameOrWorker = frameOrWorker;
  }
  get environment() {
    return this.#frameOrWorker;
  }
  get client() {
    return this.#frameOrWorker.client;
  }
  get emitter() {
    return this.#emitter;
  }
  setContext(context2) {
    this.#context?.[disposeSymbol]();
    context2.once("disposed", this.#onContextDisposed.bind(this));
    context2.on("consoleapicalled", this.#onContextConsoleApiCalled.bind(this));
    context2.on("bindingcalled", this.#onContextBindingCalled.bind(this));
    this.#context = context2;
    this.#emitter.emit("context", context2);
    void this.taskManager.rerunAll();
  }
  #onContextDisposed() {
    this.#context = void 0;
    if ("clearDocumentHandle" in this.#frameOrWorker) {
      this.#frameOrWorker.clearDocumentHandle();
    }
  }
  #onContextConsoleApiCalled(event) {
    this.#emitter.emit("consoleapicalled", event);
  }
  #onContextBindingCalled(event) {
    this.#emitter.emit("bindingcalled", event);
  }
  hasContext() {
    return !!this.#context;
  }
  get context() {
    return this.#context;
  }
  #executionContext() {
    if (this.disposed) {
      throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
    }
    return this.#context;
  }
  /**
   * Waits for the next context to be set on the isolated world.
   */
  async #waitForExecutionContext() {
    const error = new Error("Execution context was destroyed");
    const result = await firstValueFrom(fromEmitterEvent(this.#emitter, "context").pipe(raceWith(fromEmitterEvent(this.#emitter, "disposed").pipe(map(() => {
      throw error;
    })), timeout(this.timeoutSettings.timeout()))));
    return result;
  }
  async evaluateHandle(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
    let context2 = this.#executionContext();
    if (!context2) {
      context2 = await this.#waitForExecutionContext();
    }
    return await context2.evaluateHandle(pageFunction, ...args);
  }
  async evaluate(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
    let context2 = this.#executionContext();
    if (!context2) {
      context2 = await this.#waitForExecutionContext();
    }
    return await context2.evaluate(pageFunction, ...args);
  }
  async adoptBackendNode(backendNodeId) {
    let context2 = this.#executionContext();
    if (!context2) {
      context2 = await this.#waitForExecutionContext();
    }
    const { object } = await this.client.send("DOM.resolveNode", {
      backendNodeId,
      executionContextId: context2.id
    });
    return this.createCdpHandle(object);
  }
  async adoptHandle(handle) {
    if (handle.realm === this) {
      return await handle.evaluateHandle((value) => {
        return value;
      });
    }
    const nodeInfo = await this.client.send("DOM.describeNode", {
      objectId: handle.id
    });
    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
  }
  async transferHandle(handle) {
    if (handle.realm === this) {
      return handle;
    }
    if (handle.remoteObject().objectId === void 0) {
      return handle;
    }
    const info = await this.client.send("DOM.describeNode", {
      objectId: handle.remoteObject().objectId
    });
    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
    await handle.dispose();
    return newHandle;
  }
  /**
   * @internal
   */
  createCdpHandle(remoteObject) {
    if (remoteObject.subtype === "node") {
      return new CdpElementHandle(this, remoteObject);
    }
    return new CdpJSHandle(this, remoteObject);
  }
  [disposeSymbol]() {
    this.#context?.[disposeSymbol]();
    this.#emitter.emit("disposed", void 0);
    super[disposeSymbol]();
    this.#emitter.removeAllListeners();
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorlds.js
var MAIN_WORLD = Symbol("mainWorld");
var PUPPETEER_WORLD = Symbol("puppeteerWorld");

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js
init_Frame();
init_EventEmitter();
init_assert();
init_Deferred();
init_disposable();
var puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
  ["load", "load"],
  ["domcontentloaded", "DOMContentLoaded"],
  ["networkidle0", "networkIdle"],
  ["networkidle2", "networkAlmostIdle"]
]);
var LifecycleWatcher = class {
  #expectedLifecycle;
  #frame;
  #timeout;
  #navigationRequest = null;
  #subscriptions = new DisposableStack();
  #initialLoaderId;
  #terminationDeferred;
  #sameDocumentNavigationDeferred = Deferred.create();
  #lifecycleDeferred = Deferred.create();
  #newDocumentNavigationDeferred = Deferred.create();
  #hasSameDocumentNavigation;
  #swapped;
  #navigationResponseReceived;
  constructor(networkManager, frame, waitUntil, timeout2, signal) {
    if (Array.isArray(waitUntil)) {
      waitUntil = waitUntil.slice();
    } else if (typeof waitUntil === "string") {
      waitUntil = [waitUntil];
    }
    this.#initialLoaderId = frame._loaderId;
    this.#expectedLifecycle = waitUntil.map((value) => {
      const protocolEvent = puppeteerToProtocolLifecycle.get(value);
      assert(protocolEvent, "Unknown value for options.waitUntil: " + value);
      return protocolEvent;
    });
    signal?.addEventListener("abort", () => {
      this.#terminationDeferred.reject(signal.reason);
    });
    this.#frame = frame;
    this.#timeout = timeout2;
    const frameManagerEmitter = this.#subscriptions.use(new EventEmitter(frame._frameManager));
    frameManagerEmitter.on(FrameManagerEvent.LifecycleEvent, this.#checkLifecycleComplete.bind(this));
    const frameEmitter = this.#subscriptions.use(new EventEmitter(frame));
    frameEmitter.on(FrameEvent.FrameNavigatedWithinDocument, this.#navigatedWithinDocument.bind(this));
    frameEmitter.on(FrameEvent.FrameNavigated, this.#navigated.bind(this));
    frameEmitter.on(FrameEvent.FrameSwapped, this.#frameSwapped.bind(this));
    frameEmitter.on(FrameEvent.FrameSwappedByActivation, this.#frameSwapped.bind(this));
    frameEmitter.on(FrameEvent.FrameDetached, this.#onFrameDetached.bind(this));
    const networkManagerEmitter = this.#subscriptions.use(new EventEmitter(networkManager));
    networkManagerEmitter.on(NetworkManagerEvent.Request, this.#onRequest.bind(this));
    networkManagerEmitter.on(NetworkManagerEvent.Response, this.#onResponse.bind(this));
    networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, this.#onRequestFailed.bind(this));
    this.#terminationDeferred = Deferred.create({
      timeout: this.#timeout,
      message: `Navigation timeout of ${this.#timeout} ms exceeded`
    });
    this.#checkLifecycleComplete();
  }
  #onRequest(request) {
    if (request.frame() !== this.#frame || !request.isNavigationRequest()) {
      return;
    }
    this.#navigationRequest = request;
    this.#navigationResponseReceived?.resolve();
    this.#navigationResponseReceived = Deferred.create();
    if (request.response() !== null) {
      this.#navigationResponseReceived?.resolve();
    }
  }
  #onRequestFailed(request) {
    if (this.#navigationRequest?.id !== request.id) {
      return;
    }
    this.#navigationResponseReceived?.resolve();
  }
  #onResponse(response) {
    if (this.#navigationRequest?.id !== response.request().id) {
      return;
    }
    this.#navigationResponseReceived?.resolve();
  }
  #onFrameDetached(frame) {
    if (this.#frame === frame) {
      this.#terminationDeferred.resolve(new Error("Navigating frame was detached"));
      return;
    }
    this.#checkLifecycleComplete();
  }
  async navigationResponse() {
    await this.#navigationResponseReceived?.valueOrThrow();
    return this.#navigationRequest ? this.#navigationRequest.response() : null;
  }
  sameDocumentNavigationPromise() {
    return this.#sameDocumentNavigationDeferred.valueOrThrow();
  }
  newDocumentNavigationPromise() {
    return this.#newDocumentNavigationDeferred.valueOrThrow();
  }
  lifecyclePromise() {
    return this.#lifecycleDeferred.valueOrThrow();
  }
  terminationPromise() {
    return this.#terminationDeferred.valueOrThrow();
  }
  #navigatedWithinDocument() {
    this.#hasSameDocumentNavigation = true;
    this.#checkLifecycleComplete();
  }
  #navigated(navigationType) {
    if (navigationType === "BackForwardCacheRestore") {
      return this.#frameSwapped();
    }
    this.#checkLifecycleComplete();
  }
  #frameSwapped() {
    this.#swapped = true;
    this.#checkLifecycleComplete();
  }
  #checkLifecycleComplete() {
    if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {
      return;
    }
    this.#lifecycleDeferred.resolve();
    if (this.#hasSameDocumentNavigation) {
      this.#sameDocumentNavigationDeferred.resolve(void 0);
    }
    if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {
      this.#newDocumentNavigationDeferred.resolve(void 0);
    }
    function checkLifecycle(frame, expectedLifecycle) {
      for (const event of expectedLifecycle) {
        if (!frame._lifecycleEvents.has(event)) {
          return false;
        }
      }
      for (const child of frame.childFrames()) {
        if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
          return false;
        }
      }
      return true;
    }
  }
  dispose() {
    this.#subscriptions.dispose();
    this.#terminationDeferred.resolve(new Error("LifecycleWatcher disposed"));
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Frame.js
var __runInitializers7 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var CdpFrame = (() => {
  let _classSuper = Frame;
  let _instanceExtraInitializers = [];
  let _goto_decorators;
  let _waitForNavigation_decorators;
  let _setContent_decorators;
  let _addPreloadScript_decorators;
  let _addExposedFunctionBinding_decorators;
  let _removeExposedFunctionBinding_decorators;
  let _waitForDevicePrompt_decorators;
  return class CdpFrame extends _classSuper {
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate7(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: (obj) => "addPreloadScript" in obj, get: (obj) => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _addExposedFunctionBinding_decorators, { kind: "method", name: "addExposedFunctionBinding", static: false, private: false, access: { has: (obj) => "addExposedFunctionBinding" in obj, get: (obj) => obj.addExposedFunctionBinding }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _removeExposedFunctionBinding_decorators, { kind: "method", name: "removeExposedFunctionBinding", static: false, private: false, access: { has: (obj) => "removeExposedFunctionBinding" in obj, get: (obj) => obj.removeExposedFunctionBinding }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: (obj) => "waitForDevicePrompt" in obj, get: (obj) => obj.waitForDevicePrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata)
        Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    #url = (__runInitializers7(this, _instanceExtraInitializers), "");
    #detached = false;
    #client;
    _frameManager;
    _loaderId = "";
    _lifecycleEvents = /* @__PURE__ */ new Set();
    _id;
    _parentId;
    accessibility;
    worlds;
    constructor(frameManager, frameId, parentFrameId, client) {
      super();
      this._frameManager = frameManager;
      this.#url = "";
      this._id = frameId;
      this._parentId = parentFrameId;
      this.#detached = false;
      this.#client = client;
      this._loaderId = "";
      this.worlds = {
        [MAIN_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
        [PUPPETEER_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings)
      };
      this.accessibility = new Accessibility(this.worlds[MAIN_WORLD], frameId);
      this.on(FrameEvent.FrameSwappedByActivation, () => {
        this._onLoadingStarted();
        this._onLoadingStopped();
      });
      this.worlds[MAIN_WORLD].emitter.on("consoleapicalled", this.#onMainWorldConsoleApiCalled.bind(this));
      this.worlds[MAIN_WORLD].emitter.on("bindingcalled", this.#onMainWorldBindingCalled.bind(this));
    }
    #onMainWorldConsoleApiCalled(event) {
      this._frameManager.emit(FrameManagerEvent.ConsoleApiCalled, [
        this.worlds[MAIN_WORLD],
        event
      ]);
    }
    #onMainWorldBindingCalled(event) {
      this._frameManager.emit(FrameManagerEvent.BindingCalled, [
        this.worlds[MAIN_WORLD],
        event
      ]);
    }
    /**
     * This is used internally in DevTools.
     *
     * @internal
     */
    _client() {
      return this.#client;
    }
    /**
     * Updates the frame ID with the new ID. This happens when the main frame is
     * replaced by a different frame.
     */
    updateId(id) {
      this._id = id;
    }
    updateClient(client) {
      this.#client = client;
    }
    page() {
      return this._frameManager.page();
    }
    async goto(url, options = {}) {
      const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      let ensureNewDocumentNavigation = false;
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
      let error = await Deferred.race([
        navigate(this.#client, url, referer, referrerPolicy, this._id),
        watcher.terminationPromise()
      ]);
      if (!error) {
        error = await Deferred.race([
          watcher.terminationPromise(),
          ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
        ]);
      }
      try {
        if (error) {
          throw error;
        }
        return await watcher.navigationResponse();
      } finally {
        watcher.dispose();
      }
      async function navigate(client, url2, referrer, referrerPolicy2, frameId) {
        try {
          const response = await client.send("Page.navigate", {
            url: url2,
            referrer,
            frameId,
            referrerPolicy: referrerPolicy2
          });
          ensureNewDocumentNavigation = !!response.loaderId;
          if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
            return null;
          }
          return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
        } catch (error2) {
          if (isErrorLike(error2)) {
            return error2;
          }
          throw error2;
        }
      }
    }
    async waitForNavigation(options = {}) {
      const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout(), signal } = options;
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2, signal);
      const error = await Deferred.race([
        watcher.terminationPromise(),
        ...options.ignoreSameDocumentNavigation ? [] : [watcher.sameDocumentNavigationPromise()],
        watcher.newDocumentNavigationPromise()
      ]);
      try {
        if (error) {
          throw error;
        }
        const result = await Deferred.race([watcher.terminationPromise(), watcher.navigationResponse()]);
        if (result instanceof Error) {
          throw error;
        }
        return result || null;
      } finally {
        watcher.dispose();
      }
    }
    get client() {
      return this.#client;
    }
    mainRealm() {
      return this.worlds[MAIN_WORLD];
    }
    isolatedRealm() {
      return this.worlds[PUPPETEER_WORLD];
    }
    async setContent(html, options = {}) {
      const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      await this.setFrameContent(html);
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
      const error = await Deferred.race([
        watcher.terminationPromise(),
        watcher.lifecyclePromise()
      ]);
      watcher.dispose();
      if (error) {
        throw error;
      }
    }
    url() {
      return this.#url;
    }
    parentFrame() {
      return this._frameManager._frameTree.parentFrame(this._id) || null;
    }
    childFrames() {
      return this._frameManager._frameTree.childFrames(this._id);
    }
    #deviceRequestPromptManager() {
      return this._frameManager._deviceRequestPromptManager(this.#client);
    }
    async addPreloadScript(preloadScript) {
      const parentFrame = this.parentFrame();
      if (parentFrame && this.#client === parentFrame.client) {
        return;
      }
      if (preloadScript.getIdForFrame(this)) {
        return;
      }
      const { identifier } = await this.#client.send("Page.addScriptToEvaluateOnNewDocument", {
        source: preloadScript.source
      });
      preloadScript.setIdForFrame(this, identifier);
    }
    async addExposedFunctionBinding(binding) {
      if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
        return;
      }
      await Promise.all([
        this.#client.send("Runtime.addBinding", {
          name: CDP_BINDING_PREFIX + binding.name
        }),
        this.evaluate(binding.initSource).catch(debugError)
      ]);
    }
    async removeExposedFunctionBinding(binding) {
      if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
        return;
      }
      await Promise.all([
        this.#client.send("Runtime.removeBinding", {
          name: CDP_BINDING_PREFIX + binding.name
        }),
        this.evaluate((name) => {
          globalThis[name] = void 0;
        }, binding.name).catch(debugError)
      ]);
    }
    async waitForDevicePrompt(options = {}) {
      return await this.#deviceRequestPromptManager().waitForDevicePrompt(options);
    }
    _navigated(framePayload) {
      this._name = framePayload.name;
      this.#url = `${framePayload.url}${framePayload.urlFragment || ""}`;
    }
    _navigatedWithinDocument(url) {
      this.#url = url;
    }
    _onLifecycleEvent(loaderId, name) {
      if (name === "init") {
        this._loaderId = loaderId;
        this._lifecycleEvents.clear();
      }
      this._lifecycleEvents.add(name);
    }
    _onLoadingStopped() {
      this._lifecycleEvents.add("DOMContentLoaded");
      this._lifecycleEvents.add("load");
    }
    _onLoadingStarted() {
      this._hasStartedLoading = true;
    }
    get detached() {
      return this.#detached;
    }
    [(_goto_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _addPreloadScript_decorators = [throwIfDetached], _addExposedFunctionBinding_decorators = [throwIfDetached], _removeExposedFunctionBinding_decorators = [throwIfDetached], _waitForDevicePrompt_decorators = [throwIfDetached], disposeSymbol)]() {
      if (this.#detached) {
        return;
      }
      this.#detached = true;
      this.worlds[MAIN_WORLD][disposeSymbol]();
      this.worlds[PUPPETEER_WORLD][disposeSymbol]();
    }
    exposeFunction() {
      throw new UnsupportedOperation();
    }
    async frameElement() {
      const parent = this.parentFrame();
      if (!parent) {
        return null;
      }
      const { backendNodeId } = await parent.client.send("DOM.getFrameOwner", {
        frameId: this._id
      });
      return await parent.mainRealm().adoptBackendNode(backendNodeId);
    }
  };
})();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameTree.js
init_Deferred();
var FrameTree = class {
  #frames = /* @__PURE__ */ new Map();
  // frameID -> parentFrameID
  #parentIds = /* @__PURE__ */ new Map();
  // frameID -> childFrameIDs
  #childIds = /* @__PURE__ */ new Map();
  #mainFrame;
  #isMainFrameStale = false;
  #waitRequests = /* @__PURE__ */ new Map();
  getMainFrame() {
    return this.#mainFrame;
  }
  getById(frameId) {
    return this.#frames.get(frameId);
  }
  /**
   * Returns a promise that is resolved once the frame with
   * the given ID is added to the tree.
   */
  waitForFrame(frameId) {
    const frame = this.getById(frameId);
    if (frame) {
      return Promise.resolve(frame);
    }
    const deferred = Deferred.create();
    const callbacks = this.#waitRequests.get(frameId) || /* @__PURE__ */ new Set();
    callbacks.add(deferred);
    return deferred.valueOrThrow();
  }
  frames() {
    return Array.from(this.#frames.values());
  }
  addFrame(frame) {
    this.#frames.set(frame._id, frame);
    if (frame._parentId) {
      this.#parentIds.set(frame._id, frame._parentId);
      if (!this.#childIds.has(frame._parentId)) {
        this.#childIds.set(frame._parentId, /* @__PURE__ */ new Set());
      }
      this.#childIds.get(frame._parentId).add(frame._id);
    } else if (!this.#mainFrame || this.#isMainFrameStale) {
      this.#mainFrame = frame;
      this.#isMainFrameStale = false;
    }
    this.#waitRequests.get(frame._id)?.forEach((request) => {
      return request.resolve(frame);
    });
  }
  removeFrame(frame) {
    this.#frames.delete(frame._id);
    this.#parentIds.delete(frame._id);
    if (frame._parentId) {
      this.#childIds.get(frame._parentId)?.delete(frame._id);
    } else {
      this.#isMainFrameStale = true;
    }
  }
  childFrames(frameId) {
    const childIds = this.#childIds.get(frameId);
    if (!childIds) {
      return [];
    }
    return Array.from(childIds).map((id) => {
      return this.getById(id);
    }).filter((frame) => {
      return frame !== void 0;
    });
  }
  parentFrame(frameId) {
    const parentId = this.#parentIds.get(frameId);
    return parentId ? this.getById(parentId) : void 0;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js
init_CDPSession();
init_EventEmitter();
init_util();
init_assert();
init_disposable();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPRequest.js
init_HTTPRequest();
init_util();
init_encoding();
var CdpHTTPRequest = class extends HTTPRequest {
  id;
  #client;
  #isNavigationRequest;
  #url;
  #resourceType;
  #method;
  #hasPostData = false;
  #postData;
  #headers = {};
  #frame;
  #initiator;
  get client() {
    return this.#client;
  }
  set client(newClient) {
    this.#client = newClient;
  }
  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
    super();
    this.#client = client;
    this.id = data.requestId;
    this.#isNavigationRequest = data.requestId === data.loaderId && data.type === "Document";
    this._interceptionId = interceptionId;
    this.#url = data.request.url + (data.request.urlFragment ?? "");
    this.#resourceType = (data.type || "other").toLowerCase();
    this.#method = data.request.method;
    this.#postData = data.request.postData;
    this.#hasPostData = data.request.hasPostData ?? false;
    this.#frame = frame;
    this._redirectChain = redirectChain;
    this.#initiator = data.initiator;
    this.interception.enabled = allowInterception;
    for (const [key, value] of Object.entries(data.request.headers)) {
      this.#headers[key.toLowerCase()] = value;
    }
  }
  url() {
    return this.#url;
  }
  resourceType() {
    return this.#resourceType;
  }
  method() {
    return this.#method;
  }
  postData() {
    return this.#postData;
  }
  hasPostData() {
    return this.#hasPostData;
  }
  async fetchPostData() {
    try {
      const result = await this.#client.send("Network.getRequestPostData", {
        requestId: this.id
      });
      return result.postData;
    } catch (err) {
      debugError(err);
      return;
    }
  }
  headers() {
    return this.#headers;
  }
  response() {
    return this._response;
  }
  frame() {
    return this.#frame;
  }
  isNavigationRequest() {
    return this.#isNavigationRequest;
  }
  initiator() {
    return this.#initiator;
  }
  redirectChain() {
    return this._redirectChain.slice();
  }
  failure() {
    if (!this._failureText) {
      return null;
    }
    return {
      errorText: this._failureText
    };
  }
  /**
   * @internal
   */
  async _continue(overrides = {}) {
    const { url, method, postData, headers } = overrides;
    this.interception.handled = true;
    const postDataBinaryBase64 = postData ? stringToBase64(postData) : void 0;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
    }
    await this.#client.send("Fetch.continueRequest", {
      requestId: this._interceptionId,
      url,
      method,
      postData: postDataBinaryBase64,
      headers: headers ? headersArray(headers) : void 0
    }).catch((error) => {
      this.interception.handled = false;
      return handleError(error);
    });
  }
  async _respond(response) {
    this.interception.handled = true;
    let parsedBody;
    if (response.body) {
      parsedBody = HTTPRequest.getResponse(response.body);
    }
    const responseHeaders = {};
    if (response.headers) {
      for (const header of Object.keys(response.headers)) {
        const value = response.headers[header];
        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
          return String(item);
        }) : String(value);
      }
    }
    if (response.contentType) {
      responseHeaders["content-type"] = response.contentType;
    }
    if (parsedBody?.contentLength && !("content-length" in responseHeaders)) {
      responseHeaders["content-length"] = String(parsedBody.contentLength);
    }
    const status = response.status || 200;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
    }
    await this.#client.send("Fetch.fulfillRequest", {
      requestId: this._interceptionId,
      responseCode: status,
      responsePhrase: STATUS_TEXTS[status],
      responseHeaders: headersArray(responseHeaders),
      body: parsedBody?.base64
    }).catch((error) => {
      this.interception.handled = false;
      return handleError(error);
    });
  }
  async _abort(errorReason) {
    this.interception.handled = true;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
    }
    await this.#client.send("Fetch.failRequest", {
      requestId: this._interceptionId,
      errorReason: errorReason || "Failed"
    }).catch(handleError);
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPResponse.js
init_HTTPResponse();
init_Errors();
init_SecurityDetails();
init_Deferred();
init_encoding();
var CdpHTTPResponse = class extends HTTPResponse {
  #request;
  #contentPromise = null;
  #bodyLoadedDeferred = Deferred.create();
  #remoteAddress;
  #status;
  #statusText;
  #fromDiskCache;
  #fromServiceWorker;
  #headers = {};
  #securityDetails;
  #timing;
  constructor(request, responsePayload, extraInfo) {
    super();
    this.#request = request;
    this.#remoteAddress = {
      ip: responsePayload.remoteIPAddress,
      port: responsePayload.remotePort
    };
    this.#statusText = this.#parseStatusTextFromExtraInfo(extraInfo) || responsePayload.statusText;
    this.#fromDiskCache = !!responsePayload.fromDiskCache;
    this.#fromServiceWorker = !!responsePayload.fromServiceWorker;
    this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;
    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
    for (const [key, value] of Object.entries(headers)) {
      this.#headers[key.toLowerCase()] = value;
    }
    this.#securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
    this.#timing = responsePayload.timing || null;
  }
  #parseStatusTextFromExtraInfo(extraInfo) {
    if (!extraInfo || !extraInfo.headersText) {
      return;
    }
    const firstLine = extraInfo.headersText.split("\r", 1)[0];
    if (!firstLine || firstLine.length > 1e3) {
      return;
    }
    const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
    if (!match) {
      return;
    }
    const statusText = match[1];
    if (!statusText) {
      return;
    }
    return statusText;
  }
  _resolveBody(err) {
    if (err) {
      return this.#bodyLoadedDeferred.reject(err);
    }
    return this.#bodyLoadedDeferred.resolve();
  }
  remoteAddress() {
    return this.#remoteAddress;
  }
  url() {
    return this.#request.url();
  }
  status() {
    return this.#status;
  }
  statusText() {
    return this.#statusText;
  }
  headers() {
    return this.#headers;
  }
  securityDetails() {
    return this.#securityDetails;
  }
  timing() {
    return this.#timing;
  }
  content() {
    if (!this.#contentPromise) {
      this.#contentPromise = this.#bodyLoadedDeferred.valueOrThrow().then(async () => {
        try {
          const response = await this.#request.client.send("Network.getResponseBody", {
            requestId: this.#request.id
          });
          return stringToTypedArray(response.body, response.base64Encoded);
        } catch (error) {
          if (error instanceof ProtocolError && error.originalMessage === "No resource with given identifier found") {
            throw new ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
          }
          throw error;
        }
      });
    }
    return this.#contentPromise;
  }
  request() {
    return this.#request;
  }
  fromCache() {
    return this.#fromDiskCache || this.#request._fromMemoryCache;
  }
  fromServiceWorker() {
    return this.#fromServiceWorker;
  }
  frame() {
    return this.#request.frame();
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkEventManager.js
var NetworkEventManager = class {
  /**
   * There are four possible orders of events:
   * A. `_onRequestWillBeSent`
   * B. `_onRequestWillBeSent`, `_onRequestPaused`
   * C. `_onRequestPaused`, `_onRequestWillBeSent`
   * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
   * (see crbug.com/1196004)
   *
   * For `_onRequest` we need the event from `_onRequestWillBeSent` and
   * optionally the `interceptionId` from `_onRequestPaused`.
   *
   * If request interception is disabled, call `_onRequest` once per call to
   * `_onRequestWillBeSent`.
   * If request interception is enabled, call `_onRequest` once per call to
   * `_onRequestPaused` (once per `interceptionId`).
   *
   * Events are stored to allow for subsequent events to call `_onRequest`.
   *
   * Note that (chains of) redirect requests have the same `requestId` (!) as
   * the original request. We have to anticipate series of events like these:
   * A. `_onRequestWillBeSent`,
   * `_onRequestWillBeSent`, ...
   * B. `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestWillBeSent`, `_onRequestPaused`, ...
   * C. `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestPaused`, `_onRequestWillBeSent`, ...
   * D. `_onRequestPaused`, `_onRequestWillBeSent`,
   * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
   * (see crbug.com/1196004)
   */
  #requestWillBeSentMap = /* @__PURE__ */ new Map();
  #requestPausedMap = /* @__PURE__ */ new Map();
  #httpRequestsMap = /* @__PURE__ */ new Map();
  /*
   * The below maps are used to reconcile Network.responseReceivedExtraInfo
   * events with their corresponding request. Each response and redirect
   * response gets an ExtraInfo event, and we don't know which will come first.
   * This means that we have to store a Response or an ExtraInfo for each
   * response, and emit the event when we get both of them. In addition, to
   * handle redirects, we have to make them Arrays to represent the chain of
   * events.
   */
  #responseReceivedExtraInfoMap = /* @__PURE__ */ new Map();
  #queuedRedirectInfoMap = /* @__PURE__ */ new Map();
  #queuedEventGroupMap = /* @__PURE__ */ new Map();
  forget(networkRequestId) {
    this.#requestWillBeSentMap.delete(networkRequestId);
    this.#requestPausedMap.delete(networkRequestId);
    this.#queuedEventGroupMap.delete(networkRequestId);
    this.#queuedRedirectInfoMap.delete(networkRequestId);
    this.#responseReceivedExtraInfoMap.delete(networkRequestId);
  }
  responseExtraInfo(networkRequestId) {
    if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {
      this.#responseReceivedExtraInfoMap.set(networkRequestId, []);
    }
    return this.#responseReceivedExtraInfoMap.get(networkRequestId);
  }
  queuedRedirectInfo(fetchRequestId) {
    if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {
      this.#queuedRedirectInfoMap.set(fetchRequestId, []);
    }
    return this.#queuedRedirectInfoMap.get(fetchRequestId);
  }
  queueRedirectInfo(fetchRequestId, redirectInfo) {
    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
  }
  takeQueuedRedirectInfo(fetchRequestId) {
    return this.queuedRedirectInfo(fetchRequestId).shift();
  }
  inFlightRequestsCount() {
    let inFlightRequestCounter = 0;
    for (const request of this.#httpRequestsMap.values()) {
      if (!request.response()) {
        inFlightRequestCounter++;
      }
    }
    return inFlightRequestCounter;
  }
  storeRequestWillBeSent(networkRequestId, event) {
    this.#requestWillBeSentMap.set(networkRequestId, event);
  }
  getRequestWillBeSent(networkRequestId) {
    return this.#requestWillBeSentMap.get(networkRequestId);
  }
  forgetRequestWillBeSent(networkRequestId) {
    this.#requestWillBeSentMap.delete(networkRequestId);
  }
  getRequestPaused(networkRequestId) {
    return this.#requestPausedMap.get(networkRequestId);
  }
  forgetRequestPaused(networkRequestId) {
    this.#requestPausedMap.delete(networkRequestId);
  }
  storeRequestPaused(networkRequestId, event) {
    this.#requestPausedMap.set(networkRequestId, event);
  }
  getRequest(networkRequestId) {
    return this.#httpRequestsMap.get(networkRequestId);
  }
  storeRequest(networkRequestId, request) {
    this.#httpRequestsMap.set(networkRequestId, request);
  }
  forgetRequest(networkRequestId) {
    this.#httpRequestsMap.delete(networkRequestId);
  }
  getQueuedEventGroup(networkRequestId) {
    return this.#queuedEventGroupMap.get(networkRequestId);
  }
  queueEventGroup(networkRequestId, event) {
    this.#queuedEventGroupMap.set(networkRequestId, event);
  }
  forgetQueuedEventGroup(networkRequestId) {
    this.#queuedEventGroupMap.delete(networkRequestId);
  }
  printState() {
    function replacer(_key, value) {
      if (value instanceof Map) {
        return {
          dataType: "Map",
          value: Array.from(value.entries())
          // or with spread: value: [...value]
        };
      } else if (value instanceof CdpHTTPRequest) {
        return {
          dataType: "CdpHTTPRequest",
          value: `${value.id}: ${value.url()}`
        };
      }
      {
        return value;
      }
    }
    console.log("httpRequestsMap", JSON.stringify(this.#httpRequestsMap, replacer, 2));
    console.log("requestWillBeSentMap", JSON.stringify(this.#requestWillBeSentMap, replacer, 2));
    console.log("requestWillBeSentMap", JSON.stringify(this.#responseReceivedExtraInfoMap, replacer, 2));
    console.log("requestWillBeSentMap", JSON.stringify(this.#requestPausedMap, replacer, 2));
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js
var NetworkManager = class extends EventEmitter {
  #frameManager;
  #networkEventManager = new NetworkEventManager();
  #extraHTTPHeaders;
  #credentials = null;
  #attemptedAuthentications = /* @__PURE__ */ new Set();
  #userRequestInterceptionEnabled = false;
  #protocolRequestInterceptionEnabled = false;
  #userCacheDisabled;
  #emulatedNetworkConditions;
  #userAgent;
  #userAgentMetadata;
  #handlers = [
    ["Fetch.requestPaused", this.#onRequestPaused],
    ["Fetch.authRequired", this.#onAuthRequired],
    ["Network.requestWillBeSent", this.#onRequestWillBeSent],
    ["Network.requestServedFromCache", this.#onRequestServedFromCache],
    ["Network.responseReceived", this.#onResponseReceived],
    ["Network.loadingFinished", this.#onLoadingFinished],
    ["Network.loadingFailed", this.#onLoadingFailed],
    ["Network.responseReceivedExtraInfo", this.#onResponseReceivedExtraInfo],
    [CDPSessionEvent.Disconnected, this.#removeClient]
  ];
  #clients = /* @__PURE__ */ new Map();
  constructor(frameManager) {
    super();
    this.#frameManager = frameManager;
  }
  async addClient(client) {
    if (this.#clients.has(client)) {
      return;
    }
    const subscriptions = new DisposableStack();
    this.#clients.set(client, subscriptions);
    const clientEmitter = subscriptions.use(new EventEmitter(client));
    for (const [event, handler] of this.#handlers) {
      clientEmitter.on(event, (arg) => {
        return handler.bind(this)(client, arg);
      });
    }
    await Promise.all([
      client.send("Network.enable"),
      this.#applyExtraHTTPHeaders(client),
      this.#applyNetworkConditions(client),
      this.#applyProtocolCacheDisabled(client),
      this.#applyProtocolRequestInterception(client),
      this.#applyUserAgent(client)
    ]);
  }
  async #removeClient(client) {
    this.#clients.get(client)?.dispose();
    this.#clients.delete(client);
  }
  async authenticate(credentials) {
    this.#credentials = credentials;
    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
    if (enabled === this.#protocolRequestInterceptionEnabled) {
      return;
    }
    this.#protocolRequestInterceptionEnabled = enabled;
    await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
  }
  async setExtraHTTPHeaders(headers) {
    const extraHTTPHeaders = {};
    for (const [key, value] of Object.entries(headers)) {
      assert(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      extraHTTPHeaders[key.toLowerCase()] = value;
    }
    this.#extraHTTPHeaders = extraHTTPHeaders;
    await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));
  }
  async #applyExtraHTTPHeaders(client) {
    if (this.#extraHTTPHeaders === void 0) {
      return;
    }
    await client.send("Network.setExtraHTTPHeaders", {
      headers: this.#extraHTTPHeaders
    });
  }
  extraHTTPHeaders() {
    return Object.assign({}, this.#extraHTTPHeaders);
  }
  inFlightRequestsCount() {
    return this.#networkEventManager.inFlightRequestsCount();
  }
  async setOfflineMode(value) {
    if (!this.#emulatedNetworkConditions) {
      this.#emulatedNetworkConditions = {
        offline: false,
        upload: -1,
        download: -1,
        latency: 0
      };
    }
    this.#emulatedNetworkConditions.offline = value;
    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
  }
  async emulateNetworkConditions(networkConditions) {
    if (!this.#emulatedNetworkConditions) {
      this.#emulatedNetworkConditions = {
        offline: false,
        upload: -1,
        download: -1,
        latency: 0
      };
    }
    this.#emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;
    this.#emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;
    this.#emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;
    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
  }
  async #applyToAllClients(fn) {
    await Promise.all(Array.from(this.#clients.keys()).map((client) => {
      return fn(client);
    }));
  }
  async #applyNetworkConditions(client) {
    if (this.#emulatedNetworkConditions === void 0) {
      return;
    }
    await client.send("Network.emulateNetworkConditions", {
      offline: this.#emulatedNetworkConditions.offline,
      latency: this.#emulatedNetworkConditions.latency,
      uploadThroughput: this.#emulatedNetworkConditions.upload,
      downloadThroughput: this.#emulatedNetworkConditions.download
    });
  }
  async setUserAgent(userAgent, userAgentMetadata) {
    this.#userAgent = userAgent;
    this.#userAgentMetadata = userAgentMetadata;
    await this.#applyToAllClients(this.#applyUserAgent.bind(this));
  }
  async #applyUserAgent(client) {
    if (this.#userAgent === void 0) {
      return;
    }
    await client.send("Network.setUserAgentOverride", {
      userAgent: this.#userAgent,
      userAgentMetadata: this.#userAgentMetadata
    });
  }
  async setCacheEnabled(enabled) {
    this.#userCacheDisabled = !enabled;
    await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));
  }
  async setRequestInterception(value) {
    this.#userRequestInterceptionEnabled = value;
    const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
    if (enabled === this.#protocolRequestInterceptionEnabled) {
      return;
    }
    this.#protocolRequestInterceptionEnabled = enabled;
    await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
  }
  async #applyProtocolRequestInterception(client) {
    if (this.#userCacheDisabled === void 0) {
      this.#userCacheDisabled = false;
    }
    if (this.#protocolRequestInterceptionEnabled) {
      await Promise.all([
        this.#applyProtocolCacheDisabled(client),
        client.send("Fetch.enable", {
          handleAuthRequests: true,
          patterns: [{ urlPattern: "*" }]
        })
      ]);
    } else {
      await Promise.all([
        this.#applyProtocolCacheDisabled(client),
        client.send("Fetch.disable")
      ]);
    }
  }
  async #applyProtocolCacheDisabled(client) {
    if (this.#userCacheDisabled === void 0) {
      return;
    }
    await client.send("Network.setCacheDisabled", {
      cacheDisabled: this.#userCacheDisabled
    });
  }
  #onRequestWillBeSent(client, event) {
    if (this.#userRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
      const { requestId: networkRequestId } = event;
      this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);
      const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);
      if (requestPausedEvent) {
        const { requestId: fetchRequestId } = requestPausedEvent;
        this.#patchRequestEventHeaders(event, requestPausedEvent);
        this.#onRequest(client, event, fetchRequestId);
        this.#networkEventManager.forgetRequestPaused(networkRequestId);
      }
      return;
    }
    this.#onRequest(client, event, void 0);
  }
  #onAuthRequired(client, event) {
    let response = "Default";
    if (this.#attemptedAuthentications.has(event.requestId)) {
      response = "CancelAuth";
    } else if (this.#credentials) {
      response = "ProvideCredentials";
      this.#attemptedAuthentications.add(event.requestId);
    }
    const { username, password } = this.#credentials || {
      username: void 0,
      password: void 0
    };
    client.send("Fetch.continueWithAuth", {
      requestId: event.requestId,
      authChallengeResponse: { response, username, password }
    }).catch(debugError);
  }
  /**
   * CDP may send a Fetch.requestPaused without or before a
   * Network.requestWillBeSent
   *
   * CDP may send multiple Fetch.requestPaused
   * for the same Network.requestWillBeSent.
   */
  #onRequestPaused(client, event) {
    if (!this.#userRequestInterceptionEnabled && this.#protocolRequestInterceptionEnabled) {
      client.send("Fetch.continueRequest", {
        requestId: event.requestId
      }).catch(debugError);
    }
    const { networkId: networkRequestId, requestId: fetchRequestId } = event;
    if (!networkRequestId) {
      this.#onRequestWithoutNetworkInstrumentation(client, event);
      return;
    }
    const requestWillBeSentEvent = (() => {
      const requestWillBeSentEvent2 = this.#networkEventManager.getRequestWillBeSent(networkRequestId);
      if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
        this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);
        return;
      }
      return requestWillBeSentEvent2;
    })();
    if (requestWillBeSentEvent) {
      this.#patchRequestEventHeaders(requestWillBeSentEvent, event);
      this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);
    } else {
      this.#networkEventManager.storeRequestPaused(networkRequestId, event);
    }
  }
  #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
    requestWillBeSentEvent.request.headers = {
      ...requestWillBeSentEvent.request.headers,
      // includes extra headers, like: Accept, Origin
      ...requestPausedEvent.request.headers
    };
  }
  #onRequestWithoutNetworkInstrumentation(client, event) {
    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
    const request = new CdpHTTPRequest(client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);
    this.emit(NetworkManagerEvent.Request, request);
    void request.finalizeInterceptions();
  }
  #onRequest(client, event, fetchRequestId, fromMemoryCache = false) {
    let redirectChain = [];
    if (event.redirectResponse) {
      let redirectResponseExtraInfo = null;
      if (event.redirectHasExtraInfo) {
        redirectResponseExtraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
        if (!redirectResponseExtraInfo) {
          this.#networkEventManager.queueRedirectInfo(event.requestId, {
            event,
            fetchRequestId
          });
          return;
        }
      }
      const request2 = this.#networkEventManager.getRequest(event.requestId);
      if (request2) {
        this.#handleRequestRedirect(client, request2, event.redirectResponse, redirectResponseExtraInfo);
        redirectChain = request2._redirectChain;
      }
    }
    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
    const request = new CdpHTTPRequest(client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);
    request._fromMemoryCache = fromMemoryCache;
    this.#networkEventManager.storeRequest(event.requestId, request);
    this.emit(NetworkManagerEvent.Request, request);
    void request.finalizeInterceptions();
  }
  #onRequestServedFromCache(client, event) {
    const requestWillBeSentEvent = this.#networkEventManager.getRequestWillBeSent(event.requestId);
    let request = this.#networkEventManager.getRequest(event.requestId);
    if (request) {
      request._fromMemoryCache = true;
    }
    if (!request && requestWillBeSentEvent) {
      this.#onRequest(client, requestWillBeSentEvent, void 0, true);
      request = this.#networkEventManager.getRequest(event.requestId);
    }
    if (!request) {
      debugError(new Error(`Request ${event.requestId} was served from cache but we could not find the corresponding request object`));
      return;
    }
    this.emit(NetworkManagerEvent.RequestServedFromCache, request);
  }
  #handleRequestRedirect(_client, request, responsePayload, extraInfo) {
    const response = new CdpHTTPResponse(request, responsePayload, extraInfo);
    request._response = response;
    request._redirectChain.push(request);
    response._resolveBody(new Error("Response body is unavailable for redirect responses"));
    this.#forgetRequest(request, false);
    this.emit(NetworkManagerEvent.Response, response);
    this.emit(NetworkManagerEvent.RequestFinished, request);
  }
  #emitResponseEvent(_client, responseReceived, extraInfo) {
    const request = this.#networkEventManager.getRequest(responseReceived.requestId);
    if (!request) {
      return;
    }
    const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);
    if (extraInfos.length) {
      debugError(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
    }
    if (responseReceived.response.fromDiskCache) {
      extraInfo = null;
    }
    const response = new CdpHTTPResponse(request, responseReceived.response, extraInfo);
    request._response = response;
    this.emit(NetworkManagerEvent.Response, response);
  }
  #onResponseReceived(client, event) {
    const request = this.#networkEventManager.getRequest(event.requestId);
    let extraInfo = null;
    if (request && !request._fromMemoryCache && event.hasExtraInfo) {
      extraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
      if (!extraInfo) {
        this.#networkEventManager.queueEventGroup(event.requestId, {
          responseReceivedEvent: event
        });
        return;
      }
    }
    this.#emitResponseEvent(client, event, extraInfo);
  }
  #onResponseReceivedExtraInfo(client, event) {
    const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);
    if (redirectInfo) {
      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
      this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);
      return;
    }
    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      this.#networkEventManager.forgetQueuedEventGroup(event.requestId);
      this.#emitResponseEvent(client, queuedEvents.responseReceivedEvent, event);
      if (queuedEvents.loadingFinishedEvent) {
        this.#emitLoadingFinished(client, queuedEvents.loadingFinishedEvent);
      }
      if (queuedEvents.loadingFailedEvent) {
        this.#emitLoadingFailed(client, queuedEvents.loadingFailedEvent);
      }
      return;
    }
    this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
  }
  #forgetRequest(request, events) {
    const requestId = request.id;
    const interceptionId = request._interceptionId;
    this.#networkEventManager.forgetRequest(requestId);
    if (interceptionId !== void 0) {
      this.#attemptedAuthentications.delete(interceptionId);
    }
    if (events) {
      this.#networkEventManager.forget(requestId);
    }
  }
  #onLoadingFinished(client, event) {
    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFinishedEvent = event;
    } else {
      this.#emitLoadingFinished(client, event);
    }
  }
  #emitLoadingFinished(client, event) {
    const request = this.#networkEventManager.getRequest(event.requestId);
    if (!request) {
      return;
    }
    this.#maybeReassignOOPIFRequestClient(client, request);
    if (request.response()) {
      request.response()?._resolveBody();
    }
    this.#forgetRequest(request, true);
    this.emit(NetworkManagerEvent.RequestFinished, request);
  }
  #onLoadingFailed(client, event) {
    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFailedEvent = event;
    } else {
      this.#emitLoadingFailed(client, event);
    }
  }
  #emitLoadingFailed(client, event) {
    const request = this.#networkEventManager.getRequest(event.requestId);
    if (!request) {
      return;
    }
    this.#maybeReassignOOPIFRequestClient(client, request);
    request._failureText = event.errorText;
    const response = request.response();
    if (response) {
      response._resolveBody();
    }
    this.#forgetRequest(request, true);
    this.emit(NetworkManagerEvent.RequestFailed, request);
  }
  #maybeReassignOOPIFRequestClient(client, request) {
    if (client !== request.client && request.isNavigationRequest()) {
      request.client = client;
    }
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
var TIME_FOR_WAITING_FOR_SWAP = 100;
var FrameManager = class extends EventEmitter {
  #page;
  #networkManager;
  #timeoutSettings;
  #isolatedWorlds = /* @__PURE__ */ new Set();
  #client;
  #scriptsToEvaluateOnNewDocument = /* @__PURE__ */ new Map();
  #bindings = /* @__PURE__ */ new Set();
  _frameTree = new FrameTree();
  /**
   * Set of frame IDs stored to indicate if a frame has received a
   * frameNavigated event so that frame tree responses could be ignored as the
   * frameNavigated event usually contains the latest information.
   */
  #frameNavigatedReceived = /* @__PURE__ */ new Set();
  #deviceRequestPromptManagerMap = /* @__PURE__ */ new WeakMap();
  #frameTreeHandled;
  get timeoutSettings() {
    return this.#timeoutSettings;
  }
  get networkManager() {
    return this.#networkManager;
  }
  get client() {
    return this.#client;
  }
  constructor(client, page, timeoutSettings) {
    super();
    this.#client = client;
    this.#page = page;
    this.#networkManager = new NetworkManager(this);
    this.#timeoutSettings = timeoutSettings;
    this.setupEventListeners(this.#client);
    client.once(CDPSessionEvent.Disconnected, () => {
      this.#onClientDisconnect().catch(debugError);
    });
  }
  /**
   * Called when the frame's client is disconnected. We don't know if the
   * disconnect means that the frame is removed or if it will be replaced by a
   * new frame. Therefore, we wait for a swap event.
   */
  async #onClientDisconnect() {
    const mainFrame = this._frameTree.getMainFrame();
    if (!mainFrame) {
      return;
    }
    if (!this.#page.browser().connected) {
      this.#removeFramesRecursively(mainFrame);
      return;
    }
    for (const child of mainFrame.childFrames()) {
      this.#removeFramesRecursively(child);
    }
    const swapped = Deferred.create({
      timeout: TIME_FOR_WAITING_FOR_SWAP,
      message: "Frame was not swapped"
    });
    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {
      swapped.resolve();
    });
    try {
      await swapped.valueOrThrow();
    } catch {
      this.#removeFramesRecursively(mainFrame);
    }
  }
  /**
   * When the main frame is replaced by another main frame,
   * we maintain the main frame object identity while updating
   * its frame tree and ID.
   */
  async swapFrameTree(client) {
    this.#client = client;
    const frame = this._frameTree.getMainFrame();
    if (frame) {
      this.#frameNavigatedReceived.add(this.#client.target()._targetId);
      this._frameTree.removeFrame(frame);
      frame.updateId(this.#client.target()._targetId);
      this._frameTree.addFrame(frame);
      frame.updateClient(client);
    }
    this.setupEventListeners(client);
    client.once(CDPSessionEvent.Disconnected, () => {
      this.#onClientDisconnect().catch(debugError);
    });
    await this.initialize(client, frame);
    await this.#networkManager.addClient(client);
    if (frame) {
      frame.emit(FrameEvent.FrameSwappedByActivation, void 0);
    }
  }
  async registerSpeculativeSession(client) {
    await this.#networkManager.addClient(client);
  }
  setupEventListeners(session) {
    session.on("Page.frameAttached", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameAttached(session, event.frameId, event.parentFrameId);
    });
    session.on("Page.frameNavigated", async (event) => {
      this.#frameNavigatedReceived.add(event.frame.id);
      await this.#frameTreeHandled?.valueOrThrow();
      void this.#onFrameNavigated(event.frame, event.type);
    });
    session.on("Page.navigatedWithinDocument", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);
    });
    session.on("Page.frameDetached", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameDetached(event.frameId, event.reason);
    });
    session.on("Page.frameStartedLoading", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameStartedLoading(event.frameId);
    });
    session.on("Page.frameStoppedLoading", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameStoppedLoading(event.frameId);
    });
    session.on("Runtime.executionContextCreated", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onExecutionContextCreated(event.context, session);
    });
    session.on("Page.lifecycleEvent", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onLifecycleEvent(event);
    });
  }
  async initialize(client, frame) {
    try {
      this.#frameTreeHandled?.resolve();
      this.#frameTreeHandled = Deferred.create();
      await Promise.all([
        this.#networkManager.addClient(client),
        client.send("Page.enable"),
        client.send("Page.getFrameTree").then(({ frameTree }) => {
          this.#handleFrameTree(client, frameTree);
          this.#frameTreeHandled?.resolve();
        }),
        client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
        client.send("Runtime.enable").then(() => {
          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
        }),
        ...(frame ? Array.from(this.#scriptsToEvaluateOnNewDocument.values()) : []).map((script) => {
          return frame?.addPreloadScript(script);
        }),
        ...(frame ? Array.from(this.#bindings.values()) : []).map((binding) => {
          return frame?.addExposedFunctionBinding(binding);
        })
      ]);
    } catch (error) {
      this.#frameTreeHandled?.resolve();
      if (isErrorLike(error) && isTargetClosedError(error)) {
        return;
      }
      throw error;
    }
  }
  page() {
    return this.#page;
  }
  mainFrame() {
    const mainFrame = this._frameTree.getMainFrame();
    assert(mainFrame, "Requesting main frame too early!");
    return mainFrame;
  }
  frames() {
    return Array.from(this._frameTree.frames());
  }
  frame(frameId) {
    return this._frameTree.getById(frameId) || null;
  }
  async addExposedFunctionBinding(binding) {
    this.#bindings.add(binding);
    await Promise.all(this.frames().map(async (frame) => {
      return await frame.addExposedFunctionBinding(binding);
    }));
  }
  async removeExposedFunctionBinding(binding) {
    this.#bindings.delete(binding);
    await Promise.all(this.frames().map(async (frame) => {
      return await frame.removeExposedFunctionBinding(binding);
    }));
  }
  async evaluateOnNewDocument(source2) {
    const { identifier } = await this.mainFrame()._client().send("Page.addScriptToEvaluateOnNewDocument", {
      source: source2
    });
    const preloadScript = new CdpPreloadScript(this.mainFrame(), identifier, source2);
    this.#scriptsToEvaluateOnNewDocument.set(identifier, preloadScript);
    await Promise.all(this.frames().map(async (frame) => {
      return await frame.addPreloadScript(preloadScript);
    }));
    return { identifier };
  }
  async removeScriptToEvaluateOnNewDocument(identifier) {
    const preloadScript = this.#scriptsToEvaluateOnNewDocument.get(identifier);
    if (!preloadScript) {
      throw new Error(`Script to evaluate on new document with id ${identifier} not found`);
    }
    this.#scriptsToEvaluateOnNewDocument.delete(identifier);
    await Promise.all(this.frames().map((frame) => {
      const identifier2 = preloadScript.getIdForFrame(frame);
      if (!identifier2) {
        return;
      }
      return frame._client().send("Page.removeScriptToEvaluateOnNewDocument", {
        identifier: identifier2
      }).catch(debugError);
    }));
  }
  onAttachedToTarget(target) {
    if (target._getTargetInfo().type !== "iframe") {
      return;
    }
    const frame = this.frame(target._getTargetInfo().targetId);
    if (frame) {
      frame.updateClient(target._session());
    }
    this.setupEventListeners(target._session());
    void this.initialize(target._session(), frame);
  }
  _deviceRequestPromptManager(client) {
    let manager = this.#deviceRequestPromptManagerMap.get(client);
    if (manager === void 0) {
      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);
      this.#deviceRequestPromptManagerMap.set(client, manager);
    }
    return manager;
  }
  #onLifecycleEvent(event) {
    const frame = this.frame(event.frameId);
    if (!frame) {
      return;
    }
    frame._onLifecycleEvent(event.loaderId, event.name);
    this.emit(FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(FrameEvent.LifecycleEvent, void 0);
  }
  #onFrameStartedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStarted();
  }
  #onFrameStoppedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStopped();
    this.emit(FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(FrameEvent.LifecycleEvent, void 0);
  }
  #handleFrameTree(session, frameTree) {
    if (frameTree.frame.parentId) {
      this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);
    }
    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {
      void this.#onFrameNavigated(frameTree.frame, "Navigation");
    } else {
      this.#frameNavigatedReceived.delete(frameTree.frame.id);
    }
    if (!frameTree.childFrames) {
      return;
    }
    for (const child of frameTree.childFrames) {
      this.#handleFrameTree(session, child);
    }
  }
  #onFrameAttached(session, frameId, parentFrameId) {
    let frame = this.frame(frameId);
    if (frame) {
      const parentFrame = this.frame(parentFrameId);
      if (session && parentFrame && frame.client !== parentFrame?.client) {
        frame.updateClient(session);
      }
      return;
    }
    frame = new CdpFrame(this, frameId, parentFrameId, session);
    this._frameTree.addFrame(frame);
    this.emit(FrameManagerEvent.FrameAttached, frame);
  }
  async #onFrameNavigated(framePayload, navigationType) {
    const frameId = framePayload.id;
    const isMainFrame = !framePayload.parentId;
    let frame = this._frameTree.getById(frameId);
    if (frame) {
      for (const child of frame.childFrames()) {
        this.#removeFramesRecursively(child);
      }
    }
    if (isMainFrame) {
      if (frame) {
        this._frameTree.removeFrame(frame);
        frame._id = frameId;
      } else {
        frame = new CdpFrame(this, frameId, void 0, this.#client);
      }
      this._frameTree.addFrame(frame);
    }
    frame = await this._frameTree.waitForFrame(frameId);
    frame._navigated(framePayload);
    this.emit(FrameManagerEvent.FrameNavigated, frame);
    frame.emit(FrameEvent.FrameNavigated, navigationType);
  }
  async #createIsolatedWorld(session, name) {
    const key = `${session.id()}:${name}`;
    if (this.#isolatedWorlds.has(key)) {
      return;
    }
    await session.send("Page.addScriptToEvaluateOnNewDocument", {
      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
      worldName: name
    });
    await Promise.all(this.frames().filter((frame) => {
      return frame.client === session;
    }).map((frame) => {
      return session.send("Page.createIsolatedWorld", {
        frameId: frame._id,
        worldName: name,
        grantUniveralAccess: true
      }).catch(debugError);
    }));
    this.#isolatedWorlds.add(key);
  }
  #onFrameNavigatedWithinDocument(frameId, url) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._navigatedWithinDocument(url);
    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);
    frame.emit(FrameEvent.FrameNavigatedWithinDocument, void 0);
    this.emit(FrameManagerEvent.FrameNavigated, frame);
    frame.emit(FrameEvent.FrameNavigated, "Navigation");
  }
  #onFrameDetached(frameId, reason) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    switch (reason) {
      case "remove":
        this.#removeFramesRecursively(frame);
        break;
      case "swap":
        this.emit(FrameManagerEvent.FrameSwapped, frame);
        frame.emit(FrameEvent.FrameSwapped, void 0);
        break;
    }
  }
  #onExecutionContextCreated(contextPayload, session) {
    const auxData = contextPayload.auxData;
    const frameId = auxData && auxData.frameId;
    const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
    let world;
    if (frame) {
      if (frame.client !== session) {
        return;
      }
      if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
        world = frame.worlds[MAIN_WORLD];
      } else if (contextPayload.name === UTILITY_WORLD_NAME) {
        world = frame.worlds[PUPPETEER_WORLD];
      }
    }
    if (!world) {
      return;
    }
    const context2 = new ExecutionContext(frame?.client || this.#client, contextPayload, world);
    world.setContext(context2);
  }
  #removeFramesRecursively(frame) {
    for (const child of frame.childFrames()) {
      this.#removeFramesRecursively(child);
    }
    frame[disposeSymbol]();
    this._frameTree.removeFrame(frame);
    this.emit(FrameManagerEvent.FrameDetached, frame);
    frame.emit(FrameEvent.FrameDetached, frame);
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Input.js
init_Input();
init_Errors();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js
var _keyDefinitions = {
  "0": { keyCode: 48, key: "0", code: "Digit0" },
  "1": { keyCode: 49, key: "1", code: "Digit1" },
  "2": { keyCode: 50, key: "2", code: "Digit2" },
  "3": { keyCode: 51, key: "3", code: "Digit3" },
  "4": { keyCode: 52, key: "4", code: "Digit4" },
  "5": { keyCode: 53, key: "5", code: "Digit5" },
  "6": { keyCode: 54, key: "6", code: "Digit6" },
  "7": { keyCode: 55, key: "7", code: "Digit7" },
  "8": { keyCode: 56, key: "8", code: "Digit8" },
  "9": { keyCode: 57, key: "9", code: "Digit9" },
  Power: { key: "Power", code: "Power" },
  Eject: { key: "Eject", code: "Eject" },
  Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
  Help: { keyCode: 6, code: "Help", key: "Help" },
  Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
  Tab: { keyCode: 9, code: "Tab", key: "Tab" },
  Numpad5: {
    keyCode: 12,
    shiftKeyCode: 101,
    key: "Clear",
    code: "Numpad5",
    shiftKey: "5",
    location: 3
  },
  NumpadEnter: {
    keyCode: 13,
    code: "NumpadEnter",
    key: "Enter",
    text: "\r",
    location: 3
  },
  Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
  ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
  ControlLeft: {
    keyCode: 17,
    code: "ControlLeft",
    key: "Control",
    location: 1
  },
  ControlRight: {
    keyCode: 17,
    code: "ControlRight",
    key: "Control",
    location: 2
  },
  AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
  AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
  Pause: { keyCode: 19, code: "Pause", key: "Pause" },
  CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
  Escape: { keyCode: 27, code: "Escape", key: "Escape" },
  Convert: { keyCode: 28, code: "Convert", key: "Convert" },
  NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
  Space: { keyCode: 32, code: "Space", key: " " },
  Numpad9: {
    keyCode: 33,
    shiftKeyCode: 105,
    key: "PageUp",
    code: "Numpad9",
    shiftKey: "9",
    location: 3
  },
  PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
  Numpad3: {
    keyCode: 34,
    shiftKeyCode: 99,
    key: "PageDown",
    code: "Numpad3",
    shiftKey: "3",
    location: 3
  },
  PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
  End: { keyCode: 35, code: "End", key: "End" },
  Numpad1: {
    keyCode: 35,
    shiftKeyCode: 97,
    key: "End",
    code: "Numpad1",
    shiftKey: "1",
    location: 3
  },
  Home: { keyCode: 36, code: "Home", key: "Home" },
  Numpad7: {
    keyCode: 36,
    shiftKeyCode: 103,
    key: "Home",
    code: "Numpad7",
    shiftKey: "7",
    location: 3
  },
  ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
  Numpad4: {
    keyCode: 37,
    shiftKeyCode: 100,
    key: "ArrowLeft",
    code: "Numpad4",
    shiftKey: "4",
    location: 3
  },
  Numpad8: {
    keyCode: 38,
    shiftKeyCode: 104,
    key: "ArrowUp",
    code: "Numpad8",
    shiftKey: "8",
    location: 3
  },
  ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
  ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
  Numpad6: {
    keyCode: 39,
    shiftKeyCode: 102,
    key: "ArrowRight",
    code: "Numpad6",
    shiftKey: "6",
    location: 3
  },
  Numpad2: {
    keyCode: 40,
    shiftKeyCode: 98,
    key: "ArrowDown",
    code: "Numpad2",
    shiftKey: "2",
    location: 3
  },
  ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
  Select: { keyCode: 41, code: "Select", key: "Select" },
  Open: { keyCode: 43, code: "Open", key: "Execute" },
  PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
  Insert: { keyCode: 45, code: "Insert", key: "Insert" },
  Numpad0: {
    keyCode: 45,
    shiftKeyCode: 96,
    key: "Insert",
    code: "Numpad0",
    shiftKey: "0",
    location: 3
  },
  Delete: { keyCode: 46, code: "Delete", key: "Delete" },
  NumpadDecimal: {
    keyCode: 46,
    shiftKeyCode: 110,
    code: "NumpadDecimal",
    key: "\0",
    shiftKey: ".",
    location: 3
  },
  Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
  Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
  Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
  Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
  Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
  Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
  Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
  Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
  Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
  Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
  KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
  KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
  KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
  KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
  KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
  KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
  KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
  KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
  KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
  KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
  KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
  KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
  KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
  KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
  KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
  KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
  KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
  KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
  KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
  KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
  KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
  KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
  KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
  KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
  KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
  KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
  MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
  MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
  ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
  NumpadMultiply: {
    keyCode: 106,
    code: "NumpadMultiply",
    key: "*",
    location: 3
  },
  NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
  NumpadSubtract: {
    keyCode: 109,
    code: "NumpadSubtract",
    key: "-",
    location: 3
  },
  NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
  F1: { keyCode: 112, code: "F1", key: "F1" },
  F2: { keyCode: 113, code: "F2", key: "F2" },
  F3: { keyCode: 114, code: "F3", key: "F3" },
  F4: { keyCode: 115, code: "F4", key: "F4" },
  F5: { keyCode: 116, code: "F5", key: "F5" },
  F6: { keyCode: 117, code: "F6", key: "F6" },
  F7: { keyCode: 118, code: "F7", key: "F7" },
  F8: { keyCode: 119, code: "F8", key: "F8" },
  F9: { keyCode: 120, code: "F9", key: "F9" },
  F10: { keyCode: 121, code: "F10", key: "F10" },
  F11: { keyCode: 122, code: "F11", key: "F11" },
  F12: { keyCode: 123, code: "F12", key: "F12" },
  F13: { keyCode: 124, code: "F13", key: "F13" },
  F14: { keyCode: 125, code: "F14", key: "F14" },
  F15: { keyCode: 126, code: "F15", key: "F15" },
  F16: { keyCode: 127, code: "F16", key: "F16" },
  F17: { keyCode: 128, code: "F17", key: "F17" },
  F18: { keyCode: 129, code: "F18", key: "F18" },
  F19: { keyCode: 130, code: "F19", key: "F19" },
  F20: { keyCode: 131, code: "F20", key: "F20" },
  F21: { keyCode: 132, code: "F21", key: "F21" },
  F22: { keyCode: 133, code: "F22", key: "F22" },
  F23: { keyCode: 134, code: "F23", key: "F23" },
  F24: { keyCode: 135, code: "F24", key: "F24" },
  NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
  ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
  AudioVolumeMute: {
    keyCode: 173,
    code: "AudioVolumeMute",
    key: "AudioVolumeMute"
  },
  AudioVolumeDown: {
    keyCode: 174,
    code: "AudioVolumeDown",
    key: "AudioVolumeDown"
  },
  AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
  MediaTrackNext: {
    keyCode: 176,
    code: "MediaTrackNext",
    key: "MediaTrackNext"
  },
  MediaTrackPrevious: {
    keyCode: 177,
    code: "MediaTrackPrevious",
    key: "MediaTrackPrevious"
  },
  MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
  MediaPlayPause: {
    keyCode: 179,
    code: "MediaPlayPause",
    key: "MediaPlayPause"
  },
  Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
  Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
  NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
  Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
  Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
  Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
  Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
  Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
  BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
  Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
  BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
  Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
  AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
  Props: { keyCode: 247, code: "Props", key: "CrSel" },
  Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
  Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
  Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
  Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
  Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
  Accept: { keyCode: 30, key: "Accept" },
  ModeChange: { keyCode: 31, key: "ModeChange" },
  " ": { keyCode: 32, key: " ", code: "Space" },
  Print: { keyCode: 42, key: "Print" },
  Execute: { keyCode: 43, key: "Execute", code: "Open" },
  "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
  a: { keyCode: 65, key: "a", code: "KeyA" },
  b: { keyCode: 66, key: "b", code: "KeyB" },
  c: { keyCode: 67, key: "c", code: "KeyC" },
  d: { keyCode: 68, key: "d", code: "KeyD" },
  e: { keyCode: 69, key: "e", code: "KeyE" },
  f: { keyCode: 70, key: "f", code: "KeyF" },
  g: { keyCode: 71, key: "g", code: "KeyG" },
  h: { keyCode: 72, key: "h", code: "KeyH" },
  i: { keyCode: 73, key: "i", code: "KeyI" },
  j: { keyCode: 74, key: "j", code: "KeyJ" },
  k: { keyCode: 75, key: "k", code: "KeyK" },
  l: { keyCode: 76, key: "l", code: "KeyL" },
  m: { keyCode: 77, key: "m", code: "KeyM" },
  n: { keyCode: 78, key: "n", code: "KeyN" },
  o: { keyCode: 79, key: "o", code: "KeyO" },
  p: { keyCode: 80, key: "p", code: "KeyP" },
  q: { keyCode: 81, key: "q", code: "KeyQ" },
  r: { keyCode: 82, key: "r", code: "KeyR" },
  s: { keyCode: 83, key: "s", code: "KeyS" },
  t: { keyCode: 84, key: "t", code: "KeyT" },
  u: { keyCode: 85, key: "u", code: "KeyU" },
  v: { keyCode: 86, key: "v", code: "KeyV" },
  w: { keyCode: 87, key: "w", code: "KeyW" },
  x: { keyCode: 88, key: "x", code: "KeyX" },
  y: { keyCode: 89, key: "y", code: "KeyY" },
  z: { keyCode: 90, key: "z", code: "KeyZ" },
  Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
  "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
  "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
  "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
  "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
  ";": { keyCode: 186, key: ";", code: "Semicolon" },
  "=": { keyCode: 187, key: "=", code: "Equal" },
  ",": { keyCode: 188, key: ",", code: "Comma" },
  ".": { keyCode: 190, key: ".", code: "Period" },
  "`": { keyCode: 192, key: "`", code: "Backquote" },
  "[": { keyCode: 219, key: "[", code: "BracketLeft" },
  "\\": { keyCode: 220, key: "\\", code: "Backslash" },
  "]": { keyCode: 221, key: "]", code: "BracketRight" },
  "'": { keyCode: 222, key: "'", code: "Quote" },
  Attn: { keyCode: 246, key: "Attn" },
  CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
  ExSel: { keyCode: 248, key: "ExSel" },
  EraseEof: { keyCode: 249, key: "EraseEof" },
  Play: { keyCode: 250, key: "Play" },
  ZoomOut: { keyCode: 251, key: "ZoomOut" },
  ")": { keyCode: 48, key: ")", code: "Digit0" },
  "!": { keyCode: 49, key: "!", code: "Digit1" },
  "@": { keyCode: 50, key: "@", code: "Digit2" },
  "#": { keyCode: 51, key: "#", code: "Digit3" },
  $: { keyCode: 52, key: "$", code: "Digit4" },
  "%": { keyCode: 53, key: "%", code: "Digit5" },
  "^": { keyCode: 54, key: "^", code: "Digit6" },
  "&": { keyCode: 55, key: "&", code: "Digit7" },
  "(": { keyCode: 57, key: "(", code: "Digit9" },
  A: { keyCode: 65, key: "A", code: "KeyA" },
  B: { keyCode: 66, key: "B", code: "KeyB" },
  C: { keyCode: 67, key: "C", code: "KeyC" },
  D: { keyCode: 68, key: "D", code: "KeyD" },
  E: { keyCode: 69, key: "E", code: "KeyE" },
  F: { keyCode: 70, key: "F", code: "KeyF" },
  G: { keyCode: 71, key: "G", code: "KeyG" },
  H: { keyCode: 72, key: "H", code: "KeyH" },
  I: { keyCode: 73, key: "I", code: "KeyI" },
  J: { keyCode: 74, key: "J", code: "KeyJ" },
  K: { keyCode: 75, key: "K", code: "KeyK" },
  L: { keyCode: 76, key: "L", code: "KeyL" },
  M: { keyCode: 77, key: "M", code: "KeyM" },
  N: { keyCode: 78, key: "N", code: "KeyN" },
  O: { keyCode: 79, key: "O", code: "KeyO" },
  P: { keyCode: 80, key: "P", code: "KeyP" },
  Q: { keyCode: 81, key: "Q", code: "KeyQ" },
  R: { keyCode: 82, key: "R", code: "KeyR" },
  S: { keyCode: 83, key: "S", code: "KeyS" },
  T: { keyCode: 84, key: "T", code: "KeyT" },
  U: { keyCode: 85, key: "U", code: "KeyU" },
  V: { keyCode: 86, key: "V", code: "KeyV" },
  W: { keyCode: 87, key: "W", code: "KeyW" },
  X: { keyCode: 88, key: "X", code: "KeyX" },
  Y: { keyCode: 89, key: "Y", code: "KeyY" },
  Z: { keyCode: 90, key: "Z", code: "KeyZ" },
  ":": { keyCode: 186, key: ":", code: "Semicolon" },
  "<": { keyCode: 188, key: "<", code: "Comma" },
  _: { keyCode: 189, key: "_", code: "Minus" },
  ">": { keyCode: 190, key: ">", code: "Period" },
  "?": { keyCode: 191, key: "?", code: "Slash" },
  "~": { keyCode: 192, key: "~", code: "Backquote" },
  "{": { keyCode: 219, key: "{", code: "BracketLeft" },
  "|": { keyCode: 220, key: "|", code: "Backslash" },
  "}": { keyCode: 221, key: "}", code: "BracketRight" },
  '"': { keyCode: 222, key: '"', code: "Quote" },
  SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
  SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
  Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
  Call: { key: "Call", code: "Call", location: 4 },
  EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
  VolumeDown: {
    keyCode: 182,
    key: "VolumeDown",
    code: "VolumeDown",
    location: 4
  },
  VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Input.js
init_assert();
var CdpKeyboard = class extends Keyboard {
  #client;
  #pressedKeys = /* @__PURE__ */ new Set();
  _modifiers = 0;
  constructor(client) {
    super();
    this.#client = client;
  }
  updateClient(client) {
    this.#client = client;
  }
  async down(key, options = {
    text: void 0,
    commands: []
  }) {
    const description = this.#keyDescriptionForString(key);
    const autoRepeat = this.#pressedKeys.has(description.code);
    this.#pressedKeys.add(description.code);
    this._modifiers |= this.#modifierBit(description.key);
    const text = options.text === void 0 ? description.text : options.text;
    await this.#client.send("Input.dispatchKeyEvent", {
      type: text ? "keyDown" : "rawKeyDown",
      modifiers: this._modifiers,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      key: description.key,
      text,
      unmodifiedText: text,
      autoRepeat,
      location: description.location,
      isKeypad: description.location === 3,
      commands: options.commands
    });
  }
  #modifierBit(key) {
    if (key === "Alt") {
      return 1;
    }
    if (key === "Control") {
      return 2;
    }
    if (key === "Meta") {
      return 4;
    }
    if (key === "Shift") {
      return 8;
    }
    return 0;
  }
  #keyDescriptionForString(keyString) {
    const shift = this._modifiers & 8;
    const description = {
      key: "",
      keyCode: 0,
      code: "",
      text: "",
      location: 0
    };
    const definition = _keyDefinitions[keyString];
    assert(definition, `Unknown key: "${keyString}"`);
    if (definition.key) {
      description.key = definition.key;
    }
    if (shift && definition.shiftKey) {
      description.key = definition.shiftKey;
    }
    if (definition.keyCode) {
      description.keyCode = definition.keyCode;
    }
    if (shift && definition.shiftKeyCode) {
      description.keyCode = definition.shiftKeyCode;
    }
    if (definition.code) {
      description.code = definition.code;
    }
    if (definition.location) {
      description.location = definition.location;
    }
    if (description.key.length === 1) {
      description.text = description.key;
    }
    if (definition.text) {
      description.text = definition.text;
    }
    if (shift && definition.shiftText) {
      description.text = definition.shiftText;
    }
    if (this._modifiers & ~8) {
      description.text = "";
    }
    return description;
  }
  async up(key) {
    const description = this.#keyDescriptionForString(key);
    this._modifiers &= ~this.#modifierBit(description.key);
    this.#pressedKeys.delete(description.code);
    await this.#client.send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: this._modifiers,
      key: description.key,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      location: description.location
    });
  }
  async sendCharacter(char) {
    await this.#client.send("Input.insertText", { text: char });
  }
  charIsKey(char) {
    return !!_keyDefinitions[char];
  }
  async type(text, options = {}) {
    const delay = options.delay || void 0;
    for (const char of text) {
      if (this.charIsKey(char)) {
        await this.press(char, { delay });
      } else {
        if (delay) {
          await new Promise((f) => {
            return setTimeout(f, delay);
          });
        }
        await this.sendCharacter(char);
      }
    }
  }
  async press(key, options = {}) {
    const { delay = null } = options;
    await this.down(key, options);
    if (delay) {
      await new Promise((f) => {
        return setTimeout(f, options.delay);
      });
    }
    await this.up(key);
  }
};
var getFlag = (button) => {
  switch (button) {
    case MouseButton.Left:
      return 1;
    case MouseButton.Right:
      return 2;
    case MouseButton.Middle:
      return 4;
    case MouseButton.Back:
      return 8;
    case MouseButton.Forward:
      return 16;
  }
};
var getButtonFromPressedButtons = (buttons) => {
  if (buttons & 1) {
    return MouseButton.Left;
  } else if (buttons & 2) {
    return MouseButton.Right;
  } else if (buttons & 4) {
    return MouseButton.Middle;
  } else if (buttons & 8) {
    return MouseButton.Back;
  } else if (buttons & 16) {
    return MouseButton.Forward;
  }
  return "none";
};
var CdpMouse = class extends Mouse {
  #client;
  #keyboard;
  constructor(client, keyboard) {
    super();
    this.#client = client;
    this.#keyboard = keyboard;
  }
  updateClient(client) {
    this.#client = client;
  }
  #_state = {
    position: { x: 0, y: 0 },
    buttons: 0
  };
  get #state() {
    return Object.assign({ ...this.#_state }, ...this.#transactions);
  }
  // Transactions can run in parallel, so we store each of thme in this array.
  #transactions = [];
  #createTransaction() {
    const transaction = {};
    this.#transactions.push(transaction);
    const popTransaction = () => {
      this.#transactions.splice(this.#transactions.indexOf(transaction), 1);
    };
    return {
      update: (updates) => {
        Object.assign(transaction, updates);
      },
      commit: () => {
        this.#_state = { ...this.#_state, ...transaction };
        popTransaction();
      },
      rollback: popTransaction
    };
  }
  /**
   * This is a shortcut for a typical update, commit/rollback lifecycle based on
   * the error of the action.
   */
  async #withTransaction(action) {
    const { update, commit, rollback } = this.#createTransaction();
    try {
      await action(update);
      commit();
    } catch (error) {
      rollback();
      throw error;
    }
  }
  async reset() {
    const actions = [];
    for (const [flag, button] of [
      [1, MouseButton.Left],
      [4, MouseButton.Middle],
      [2, MouseButton.Right],
      [16, MouseButton.Forward],
      [8, MouseButton.Back]
    ]) {
      if (this.#state.buttons & flag) {
        actions.push(this.up({ button }));
      }
    }
    if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {
      actions.push(this.move(0, 0));
    }
    await Promise.all(actions);
  }
  async move(x, y, options = {}) {
    const { steps = 1 } = options;
    const from2 = this.#state.position;
    const to = { x, y };
    for (let i = 1; i <= steps; i++) {
      await this.#withTransaction((updateState) => {
        updateState({
          position: {
            x: from2.x + (to.x - from2.x) * (i / steps),
            y: from2.y + (to.y - from2.y) * (i / steps)
          }
        });
        const { buttons, position } = this.#state;
        return this.#client.send("Input.dispatchMouseEvent", {
          type: "mouseMoved",
          modifiers: this.#keyboard._modifiers,
          buttons,
          button: getButtonFromPressedButtons(buttons),
          ...position
        });
      });
    }
  }
  async down(options = {}) {
    const { button = MouseButton.Left, clickCount = 1 } = options;
    const flag = getFlag(button);
    if (!flag) {
      throw new Error(`Unsupported mouse button: ${button}`);
    }
    if (this.#state.buttons & flag) {
      throw new Error(`'${button}' is already pressed.`);
    }
    await this.#withTransaction((updateState) => {
      updateState({
        buttons: this.#state.buttons | flag
      });
      const { buttons, position } = this.#state;
      return this.#client.send("Input.dispatchMouseEvent", {
        type: "mousePressed",
        modifiers: this.#keyboard._modifiers,
        clickCount,
        buttons,
        button,
        ...position
      });
    });
  }
  async up(options = {}) {
    const { button = MouseButton.Left, clickCount = 1 } = options;
    const flag = getFlag(button);
    if (!flag) {
      throw new Error(`Unsupported mouse button: ${button}`);
    }
    if (!(this.#state.buttons & flag)) {
      throw new Error(`'${button}' is not pressed.`);
    }
    await this.#withTransaction((updateState) => {
      updateState({
        buttons: this.#state.buttons & ~flag
      });
      const { buttons, position } = this.#state;
      return this.#client.send("Input.dispatchMouseEvent", {
        type: "mouseReleased",
        modifiers: this.#keyboard._modifiers,
        clickCount,
        buttons,
        button,
        ...position
      });
    });
  }
  async click(x, y, options = {}) {
    const { delay, count = 1, clickCount = count } = options;
    if (count < 1) {
      throw new Error("Click must occur a positive number of times.");
    }
    const actions = [this.move(x, y)];
    if (clickCount === count) {
      for (let i = 1; i < count; ++i) {
        actions.push(this.down({ ...options, clickCount: i }), this.up({ ...options, clickCount: i }));
      }
    }
    actions.push(this.down({ ...options, clickCount }));
    if (typeof delay === "number") {
      await Promise.all(actions);
      actions.length = 0;
      await new Promise((resolve) => {
        setTimeout(resolve, delay);
      });
    }
    actions.push(this.up({ ...options, clickCount }));
    await Promise.all(actions);
  }
  async wheel(options = {}) {
    const { deltaX = 0, deltaY = 0 } = options;
    const { position, buttons } = this.#state;
    await this.#client.send("Input.dispatchMouseEvent", {
      type: "mouseWheel",
      pointerType: "mouse",
      modifiers: this.#keyboard._modifiers,
      deltaY,
      deltaX,
      buttons,
      ...position
    });
  }
  async drag(start, target) {
    const promise = new Promise((resolve) => {
      this.#client.once("Input.dragIntercepted", (event) => {
        return resolve(event.data);
      });
    });
    await this.move(start.x, start.y);
    await this.down();
    await this.move(target.x, target.y);
    return await promise;
  }
  async dragEnter(target, data) {
    await this.#client.send("Input.dispatchDragEvent", {
      type: "dragEnter",
      x: target.x,
      y: target.y,
      modifiers: this.#keyboard._modifiers,
      data
    });
  }
  async dragOver(target, data) {
    await this.#client.send("Input.dispatchDragEvent", {
      type: "dragOver",
      x: target.x,
      y: target.y,
      modifiers: this.#keyboard._modifiers,
      data
    });
  }
  async drop(target, data) {
    await this.#client.send("Input.dispatchDragEvent", {
      type: "drop",
      x: target.x,
      y: target.y,
      modifiers: this.#keyboard._modifiers,
      data
    });
  }
  async dragAndDrop(start, target, options = {}) {
    const { delay = null } = options;
    const data = await this.drag(start, target);
    await this.dragEnter(target, data);
    await this.dragOver(target, data);
    if (delay) {
      await new Promise((resolve) => {
        return setTimeout(resolve, delay);
      });
    }
    await this.drop(target, data);
    await this.up();
  }
};
var CdpTouchHandle = class {
  #started = false;
  #touchScreen;
  #touchPoint;
  #client;
  #keyboard;
  constructor(client, touchScreen, keyboard, touchPoint) {
    this.#client = client;
    this.#touchScreen = touchScreen;
    this.#keyboard = keyboard;
    this.#touchPoint = touchPoint;
  }
  updateClient(client) {
    this.#client = client;
  }
  async start() {
    if (this.#started) {
      throw new TouchError("Touch has already started");
    }
    await this.#client.send("Input.dispatchTouchEvent", {
      type: "touchStart",
      touchPoints: [this.#touchPoint],
      modifiers: this.#keyboard._modifiers
    });
    this.#started = true;
  }
  move(x, y) {
    this.#touchPoint.x = Math.round(x);
    this.#touchPoint.y = Math.round(y);
    return this.#client.send("Input.dispatchTouchEvent", {
      type: "touchMove",
      touchPoints: [this.#touchPoint],
      modifiers: this.#keyboard._modifiers
    });
  }
  async end() {
    await this.#client.send("Input.dispatchTouchEvent", {
      type: "touchEnd",
      touchPoints: [this.#touchPoint],
      modifiers: this.#keyboard._modifiers
    });
    this.#touchScreen.removeHandle(this);
  }
};
var CdpTouchscreen = class extends Touchscreen {
  #client;
  #keyboard;
  constructor(client, keyboard) {
    super();
    this.#client = client;
    this.#keyboard = keyboard;
  }
  updateClient(client) {
    this.#client = client;
    this.touches.forEach((t) => {
      t.updateClient(client);
    });
  }
  async touchStart(x, y) {
    const id = this.idGenerator();
    const touchPoint = {
      x: Math.round(x),
      y: Math.round(y),
      radiusX: 0.5,
      radiusY: 0.5,
      force: 0.5,
      id
    };
    const touch = new CdpTouchHandle(this.#client, this, this.#keyboard, touchPoint);
    await touch.start();
    this.touches.push(touch);
    return touch;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
init_Tracing();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/WebWorker.js
init_CDPSession();
init_Target();
init_WebWorker();
init_TimeoutSettings();
init_util();
var CdpWebWorker = class extends WebWorker {
  #world;
  #client;
  #id;
  #targetType;
  constructor(client, url, targetId, targetType, consoleAPICalled, exceptionThrown) {
    super(url);
    this.#id = targetId;
    this.#client = client;
    this.#targetType = targetType;
    this.#world = new IsolatedWorld(this, new TimeoutSettings());
    this.#client.once("Runtime.executionContextCreated", async (event) => {
      this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
    });
    this.#world.emitter.on("consoleapicalled", async (event) => {
      try {
        return consoleAPICalled(event.type, event.args.map((object) => {
          return new CdpJSHandle(this.#world, object);
        }), event.stackTrace);
      } catch (err) {
        debugError(err);
      }
    });
    this.#client.on("Runtime.exceptionThrown", exceptionThrown);
    this.#client.once(CDPSessionEvent.Disconnected, () => {
      this.#world.dispose();
    });
    this.#client.send("Runtime.enable").catch(debugError);
  }
  mainRealm() {
    return this.#world;
  }
  get client() {
    return this.#client;
  }
  async close() {
    switch (this.#targetType) {
      case TargetType.SERVICE_WORKER:
      case TargetType.SHARED_WORKER: {
        await this.client.connection()?.send("Target.closeTarget", {
          targetId: this.#id
        });
        await this.client.connection()?.send("Target.detachFromTarget", {
          sessionId: this.client.id()
        });
        break;
      }
      default:
        await this.evaluate(() => {
          self.close();
        });
    }
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
var __addDisposableResource12 = function(env, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose, inner;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async2)
        inner = dispose;
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    if (inner)
      dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    env.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources12 = function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1)
            return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async)
              return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } else
            s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1)
        return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
function convertConsoleMessageLevel(method) {
  switch (method) {
    case "warning":
      return "warn";
    default:
      return method;
  }
}
var CdpPage = class extends Page {
  static async _create(client, target, defaultViewport) {
    const page = new CdpPage(client, target);
    await page.#initialize();
    if (defaultViewport) {
      try {
        await page.setViewport(defaultViewport);
      } catch (err) {
        if (isErrorLike(err) && isTargetClosedError(err)) {
          debugError(err);
        } else {
          throw err;
        }
      }
    }
    return page;
  }
  #closed = false;
  #targetManager;
  #primaryTargetClient;
  #primaryTarget;
  #tabTargetClient;
  #tabTarget;
  #keyboard;
  #mouse;
  #touchscreen;
  #frameManager;
  #emulationManager;
  #tracing;
  #bindings = /* @__PURE__ */ new Map();
  #exposedFunctions = /* @__PURE__ */ new Map();
  #coverage;
  #viewport;
  #workers = /* @__PURE__ */ new Map();
  #fileChooserDeferreds = /* @__PURE__ */ new Set();
  #sessionCloseDeferred = Deferred.create();
  #serviceWorkerBypassed = false;
  #userDragInterceptionEnabled = false;
  constructor(client, target) {
    super();
    this.#primaryTargetClient = client;
    this.#tabTargetClient = client.parentSession();
    assert(this.#tabTargetClient, "Tab target session is not defined.");
    this.#tabTarget = this.#tabTargetClient.target();
    assert(this.#tabTarget, "Tab target is not defined.");
    this.#primaryTarget = target;
    this.#targetManager = target._targetManager();
    this.#keyboard = new CdpKeyboard(client);
    this.#mouse = new CdpMouse(client, this.#keyboard);
    this.#touchscreen = new CdpTouchscreen(client, this.#keyboard);
    this.#frameManager = new FrameManager(client, this, this._timeoutSettings);
    this.#emulationManager = new EmulationManager(client);
    this.#tracing = new Tracing(client);
    this.#coverage = new Coverage(client);
    this.#viewport = null;
    const frameManagerEmitter = new EventEmitter(this.#frameManager);
    frameManagerEmitter.on(FrameManagerEvent.FrameAttached, (frame) => {
      this.emit("frameattached", frame);
    });
    frameManagerEmitter.on(FrameManagerEvent.FrameDetached, (frame) => {
      this.emit("framedetached", frame);
    });
    frameManagerEmitter.on(FrameManagerEvent.FrameNavigated, (frame) => {
      this.emit("framenavigated", frame);
    });
    frameManagerEmitter.on(FrameManagerEvent.ConsoleApiCalled, ([world, event]) => {
      this.#onConsoleAPI(world, event);
    });
    frameManagerEmitter.on(FrameManagerEvent.BindingCalled, ([world, event]) => {
      void this.#onBindingCalled(world, event);
    });
    const networkManagerEmitter = new EventEmitter(this.#frameManager.networkManager);
    networkManagerEmitter.on(NetworkManagerEvent.Request, (request) => {
      this.emit("request", request);
    });
    networkManagerEmitter.on(NetworkManagerEvent.RequestServedFromCache, (request) => {
      this.emit("requestservedfromcache", request);
    });
    networkManagerEmitter.on(NetworkManagerEvent.Response, (response) => {
      this.emit("response", response);
    });
    networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, (request) => {
      this.emit("requestfailed", request);
    });
    networkManagerEmitter.on(NetworkManagerEvent.RequestFinished, (request) => {
      this.emit("requestfinished", request);
    });
    this.#tabTargetClient.on(CDPSessionEvent.Swapped, this.#onActivation.bind(this));
    this.#tabTargetClient.on(CDPSessionEvent.Ready, this.#onSecondaryTarget.bind(this));
    this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
    this.#tabTarget._isClosedDeferred.valueOrThrow().then(() => {
      this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
      this.emit("close", void 0);
      this.#closed = true;
    }).catch(debugError);
    this.#setupPrimaryTargetListeners();
    this.#attachExistingTargets();
  }
  #attachExistingTargets() {
    const queue = [];
    for (const childTarget of this.#targetManager.getChildTargets(this.#primaryTarget)) {
      queue.push(childTarget);
    }
    let idx = 0;
    while (idx < queue.length) {
      const next = queue[idx];
      idx++;
      const session = next._session();
      if (session) {
        this.#onAttachedToTarget(session);
      }
      for (const childTarget of this.#targetManager.getChildTargets(next)) {
        queue.push(childTarget);
      }
    }
  }
  async #onActivation(newSession) {
    assert(newSession instanceof CdpCDPSession, "CDPSession is not instance of CdpCDPSession");
    this.#primaryTargetClient = newSession;
    this.#primaryTarget = newSession.target();
    assert(this.#primaryTarget, "Missing target on swap");
    this.#keyboard.updateClient(newSession);
    this.#mouse.updateClient(newSession);
    this.#touchscreen.updateClient(newSession);
    this.#emulationManager.updateClient(newSession);
    this.#tracing.updateClient(newSession);
    this.#coverage.updateClient(newSession);
    await this.#frameManager.swapFrameTree(newSession);
    this.#setupPrimaryTargetListeners();
  }
  async #onSecondaryTarget(session) {
    assert(session instanceof CdpCDPSession);
    if (session.target()._subtype() !== "prerender") {
      return;
    }
    this.#frameManager.registerSpeculativeSession(session).catch(debugError);
    this.#emulationManager.registerSpeculativeSession(session).catch(debugError);
  }
  /**
   * Sets up listeners for the primary target. The primary target can change
   * during a navigation to a prerended page.
   */
  #setupPrimaryTargetListeners() {
    const clientEmitter = new EventEmitter(this.#primaryTargetClient);
    clientEmitter.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
    clientEmitter.on(CDPSessionEvent.Disconnected, () => {
      this.#sessionCloseDeferred.reject(new TargetCloseError("Target closed"));
    });
    clientEmitter.on("Page.domContentEventFired", () => {
      this.emit("domcontentloaded", void 0);
    });
    clientEmitter.on("Page.loadEventFired", () => {
      this.emit("load", void 0);
    });
    clientEmitter.on("Page.javascriptDialogOpening", this.#onDialog.bind(this));
    clientEmitter.on("Runtime.exceptionThrown", this.#handleException.bind(this));
    clientEmitter.on("Inspector.targetCrashed", this.#onTargetCrashed.bind(this));
    clientEmitter.on("Performance.metrics", this.#emitMetrics.bind(this));
    clientEmitter.on("Log.entryAdded", this.#onLogEntryAdded.bind(this));
    clientEmitter.on("Page.fileChooserOpened", this.#onFileChooser.bind(this));
  }
  #onDetachedFromTarget = (target) => {
    const sessionId = target._session()?.id();
    const worker = this.#workers.get(sessionId);
    if (!worker) {
      return;
    }
    this.#workers.delete(sessionId);
    this.emit("workerdestroyed", worker);
  };
  #onAttachedToTarget = (session) => {
    assert(session instanceof CdpCDPSession);
    this.#frameManager.onAttachedToTarget(session.target());
    if (session.target()._getTargetInfo().type === "worker") {
      const worker = new CdpWebWorker(session, session.target().url(), session.target()._targetId, session.target().type(), this.#addConsoleMessage.bind(this), this.#handleException.bind(this));
      this.#workers.set(session.id(), worker);
      this.emit("workercreated", worker);
    }
    session.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
  };
  async #initialize() {
    try {
      await Promise.all([
        this.#frameManager.initialize(this.#primaryTargetClient),
        this.#primaryTargetClient.send("Performance.enable"),
        this.#primaryTargetClient.send("Log.enable")
      ]);
    } catch (err) {
      if (isErrorLike(err) && isTargetClosedError(err)) {
        debugError(err);
      } else {
        throw err;
      }
    }
  }
  async #onFileChooser(event) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      if (!this.#fileChooserDeferreds.size) {
        return;
      }
      const frame = this.#frameManager.frame(event.frameId);
      assert(frame, "This should never happen.");
      const handle = __addDisposableResource12(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);
      const fileChooser = new FileChooser(handle.move(), event);
      for (const promise of this.#fileChooserDeferreds) {
        promise.resolve(fileChooser);
      }
      this.#fileChooserDeferreds.clear();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources12(env_1);
    }
  }
  _client() {
    return this.#primaryTargetClient;
  }
  isServiceWorkerBypassed() {
    return this.#serviceWorkerBypassed;
  }
  isDragInterceptionEnabled() {
    return this.#userDragInterceptionEnabled;
  }
  isJavaScriptEnabled() {
    return this.#emulationManager.javascriptEnabled;
  }
  async waitForFileChooser(options = {}) {
    const needsEnable = this.#fileChooserDeferreds.size === 0;
    const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`FileChooser\` failed: ${timeout2}ms exceeded`,
      timeout: timeout2
    });
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        deferred.reject(options.signal?.reason);
      }, { once: true });
    }
    this.#fileChooserDeferreds.add(deferred);
    let enablePromise;
    if (needsEnable) {
      enablePromise = this.#primaryTargetClient.send("Page.setInterceptFileChooserDialog", {
        enabled: true
      });
    }
    try {
      const [result] = await Promise.all([
        deferred.valueOrThrow(),
        enablePromise
      ]);
      return result;
    } catch (error) {
      this.#fileChooserDeferreds.delete(deferred);
      throw error;
    }
  }
  async setGeolocation(options) {
    return await this.#emulationManager.setGeolocation(options);
  }
  target() {
    return this.#primaryTarget;
  }
  browser() {
    return this.#primaryTarget.browser();
  }
  browserContext() {
    return this.#primaryTarget.browserContext();
  }
  #onTargetCrashed() {
    this.emit("error", new Error("Page crashed!"));
  }
  #onLogEntryAdded(event) {
    const { level, text, args, source: source2, url, lineNumber } = event.entry;
    if (args) {
      args.map((arg) => {
        void releaseObject(this.#primaryTargetClient, arg);
      });
    }
    if (source2 !== "worker") {
      this.emit("console", new ConsoleMessage(convertConsoleMessageLevel(level), text, [], [{ url, lineNumber }]));
    }
  }
  mainFrame() {
    return this.#frameManager.mainFrame();
  }
  get keyboard() {
    return this.#keyboard;
  }
  get touchscreen() {
    return this.#touchscreen;
  }
  get coverage() {
    return this.#coverage;
  }
  get tracing() {
    return this.#tracing;
  }
  frames() {
    return this.#frameManager.frames();
  }
  workers() {
    return Array.from(this.#workers.values());
  }
  async setRequestInterception(value) {
    return await this.#frameManager.networkManager.setRequestInterception(value);
  }
  async setBypassServiceWorker(bypass) {
    this.#serviceWorkerBypassed = bypass;
    return await this.#primaryTargetClient.send("Network.setBypassServiceWorker", { bypass });
  }
  async setDragInterception(enabled) {
    this.#userDragInterceptionEnabled = enabled;
    return await this.#primaryTargetClient.send("Input.setInterceptDrags", {
      enabled
    });
  }
  async setOfflineMode(enabled) {
    return await this.#frameManager.networkManager.setOfflineMode(enabled);
  }
  async emulateNetworkConditions(networkConditions) {
    return await this.#frameManager.networkManager.emulateNetworkConditions(networkConditions);
  }
  setDefaultNavigationTimeout(timeout2) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
  }
  setDefaultTimeout(timeout2) {
    this._timeoutSettings.setDefaultTimeout(timeout2);
  }
  getDefaultTimeout() {
    return this._timeoutSettings.timeout();
  }
  getDefaultNavigationTimeout() {
    return this._timeoutSettings.navigationTimeout();
  }
  async queryObjects(prototypeHandle) {
    assert(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
    assert(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
    const response = await this.mainFrame().client.send("Runtime.queryObjects", {
      prototypeObjectId: prototypeHandle.id
    });
    return this.mainFrame().mainRealm().createCdpHandle(response.objects);
  }
  async cookies(...urls) {
    const originalCookies = (await this.#primaryTargetClient.send("Network.getCookies", {
      urls: urls.length ? urls : [this.url()]
    })).cookies;
    const unsupportedCookieAttributes = ["sourcePort"];
    const filterUnsupportedAttributes = (cookie) => {
      for (const attr of unsupportedCookieAttributes) {
        delete cookie[attr];
      }
      return cookie;
    };
    return originalCookies.map(filterUnsupportedAttributes).map((cookie) => {
      return {
        ...cookie,
        // TODO: a breaking change is needed in Puppeteer types to support other
        // partition keys.
        partitionKey: cookie.partitionKey ? cookie.partitionKey.topLevelSite : void 0
      };
    });
  }
  async deleteCookie(...cookies) {
    const pageURL = this.url();
    for (const cookie of cookies) {
      const item = {
        ...cookie,
        partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookie.partitionKey)
      };
      if (!cookie.url && pageURL.startsWith("http")) {
        item.url = pageURL;
      }
      await this.#primaryTargetClient.send("Network.deleteCookies", item);
      if (pageURL.startsWith("http") && !item.partitionKey) {
        const url = new URL(pageURL);
        await this.#primaryTargetClient.send("Network.deleteCookies", {
          ...item,
          partitionKey: {
            topLevelSite: url.origin.replace(`:${url.port}`, ""),
            hasCrossSiteAncestor: false
          }
        });
      }
    }
  }
  async setCookie(...cookies) {
    const pageURL = this.url();
    const startsWithHTTP = pageURL.startsWith("http");
    const items = cookies.map((cookie) => {
      const item = Object.assign({}, cookie);
      if (!item.url && startsWithHTTP) {
        item.url = pageURL;
      }
      assert(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
      assert(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
      return item;
    });
    await this.deleteCookie(...items);
    if (items.length) {
      await this.#primaryTargetClient.send("Network.setCookies", {
        cookies: items.map((cookieParam) => {
          return {
            ...cookieParam,
            partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookieParam.partitionKey)
          };
        })
      });
    }
  }
  async exposeFunction(name, pptrFunction) {
    if (this.#bindings.has(name)) {
      throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
    }
    const source2 = pageBindingInitString("exposedFun", name);
    let binding;
    switch (typeof pptrFunction) {
      case "function":
        binding = new Binding(name, pptrFunction, source2);
        break;
      default:
        binding = new Binding(name, pptrFunction.default, source2);
        break;
    }
    this.#bindings.set(name, binding);
    const [{ identifier }] = await Promise.all([
      this.#frameManager.evaluateOnNewDocument(source2),
      this.#frameManager.addExposedFunctionBinding(binding)
    ]);
    this.#exposedFunctions.set(name, identifier);
  }
  async removeExposedFunction(name) {
    const exposedFunctionId = this.#exposedFunctions.get(name);
    if (!exposedFunctionId) {
      throw new Error(`Function with name "${name}" does not exist`);
    }
    const binding = this.#bindings.get(name);
    this.#exposedFunctions.delete(name);
    this.#bindings.delete(name);
    await Promise.all([
      this.#frameManager.removeScriptToEvaluateOnNewDocument(exposedFunctionId),
      this.#frameManager.removeExposedFunctionBinding(binding)
    ]);
  }
  async authenticate(credentials) {
    return await this.#frameManager.networkManager.authenticate(credentials);
  }
  async setExtraHTTPHeaders(headers) {
    return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);
  }
  async setUserAgent(userAgent, userAgentMetadata) {
    return await this.#frameManager.networkManager.setUserAgent(userAgent, userAgentMetadata);
  }
  async metrics() {
    const response = await this.#primaryTargetClient.send("Performance.getMetrics");
    return this.#buildMetricsObject(response.metrics);
  }
  #emitMetrics(event) {
    this.emit("metrics", {
      title: event.title,
      metrics: this.#buildMetricsObject(event.metrics)
    });
  }
  #buildMetricsObject(metrics) {
    const result = {};
    for (const metric of metrics || []) {
      if (supportedMetrics.has(metric.name)) {
        result[metric.name] = metric.value;
      }
    }
    return result;
  }
  #handleException(exception) {
    this.emit("pageerror", createClientError(exception.exceptionDetails));
  }
  #onConsoleAPI(world, event) {
    const values = event.args.map((arg) => {
      return world.createCdpHandle(arg);
    });
    this.#addConsoleMessage(convertConsoleMessageLevel(event.type), values, event.stackTrace);
  }
  async #onBindingCalled(world, event) {
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      return;
    }
    const { type, name, seq, args, isTrivial } = payload;
    if (type !== "exposedFun") {
      return;
    }
    const context2 = world.context;
    if (!context2) {
      return;
    }
    const binding = this.#bindings.get(name);
    await binding?.run(context2, seq, args, isTrivial);
  }
  #addConsoleMessage(eventType, args, stackTrace) {
    if (!this.listenerCount(
      "console"
      /* PageEvent.Console */
    )) {
      args.forEach((arg) => {
        return arg.dispose();
      });
      return;
    }
    const textTokens = [];
    for (const arg of args) {
      const remoteObject = arg.remoteObject();
      if (remoteObject.objectId) {
        textTokens.push(arg.toString());
      } else {
        textTokens.push(valueFromRemoteObject(remoteObject));
      }
    }
    const stackTraceLocations = [];
    if (stackTrace) {
      for (const callFrame of stackTrace.callFrames) {
        stackTraceLocations.push({
          url: callFrame.url,
          lineNumber: callFrame.lineNumber,
          columnNumber: callFrame.columnNumber
        });
      }
    }
    const message = new ConsoleMessage(convertConsoleMessageLevel(eventType), textTokens.join(" "), args, stackTraceLocations);
    this.emit("console", message);
  }
  #onDialog(event) {
    const type = validateDialogType(event.type);
    const dialog = new CdpDialog(this.#primaryTargetClient, type, event.message, event.defaultPrompt);
    this.emit("dialog", dialog);
  }
  async reload(options) {
    const [result] = await Promise.all([
      this.waitForNavigation({
        ...options,
        ignoreSameDocumentNavigation: true
      }),
      this.#primaryTargetClient.send("Page.reload")
    ]);
    return result;
  }
  async createCDPSession() {
    return await this.target().createCDPSession();
  }
  async goBack(options = {}) {
    return await this.#go(-1, options);
  }
  async goForward(options = {}) {
    return await this.#go(1, options);
  }
  async #go(delta, options) {
    const history = await this.#primaryTargetClient.send("Page.getNavigationHistory");
    const entry = history.entries[history.currentIndex + delta];
    if (!entry) {
      return null;
    }
    const result = await Promise.all([
      this.waitForNavigation(options),
      this.#primaryTargetClient.send("Page.navigateToHistoryEntry", {
        entryId: entry.id
      })
    ]);
    return result[0];
  }
  async bringToFront() {
    await this.#primaryTargetClient.send("Page.bringToFront");
  }
  async setJavaScriptEnabled(enabled) {
    return await this.#emulationManager.setJavaScriptEnabled(enabled);
  }
  async setBypassCSP(enabled) {
    await this.#primaryTargetClient.send("Page.setBypassCSP", { enabled });
  }
  async emulateMediaType(type) {
    return await this.#emulationManager.emulateMediaType(type);
  }
  async emulateCPUThrottling(factor) {
    return await this.#emulationManager.emulateCPUThrottling(factor);
  }
  async emulateMediaFeatures(features) {
    return await this.#emulationManager.emulateMediaFeatures(features);
  }
  async emulateTimezone(timezoneId) {
    return await this.#emulationManager.emulateTimezone(timezoneId);
  }
  async emulateIdleState(overrides) {
    return await this.#emulationManager.emulateIdleState(overrides);
  }
  async emulateVisionDeficiency(type) {
    return await this.#emulationManager.emulateVisionDeficiency(type);
  }
  async setViewport(viewport) {
    const needsReload = await this.#emulationManager.emulateViewport(viewport);
    this.#viewport = viewport;
    if (needsReload) {
      await this.reload();
    }
  }
  viewport() {
    return this.#viewport;
  }
  async evaluateOnNewDocument(pageFunction, ...args) {
    const source2 = evaluationString(pageFunction, ...args);
    return await this.#frameManager.evaluateOnNewDocument(source2);
  }
  async removeScriptToEvaluateOnNewDocument(identifier) {
    return await this.#frameManager.removeScriptToEvaluateOnNewDocument(identifier);
  }
  async setCacheEnabled(enabled = true) {
    await this.#frameManager.networkManager.setCacheEnabled(enabled);
  }
  async _screenshot(options) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const { fromSurface, omitBackground, optimizeForSpeed, quality, clip: userClip, type, captureBeyondViewport } = options;
      const stack = __addDisposableResource12(env_2, new AsyncDisposableStack(), true);
      if (omitBackground && (type === "png" || type === "webp")) {
        await this.#emulationManager.setTransparentBackgroundColor();
        stack.defer(async () => {
          await this.#emulationManager.resetDefaultBackgroundColor().catch(debugError);
        });
      }
      let clip = userClip;
      if (clip && !captureBeyondViewport) {
        const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {
          const { height, pageLeft: x, pageTop: y, width } = window.visualViewport;
          return { x, y, height, width };
        });
        clip = getIntersectionRect(clip, viewport);
      }
      const { data } = await this.#primaryTargetClient.send("Page.captureScreenshot", {
        format: type,
        optimizeForSpeed,
        fromSurface,
        ...quality !== void 0 ? { quality: Math.round(quality) } : {},
        ...clip ? { clip: { ...clip, scale: clip.scale ?? 1 } } : {},
        captureBeyondViewport
      });
      return data;
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      const result_1 = __disposeResources12(env_2);
      if (result_1)
        await result_1;
    }
  }
  async createPDFStream(options = {}) {
    const { timeout: ms = this._timeoutSettings.timeout() } = options;
    const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, tagged: generateTaggedPDF, outline: generateDocumentOutline, waitForFonts } = parsePDFOptions(options);
    if (omitBackground) {
      await this.#emulationManager.setTransparentBackgroundColor();
    }
    if (waitForFonts) {
      await firstValueFrom(from(this.mainFrame().isolatedRealm().evaluate(() => {
        return document.fonts.ready;
      })).pipe(raceWith(timeout(ms))));
    }
    const printCommandPromise = this.#primaryTargetClient.send("Page.printToPDF", {
      transferMode: "ReturnAsStream",
      landscape,
      displayHeaderFooter,
      headerTemplate,
      footerTemplate,
      printBackground,
      scale,
      paperWidth,
      paperHeight,
      marginTop: margin.top,
      marginBottom: margin.bottom,
      marginLeft: margin.left,
      marginRight: margin.right,
      pageRanges,
      preferCSSPageSize,
      generateTaggedPDF,
      generateDocumentOutline
    });
    const result = await firstValueFrom(from(printCommandPromise).pipe(raceWith(timeout(ms))));
    if (omitBackground) {
      await this.#emulationManager.resetDefaultBackgroundColor();
    }
    assert(result.stream, "`stream` is missing from `Page.printToPDF");
    return await getReadableFromProtocolStream(this.#primaryTargetClient, result.stream);
  }
  async pdf(options = {}) {
    const { path = void 0 } = options;
    const readable = await this.createPDFStream(options);
    const typedArray = await getReadableAsTypedArray(readable, path);
    assert(typedArray, "Could not create typed array");
    return typedArray;
  }
  async close(options = { runBeforeUnload: void 0 }) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const _guard = __addDisposableResource12(env_3, await this.browserContext().waitForScreenshotOperations(), false);
      const connection = this.#primaryTargetClient.connection();
      assert(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
      const runBeforeUnload = !!options.runBeforeUnload;
      if (runBeforeUnload) {
        await this.#primaryTargetClient.send("Page.close");
      } else {
        await connection.send("Target.closeTarget", {
          targetId: this.#primaryTarget._targetId
        });
        await this.#tabTarget._isClosedDeferred.valueOrThrow();
      }
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources12(env_3);
    }
  }
  isClosed() {
    return this.#closed;
  }
  get mouse() {
    return this.#mouse;
  }
  /**
   * This method is typically coupled with an action that triggers a device
   * request from an api such as WebBluetooth.
   *
   * :::caution
   *
   * This must be called before the device request is made. It will not return a
   * currently active device prompt.
   *
   * :::
   *
   * @example
   *
   * ```ts
   * const [devicePrompt] = Promise.all([
   *   page.waitForDevicePrompt(),
   *   page.click('#connect-bluetooth'),
   * ]);
   * await devicePrompt.select(
   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device')),
   * );
   * ```
   */
  async waitForDevicePrompt(options = {}) {
    return await this.mainFrame().waitForDevicePrompt(options);
  }
};
var supportedMetrics = /* @__PURE__ */ new Set([
  "Timestamp",
  "Documents",
  "Frames",
  "JSEventListeners",
  "Nodes",
  "LayoutCount",
  "RecalcStyleCount",
  "LayoutDuration",
  "RecalcStyleDuration",
  "ScriptDuration",
  "TaskDuration",
  "JSHeapUsedSize",
  "JSHeapTotalSize"
]);
function getIntersectionRect(clip, viewport) {
  const x = Math.max(clip.x, viewport.x);
  const y = Math.max(clip.y, viewport.y);
  return {
    x,
    y,
    width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x, 0),
    height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y, 0)
  };
}
function convertCookiesPartitionKeyFromPuppeteerToCdp(partitionKey) {
  if (partitionKey === void 0) {
    return void 0;
  }
  if (typeof partitionKey === "string") {
    return {
      topLevelSite: partitionKey,
      hasCrossSiteAncestor: false
    };
  }
  return {
    topLevelSite: partitionKey.sourceOrigin,
    hasCrossSiteAncestor: partitionKey.hasCrossSiteAncestor ?? false
  };
}

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserContext.js
var __addDisposableResource13 = function(env, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose, inner;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async2)
        inner = dispose;
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    if (inner)
      dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
    env.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources13 = function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1)
            return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async)
              return s |= 2, Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } else
            s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1)
        return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError)
        throw env.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var CdpBrowserContext = class extends BrowserContext {
  #connection;
  #browser;
  #id;
  constructor(connection, browser, contextId) {
    super();
    this.#connection = connection;
    this.#browser = browser;
    this.#id = contextId;
  }
  get id() {
    return this.#id;
  }
  targets() {
    return this.#browser.targets().filter((target) => {
      return target.browserContext() === this;
    });
  }
  async pages() {
    const pages = await Promise.all(this.targets().filter((target) => {
      return target.type() === "page" || target.type() === "other" && this.#browser._getIsPageTargetCallback()?.(target);
    }).map((target) => {
      return target.page();
    }));
    return pages.filter((page) => {
      return !!page;
    });
  }
  async overridePermissions(origin, permissions) {
    const protocolPermissions = permissions.map((permission) => {
      const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
      if (!protocolPermission) {
        throw new Error("Unknown permission: " + permission);
      }
      return protocolPermission;
    });
    await this.#connection.send("Browser.grantPermissions", {
      origin,
      browserContextId: this.#id || void 0,
      permissions: protocolPermissions
    });
  }
  async clearPermissionOverrides() {
    await this.#connection.send("Browser.resetPermissions", {
      browserContextId: this.#id || void 0
    });
  }
  async newPage() {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const _guard = __addDisposableResource13(env_1, await this.waitForScreenshotOperations(), false);
      return await this.#browser._createPageInContext(this.#id);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources13(env_1);
    }
  }
  browser() {
    return this.#browser;
  }
  async close() {
    assert(this.#id, "Default BrowserContext cannot be closed!");
    await this.#browser._disposeContext(this.#id);
  }
  async cookies() {
    const { cookies } = await this.#connection.send("Storage.getCookies", {
      browserContextId: this.#id
    });
    return cookies.map((cookie) => {
      return {
        ...cookie,
        partitionKey: cookie.partitionKey ? {
          sourceOrigin: cookie.partitionKey.topLevelSite,
          hasCrossSiteAncestor: cookie.partitionKey.hasCrossSiteAncestor
        } : void 0
      };
    });
  }
  async setCookie(...cookies) {
    return await this.#connection.send("Storage.setCookies", {
      browserContextId: this.#id,
      cookies: cookies.map((cookie) => {
        return {
          ...cookie,
          partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookie.partitionKey)
        };
      })
    });
  }
  async setDownloadBehavior(downloadBehavior) {
    await this.#connection.send("Browser.setDownloadBehavior", {
      behavior: downloadBehavior.policy,
      downloadPath: downloadBehavior.downloadPath,
      browserContextId: this.#id
    });
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Target.js
init_Target();
init_util();
init_Deferred();
var InitializationStatus;
(function(InitializationStatus2) {
  InitializationStatus2["SUCCESS"] = "success";
  InitializationStatus2["ABORTED"] = "aborted";
})(InitializationStatus || (InitializationStatus = {}));
var CdpTarget = class extends Target {
  #browserContext;
  #session;
  #targetInfo;
  #targetManager;
  #sessionFactory;
  #childTargets = /* @__PURE__ */ new Set();
  _initializedDeferred = Deferred.create();
  _isClosedDeferred = Deferred.create();
  _targetId;
  /**
   * To initialize the target for use, call initialize.
   *
   * @internal
   */
  constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
    super();
    this.#session = session;
    this.#targetManager = targetManager;
    this.#targetInfo = targetInfo;
    this.#browserContext = browserContext;
    this._targetId = targetInfo.targetId;
    this.#sessionFactory = sessionFactory;
    if (this.#session) {
      this.#session.setTarget(this);
    }
  }
  async asPage() {
    const session = this._session();
    if (!session) {
      return await this.createCDPSession().then((client) => {
        return CdpPage._create(client, this, null);
      });
    }
    return await CdpPage._create(session, this, null);
  }
  _subtype() {
    return this.#targetInfo.subtype;
  }
  _session() {
    return this.#session;
  }
  _addChildTarget(target) {
    this.#childTargets.add(target);
  }
  _removeChildTarget(target) {
    this.#childTargets.delete(target);
  }
  _childTargets() {
    return this.#childTargets;
  }
  _sessionFactory() {
    if (!this.#sessionFactory) {
      throw new Error("sessionFactory is not initialized");
    }
    return this.#sessionFactory;
  }
  createCDPSession() {
    if (!this.#sessionFactory) {
      throw new Error("sessionFactory is not initialized");
    }
    return this.#sessionFactory(false).then((session) => {
      session.setTarget(this);
      return session;
    });
  }
  url() {
    return this.#targetInfo.url;
  }
  type() {
    const type = this.#targetInfo.type;
    switch (type) {
      case "page":
        return TargetType.PAGE;
      case "background_page":
        return TargetType.BACKGROUND_PAGE;
      case "service_worker":
        return TargetType.SERVICE_WORKER;
      case "shared_worker":
        return TargetType.SHARED_WORKER;
      case "browser":
        return TargetType.BROWSER;
      case "webview":
        return TargetType.WEBVIEW;
      case "tab":
        return TargetType.TAB;
      default:
        return TargetType.OTHER;
    }
  }
  _targetManager() {
    if (!this.#targetManager) {
      throw new Error("targetManager is not initialized");
    }
    return this.#targetManager;
  }
  _getTargetInfo() {
    return this.#targetInfo;
  }
  browser() {
    if (!this.#browserContext) {
      throw new Error("browserContext is not initialized");
    }
    return this.#browserContext.browser();
  }
  browserContext() {
    if (!this.#browserContext) {
      throw new Error("browserContext is not initialized");
    }
    return this.#browserContext;
  }
  opener() {
    const { openerId } = this.#targetInfo;
    if (!openerId) {
      return;
    }
    return this.browser().targets().find((target) => {
      return target._targetId === openerId;
    });
  }
  _targetInfoChanged(targetInfo) {
    this.#targetInfo = targetInfo;
    this._checkIfInitialized();
  }
  _initialize() {
    this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
  }
  _isTargetExposed() {
    return this.type() !== TargetType.TAB && !this._subtype();
  }
  _checkIfInitialized() {
    if (!this._initializedDeferred.resolved()) {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
  }
};
var PageTarget = class extends CdpTarget {
  #defaultViewport;
  pagePromise;
  constructor(targetInfo, session, browserContext, targetManager, sessionFactory, defaultViewport) {
    super(targetInfo, session, browserContext, targetManager, sessionFactory);
    this.#defaultViewport = defaultViewport ?? void 0;
  }
  _initialize() {
    this._initializedDeferred.valueOrThrow().then(async (result) => {
      if (result === InitializationStatus.ABORTED) {
        return;
      }
      const opener = this.opener();
      if (!(opener instanceof PageTarget)) {
        return;
      }
      if (!opener || !opener.pagePromise || this.type() !== "page") {
        return true;
      }
      const openerPage = await opener.pagePromise;
      if (!openerPage.listenerCount(
        "popup"
        /* PageEvent.Popup */
      )) {
        return true;
      }
      const popupPage = await this.page();
      openerPage.emit("popup", popupPage);
      return true;
    }).catch(debugError);
    this._checkIfInitialized();
  }
  async page() {
    if (!this.pagePromise) {
      const session = this._session();
      this.pagePromise = (session ? Promise.resolve(session) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        false
      )).then((client) => {
        return CdpPage._create(client, this, this.#defaultViewport ?? null);
      });
    }
    return await this.pagePromise ?? null;
  }
  _checkIfInitialized() {
    if (this._initializedDeferred.resolved()) {
      return;
    }
    if (this._getTargetInfo().url !== "") {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
  }
};
var DevToolsTarget = class extends PageTarget {
};
var WorkerTarget = class extends CdpTarget {
  #workerPromise;
  async worker() {
    if (!this.#workerPromise) {
      const session = this._session();
      this.#workerPromise = (session ? Promise.resolve(session) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        false
      )).then((client) => {
        return new CdpWebWorker(
          client,
          this._getTargetInfo().url,
          this._targetId,
          this.type(),
          () => {
          },
          () => {
          }
          /* exceptionThrown */
        );
      });
    }
    return await this.#workerPromise;
  }
};
var OtherTarget = class extends CdpTarget {
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/TargetManager.js
init_CDPSession();
init_EventEmitter();
init_util();
init_assert();
init_Deferred();
function isPageTargetBecomingPrimary(target, newTargetInfo) {
  return Boolean(target._subtype()) && !newTargetInfo.subtype;
}
var TargetManager = class extends EventEmitter {
  #connection;
  /**
   * Keeps track of the following events: 'Target.targetCreated',
   * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
   *
   * A target becomes discovered when 'Target.targetCreated' is received.
   * A target is removed from this map once 'Target.targetDestroyed' is
   * received.
   *
   * `targetFilterCallback` has no effect on this map.
   */
  #discoveredTargetsByTargetId = /* @__PURE__ */ new Map();
  /**
   * A target is added to this map once TargetManager has created
   * a Target and attached at least once to it.
   */
  #attachedTargetsByTargetId = /* @__PURE__ */ new Map();
  /**
   * Tracks which sessions attach to which target.
   */
  #attachedTargetsBySessionId = /* @__PURE__ */ new Map();
  /**
   * If a target was filtered out by `targetFilterCallback`, we still receive
   * events about it from CDP, but we don't forward them to the rest of Puppeteer.
   */
  #ignoredTargets = /* @__PURE__ */ new Set();
  #targetFilterCallback;
  #targetFactory;
  #attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap();
  #detachedFromTargetListenersBySession = /* @__PURE__ */ new WeakMap();
  #initializeDeferred = Deferred.create();
  #targetsIdsForInit = /* @__PURE__ */ new Set();
  #waitForInitiallyDiscoveredTargets = true;
  #discoveryFilter = [{}];
  constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {
    super();
    this.#connection = connection;
    this.#targetFilterCallback = targetFilterCallback;
    this.#targetFactory = targetFactory;
    this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;
    this.#connection.on("Target.targetCreated", this.#onTargetCreated);
    this.#connection.on("Target.targetDestroyed", this.#onTargetDestroyed);
    this.#connection.on("Target.targetInfoChanged", this.#onTargetInfoChanged);
    this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
    this.#setupAttachmentListeners(this.#connection);
  }
  #storeExistingTargetsForInit = () => {
    if (!this.#waitForInitiallyDiscoveredTargets) {
      return;
    }
    for (const [targetId, targetInfo] of this.#discoveredTargetsByTargetId.entries()) {
      const targetForFilter = new CdpTarget(targetInfo, void 0, void 0, this, void 0);
      const isPageOrFrame = targetInfo.type === "page" || targetInfo.type === "iframe";
      const isExtension = targetInfo.url.startsWith("chrome-extension://");
      if ((!this.#targetFilterCallback || this.#targetFilterCallback(targetForFilter)) && isPageOrFrame && !isExtension) {
        this.#targetsIdsForInit.add(targetId);
      }
    }
  };
  async initialize() {
    await this.#connection.send("Target.setDiscoverTargets", {
      discover: true,
      filter: this.#discoveryFilter
    });
    this.#storeExistingTargetsForInit();
    await this.#connection.send("Target.setAutoAttach", {
      waitForDebuggerOnStart: true,
      flatten: true,
      autoAttach: true,
      filter: [
        {
          type: "page",
          exclude: true
        },
        ...this.#discoveryFilter
      ]
    });
    this.#finishInitializationIfReady();
    await this.#initializeDeferred.valueOrThrow();
  }
  getChildTargets(target) {
    return target._childTargets();
  }
  dispose() {
    this.#connection.off("Target.targetCreated", this.#onTargetCreated);
    this.#connection.off("Target.targetDestroyed", this.#onTargetDestroyed);
    this.#connection.off("Target.targetInfoChanged", this.#onTargetInfoChanged);
    this.#connection.off(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
    this.#removeAttachmentListeners(this.#connection);
  }
  getAvailableTargets() {
    return this.#attachedTargetsByTargetId;
  }
  #setupAttachmentListeners(session) {
    const listener = (event) => {
      void this.#onAttachedToTarget(session, event);
    };
    assert(!this.#attachedToTargetListenersBySession.has(session));
    this.#attachedToTargetListenersBySession.set(session, listener);
    session.on("Target.attachedToTarget", listener);
    const detachedListener = (event) => {
      return this.#onDetachedFromTarget(session, event);
    };
    assert(!this.#detachedFromTargetListenersBySession.has(session));
    this.#detachedFromTargetListenersBySession.set(session, detachedListener);
    session.on("Target.detachedFromTarget", detachedListener);
  }
  #removeAttachmentListeners(session) {
    const listener = this.#attachedToTargetListenersBySession.get(session);
    if (listener) {
      session.off("Target.attachedToTarget", listener);
      this.#attachedToTargetListenersBySession.delete(session);
    }
    if (this.#detachedFromTargetListenersBySession.has(session)) {
      session.off("Target.detachedFromTarget", this.#detachedFromTargetListenersBySession.get(session));
      this.#detachedFromTargetListenersBySession.delete(session);
    }
  }
  #onSessionDetached = (session) => {
    this.#removeAttachmentListeners(session);
  };
  #onTargetCreated = async (event) => {
    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
    this.emit("targetDiscovered", event.targetInfo);
    if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
      if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {
        return;
      }
      const target = this.#targetFactory(event.targetInfo, void 0);
      target._initialize();
      this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);
    }
  };
  #onTargetDestroyed = (event) => {
    const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);
    this.#discoveredTargetsByTargetId.delete(event.targetId);
    this.#finishInitializationIfReady(event.targetId);
    if (targetInfo?.type === "service_worker" && this.#attachedTargetsByTargetId.has(event.targetId)) {
      const target = this.#attachedTargetsByTargetId.get(event.targetId);
      if (target) {
        this.emit("targetGone", target);
        this.#attachedTargetsByTargetId.delete(event.targetId);
      }
    }
  };
  #onTargetInfoChanged = (event) => {
    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
    if (this.#ignoredTargets.has(event.targetInfo.targetId) || !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) || !event.targetInfo.attached) {
      return;
    }
    const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);
    if (!target) {
      return;
    }
    const previousURL = target.url();
    const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;
    if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
      const session = target?._session();
      assert(session, "Target that is being activated is missing a CDPSession.");
      session.parentSession()?.emit(CDPSessionEvent.Swapped, session);
    }
    target._targetInfoChanged(event.targetInfo);
    if (wasInitialized && previousURL !== target.url()) {
      this.emit("targetChanged", {
        target,
        wasInitialized,
        previousURL
      });
    }
  };
  #onAttachedToTarget = async (parentSession, event) => {
    const targetInfo = event.targetInfo;
    const session = this.#connection._session(event.sessionId);
    if (!session) {
      throw new Error(`Session ${event.sessionId} was not created.`);
    }
    const silentDetach = async () => {
      await session.send("Runtime.runIfWaitingForDebugger").catch(debugError);
      await parentSession.send("Target.detachFromTarget", {
        sessionId: session.id()
      }).catch(debugError);
    };
    if (!this.#connection.isAutoAttached(targetInfo.targetId)) {
      return;
    }
    if (targetInfo.type === "service_worker") {
      this.#finishInitializationIfReady(targetInfo.targetId);
      await silentDetach();
      if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {
        return;
      }
      const target2 = this.#targetFactory(targetInfo);
      target2._initialize();
      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target2);
      this.emit("targetAvailable", target2);
      return;
    }
    const isExistingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);
    const target = isExistingTarget ? this.#attachedTargetsByTargetId.get(targetInfo.targetId) : this.#targetFactory(targetInfo, session, parentSession instanceof CdpCDPSession ? parentSession : void 0);
    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
      this.#ignoredTargets.add(targetInfo.targetId);
      this.#finishInitializationIfReady(targetInfo.targetId);
      await silentDetach();
      return;
    }
    this.#setupAttachmentListeners(session);
    if (isExistingTarget) {
      session.setTarget(target);
      this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));
    } else {
      target._initialize();
      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
      this.#attachedTargetsBySessionId.set(session.id(), target);
    }
    const parentTarget = parentSession instanceof CDPSession ? parentSession.target() : null;
    parentTarget?._addChildTarget(target);
    parentSession.emit(CDPSessionEvent.Ready, session);
    this.#targetsIdsForInit.delete(target._targetId);
    if (!isExistingTarget) {
      this.emit("targetAvailable", target);
    }
    this.#finishInitializationIfReady();
    await Promise.all([
      session.send("Target.setAutoAttach", {
        waitForDebuggerOnStart: true,
        flatten: true,
        autoAttach: true,
        filter: this.#discoveryFilter
      }),
      session.send("Runtime.runIfWaitingForDebugger")
    ]).catch(debugError);
  };
  #finishInitializationIfReady(targetId) {
    if (targetId !== void 0) {
      this.#targetsIdsForInit.delete(targetId);
    }
    if (this.#targetsIdsForInit.size === 0) {
      this.#initializeDeferred.resolve();
    }
  }
  #onDetachedFromTarget = (parentSession, event) => {
    const target = this.#attachedTargetsBySessionId.get(event.sessionId);
    this.#attachedTargetsBySessionId.delete(event.sessionId);
    if (!target) {
      return;
    }
    if (parentSession instanceof CDPSession) {
      parentSession.target()._removeChildTarget(target);
    }
    this.#attachedTargetsByTargetId.delete(target._targetId);
    this.emit("targetGone", target);
  };
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Browser.js
var CdpBrowser = class extends Browser {
  protocol = "cdp";
  static async _create(connection, contextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, process3, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
    const browser = new CdpBrowser(connection, contextIds, defaultViewport, process3, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets);
    if (acceptInsecureCerts) {
      await connection.send("Security.setIgnoreCertificateErrors", {
        ignore: true
      });
    }
    await browser._attach(downloadBehavior);
    return browser;
  }
  #defaultViewport;
  #process;
  #connection;
  #closeCallback;
  #targetFilterCallback;
  #isPageTargetCallback;
  #defaultContext;
  #contexts = /* @__PURE__ */ new Map();
  #targetManager;
  constructor(connection, contextIds, defaultViewport, process3, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
    super();
    this.#defaultViewport = defaultViewport;
    this.#process = process3;
    this.#connection = connection;
    this.#closeCallback = closeCallback || (() => {
    });
    this.#targetFilterCallback = targetFilterCallback || (() => {
      return true;
    });
    this.#setIsPageTargetCallback(isPageTargetCallback);
    this.#targetManager = new TargetManager(connection, this.#createTarget, this.#targetFilterCallback, waitForInitiallyDiscoveredTargets);
    this.#defaultContext = new CdpBrowserContext(this.#connection, this);
    for (const contextId of contextIds) {
      this.#contexts.set(contextId, new CdpBrowserContext(this.#connection, this, contextId));
    }
  }
  #emitDisconnected = () => {
    this.emit("disconnected", void 0);
  };
  async _attach(downloadBehavior) {
    this.#connection.on(CDPSessionEvent.Disconnected, this.#emitDisconnected);
    if (downloadBehavior) {
      await this.#defaultContext.setDownloadBehavior(downloadBehavior);
    }
    this.#targetManager.on("targetAvailable", this.#onAttachedToTarget);
    this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
    this.#targetManager.on("targetChanged", this.#onTargetChanged);
    this.#targetManager.on("targetDiscovered", this.#onTargetDiscovered);
    await this.#targetManager.initialize();
  }
  _detach() {
    this.#connection.off(CDPSessionEvent.Disconnected, this.#emitDisconnected);
    this.#targetManager.off("targetAvailable", this.#onAttachedToTarget);
    this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
    this.#targetManager.off("targetChanged", this.#onTargetChanged);
    this.#targetManager.off("targetDiscovered", this.#onTargetDiscovered);
  }
  process() {
    return this.#process ?? null;
  }
  _targetManager() {
    return this.#targetManager;
  }
  #setIsPageTargetCallback(isPageTargetCallback) {
    this.#isPageTargetCallback = isPageTargetCallback || ((target) => {
      return target.type() === "page" || target.type() === "background_page" || target.type() === "webview";
    });
  }
  _getIsPageTargetCallback() {
    return this.#isPageTargetCallback;
  }
  async createBrowserContext(options = {}) {
    const { proxyServer, proxyBypassList, downloadBehavior } = options;
    const { browserContextId } = await this.#connection.send("Target.createBrowserContext", {
      proxyServer,
      proxyBypassList: proxyBypassList && proxyBypassList.join(",")
    });
    const context2 = new CdpBrowserContext(this.#connection, this, browserContextId);
    if (downloadBehavior) {
      await context2.setDownloadBehavior(downloadBehavior);
    }
    this.#contexts.set(browserContextId, context2);
    return context2;
  }
  browserContexts() {
    return [this.#defaultContext, ...Array.from(this.#contexts.values())];
  }
  defaultBrowserContext() {
    return this.#defaultContext;
  }
  async _disposeContext(contextId) {
    if (!contextId) {
      return;
    }
    await this.#connection.send("Target.disposeBrowserContext", {
      browserContextId: contextId
    });
    this.#contexts.delete(contextId);
  }
  #createTarget = (targetInfo, session) => {
    const { browserContextId } = targetInfo;
    const context2 = browserContextId && this.#contexts.has(browserContextId) ? this.#contexts.get(browserContextId) : this.#defaultContext;
    if (!context2) {
      throw new Error("Missing browser context");
    }
    const createSession = (isAutoAttachEmulated) => {
      return this.#connection._createSession(targetInfo, isAutoAttachEmulated);
    };
    const otherTarget = new OtherTarget(targetInfo, session, context2, this.#targetManager, createSession);
    if (targetInfo.url?.startsWith("devtools://")) {
      return new DevToolsTarget(targetInfo, session, context2, this.#targetManager, createSession, this.#defaultViewport ?? null);
    }
    if (this.#isPageTargetCallback(otherTarget)) {
      return new PageTarget(targetInfo, session, context2, this.#targetManager, createSession, this.#defaultViewport ?? null);
    }
    if (targetInfo.type === "service_worker" || targetInfo.type === "shared_worker") {
      return new WorkerTarget(targetInfo, session, context2, this.#targetManager, createSession);
    }
    return otherTarget;
  };
  #onAttachedToTarget = async (target) => {
    if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
      this.emit("targetcreated", target);
      target.browserContext().emit("targetcreated", target);
    }
  };
  #onDetachedFromTarget = async (target) => {
    target._initializedDeferred.resolve(InitializationStatus.ABORTED);
    target._isClosedDeferred.resolve();
    if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
      this.emit("targetdestroyed", target);
      target.browserContext().emit("targetdestroyed", target);
    }
  };
  #onTargetChanged = ({ target }) => {
    this.emit("targetchanged", target);
    target.browserContext().emit("targetchanged", target);
  };
  #onTargetDiscovered = (targetInfo) => {
    this.emit("targetdiscovered", targetInfo);
  };
  wsEndpoint() {
    return this.#connection.url();
  }
  async newPage() {
    return await this.#defaultContext.newPage();
  }
  async _createPageInContext(contextId) {
    const { targetId } = await this.#connection.send("Target.createTarget", {
      url: "about:blank",
      browserContextId: contextId || void 0
    });
    const target = await this.waitForTarget((t) => {
      return t._targetId === targetId;
    });
    if (!target) {
      throw new Error(`Missing target for page (id = ${targetId})`);
    }
    const initialized = await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS;
    if (!initialized) {
      throw new Error(`Failed to create target for page (id = ${targetId})`);
    }
    const page = await target.page();
    if (!page) {
      throw new Error(`Failed to create a page for context (id = ${contextId})`);
    }
    return page;
  }
  targets() {
    return Array.from(this.#targetManager.getAvailableTargets().values()).filter((target) => {
      return target._isTargetExposed() && target._initializedDeferred.value() === InitializationStatus.SUCCESS;
    });
  }
  target() {
    const browserTarget = this.targets().find((target) => {
      return target.type() === "browser";
    });
    if (!browserTarget) {
      throw new Error("Browser target is not found");
    }
    return browserTarget;
  }
  async version() {
    const version = await this.#getVersion();
    return version.product;
  }
  async userAgent() {
    const version = await this.#getVersion();
    return version.userAgent;
  }
  async close() {
    await this.#closeCallback.call(null);
    await this.disconnect();
  }
  disconnect() {
    this.#targetManager.dispose();
    this.#connection.dispose();
    this._detach();
    return Promise.resolve();
  }
  get connected() {
    return !this.#connection._closed;
  }
  #getVersion() {
    return this.#connection.send("Browser.getVersion");
  }
  get debugInfo() {
    return {
      pendingProtocolErrors: this.#connection.getPendingProtocolErrors()
    };
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js
init_util();
async function _connectToCdpBrowser(connectionTransport, url, options) {
  const { acceptInsecureCerts = false, defaultViewport = DEFAULT_VIEWPORT, downloadBehavior, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout } = options;
  const connection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
  const { browserContextIds } = await connection.send("Target.getBrowserContexts");
  const browser = await CdpBrowser._create(connection, browserContextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, void 0, () => {
    return connection.send("Browser.close").catch(debugError);
  }, targetFilter, isPageTarget);
  return browser;
}

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/cdp.js
init_Coverage();
init_EmulationManager();

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/PredefinedNetworkConditions.js
var PredefinedNetworkConditions = Object.freeze({
  // Generally aligned with DevTools
  // https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/core/sdk/NetworkManager.ts;l=398;drc=225e1240f522ca684473f541ae6dae6cd766dd33.
  "Slow 3G": {
    // ~500Kbps down
    download: 500 * 1e3 / 8 * 0.8,
    // ~500Kbps up
    upload: 500 * 1e3 / 8 * 0.8,
    // 400ms RTT
    latency: 400 * 5
  },
  "Fast 3G": {
    // ~1.6 Mbps down
    download: 1.6 * 1e3 * 1e3 / 8 * 0.9,
    // ~0.75 Mbps up
    upload: 750 * 1e3 / 8 * 0.9,
    // 150ms RTT
    latency: 150 * 3.75
  },
  // alias to Fast 3G to align with Lighthouse (crbug.com/342406608)
  // and DevTools (crbug.com/342406608),
  "Slow 4G": {
    // ~1.6 Mbps down
    download: 1.6 * 1e3 * 1e3 / 8 * 0.9,
    // ~0.75 Mbps up
    upload: 750 * 1e3 / 8 * 0.9,
    // 150ms RTT
    latency: 150 * 3.75
  },
  "Fast 4G": {
    // 9 Mbps down
    download: 9 * 1e3 * 1e3 / 8 * 0.9,
    // 1.5 Mbps up
    upload: 1.5 * 1e3 * 1e3 / 8 * 0.9,
    // 60ms RTT
    latency: 60 * 2.75
  }
});

// node_modules/puppeteer-core/lib/esm/puppeteer/cdp/cdp.js
init_Tracing();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/common.js
init_BrowserWebSocketTransport();
init_CallbackRegistry();
init_ConsoleMessage();
init_CustomQueryHandler();
init_Debug();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Device.js
var knownDevices = [
  {
    name: "Blackberry PlayBook",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 600,
      height: 1024,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Blackberry PlayBook landscape",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 1024,
      height: 600,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "BlackBerry Z30",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "BlackBerry Z30 landscape",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Note 3",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Note 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Note II",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Note II landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S III",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S III landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S5",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S8",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 740,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S8 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 740,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S9+",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 320,
      height: 658,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S9+ landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 658,
      height: 320,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Tab S4",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 712,
      height: 1138,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Tab S4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 1138,
      height: 712,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad (gen 6)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad (gen 6) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad (gen 7)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 810,
      height: 1080,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad (gen 7) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1080,
      height: 810,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Mini",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Mini landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Pro",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 1366,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Pro landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1366,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Pro 11",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 834,
      height: 1194,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Pro 11 landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1194,
      height: 834,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 4",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 320,
      height: 480,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 4 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 480,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 5",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 5 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 6",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 6 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 6 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 6 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 7",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 7 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 7 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 7 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 8",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 8 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 8 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 8 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone SE",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone SE landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone X",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone X landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone XR",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone XR landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 828,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 828,
      height: 414,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 663,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 340,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 832,
      height: 378,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "JioPhone 2",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 240,
      height: 320,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "JioPhone 2 landscape",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 320,
      height: 240,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Kindle Fire HDX",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Kindle Fire HDX landscape",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "LG Optimus L70",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "LG Optimus L70 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Microsoft Lumia 550",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Microsoft Lumia 950",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Microsoft Lumia 950 landscape",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 10",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 10 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 4",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 5",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 5X",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 5X landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 6",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 6 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 6P",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 6P landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 7",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 600,
      height: 960,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 7 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 960,
      height: 600,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nokia Lumia 520",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 320,
      height: 533,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nokia Lumia 520 landscape",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 533,
      height: 320,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nokia N9",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 480,
      height: 854,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nokia N9 landscape",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 854,
      height: 480,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 2",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 731,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 2 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 731,
      height: 411,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 2 XL",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 823,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 2 XL landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 823,
      height: 411,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 3",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 786,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 786,
      height: 393,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 4",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 4a (5G)",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 4a (5G) landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 5",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 851,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 851,
      height: 393,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Moto G4",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Moto G4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }
];
var knownDevicesByName = {};
for (const device of knownDevices) {
  knownDevicesByName[device.name] = device;
}
var KnownDevices = Object.freeze(knownDevicesByName);

// node_modules/puppeteer-core/lib/esm/puppeteer/common/common.js
init_Errors();
init_EventEmitter();
init_GetQueryHandler();
init_HandleIterator();
init_LazyArg();
init_PDFOptions();
init_PierceQueryHandler();
init_PQueryHandler();
init_PSelectorParser();

// node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserConnector.js
init_Errors();
init_util();
async function _connectToBiDiBrowser(connectionTransport, url, options) {
  const { acceptInsecureCerts = false, defaultViewport = DEFAULT_VIEWPORT } = options;
  const { bidiConnection, cdpConnection, closeCallback } = await getBiDiConnection(connectionTransport, url, options);
  const BiDi = await Promise.resolve().then(() => (init_bidi(), bidi_exports));
  const bidiBrowser = await BiDi.BidiBrowser.create({
    connection: bidiConnection,
    cdpConnection,
    closeCallback,
    process: void 0,
    defaultViewport,
    acceptInsecureCerts,
    capabilities: options.capabilities
  });
  return bidiBrowser;
}
async function getBiDiConnection(connectionTransport, url, options) {
  const BiDi = await Promise.resolve().then(() => (init_bidi(), bidi_exports));
  const { slowMo = 0, protocolTimeout } = options;
  const pureBidiConnection = new BiDi.BidiConnection(url, connectionTransport, slowMo, protocolTimeout);
  try {
    const result = await pureBidiConnection.send("session.status", {});
    if ("type" in result && result.type === "success") {
      return {
        bidiConnection: pureBidiConnection,
        closeCallback: async () => {
          await pureBidiConnection.send("browser.close", {}).catch(debugError);
        }
      };
    }
  } catch (e) {
    if (!(e instanceof ProtocolError)) {
      throw e;
    }
  }
  pureBidiConnection.unbind();
  const cdpConnection = new Connection(
    url,
    connectionTransport,
    slowMo,
    protocolTimeout,
    /* rawErrors= */
    true
  );
  const version = await cdpConnection.send("Browser.getVersion");
  if (version.product.toLowerCase().includes("firefox")) {
    throw new UnsupportedOperation("Firefox is not supported in BiDi over CDP mode.");
  }
  const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);
  return {
    cdpConnection,
    bidiConnection: bidiOverCdpConnection,
    closeCallback: async () => {
      await cdpConnection.send("Browser.close").catch(debugError);
    }
  };
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js
init_environment();
init_assert();
init_ErrorLike();
var getWebSocketTransportClass = async () => {
  return isNode ? (await Promise.resolve().then(() => (init_NodeWebSocketTransport(), NodeWebSocketTransport_exports))).NodeWebSocketTransport : (await Promise.resolve().then(() => (init_BrowserWebSocketTransport(), BrowserWebSocketTransport_exports))).BrowserWebSocketTransport;
};
async function _connectToBrowser(options) {
  const { connectionTransport, endpointUrl } = await getConnectionTransport(options);
  if (options.protocol === "webDriverBiDi") {
    const bidiBrowser = await _connectToBiDiBrowser(connectionTransport, endpointUrl, options);
    return bidiBrowser;
  } else {
    const cdpBrowser = await _connectToCdpBrowser(connectionTransport, endpointUrl, options);
    return cdpBrowser;
  }
}
async function getConnectionTransport(options) {
  const { browserWSEndpoint, browserURL, transport, headers = {} } = options;
  assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
  if (transport) {
    return { connectionTransport: transport, endpointUrl: "" };
  } else if (browserWSEndpoint) {
    const WebSocketClass = await getWebSocketTransportClass();
    const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
    return {
      connectionTransport,
      endpointUrl: browserWSEndpoint
    };
  } else if (browserURL) {
    const connectionURL = await getWSEndpoint(browserURL);
    const WebSocketClass = await getWebSocketTransportClass();
    const connectionTransport = await WebSocketClass.create(connectionURL);
    return {
      connectionTransport,
      endpointUrl: connectionURL
    };
  }
  throw new Error("Invalid connection options");
}
async function getWSEndpoint(browserURL) {
  const endpointURL = new URL("/json/version", browserURL);
  try {
    const result = await globalThis.fetch(endpointURL.toString(), {
      method: "GET"
    });
    if (!result.ok) {
      throw new Error(`HTTP ${result.statusText}`);
    }
    const data = await result.json();
    return data.webSocketDebuggerUrl;
  } catch (error) {
    if (isErrorLike(error)) {
      error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;
    }
    throw error;
  }
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js
init_CustomQueryHandler();
var Puppeteer = class {
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is only
   * allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```
   * import {Puppeteer}, puppeteer from 'puppeteer';
   *
   * Puppeteer.registerCustomQueryHandler('text', { … });
   * const aHandle = await page.$('text/…');
   * ```
   *
   * @param name - The name that the custom query handler will be registered
   * under.
   * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
   * to register.
   *
   * @public
   */
  static registerCustomQueryHandler(name, queryHandler) {
    return this.customQueryHandlers.register(name, queryHandler);
  }
  /**
   * Unregisters a custom query handler for a given name.
   */
  static unregisterCustomQueryHandler(name) {
    return this.customQueryHandlers.unregister(name);
  }
  /**
   * Gets the names of all custom query handlers.
   */
  static customQueryHandlerNames() {
    return this.customQueryHandlers.names();
  }
  /**
   * Unregisters all custom query handlers.
   */
  static clearCustomQueryHandlers() {
    return this.customQueryHandlers.clear();
  }
  /**
   * @internal
   */
  _isPuppeteerCore;
  /**
   * @internal
   */
  _changedBrowsers = false;
  /**
   * @internal
   */
  constructor(settings) {
    this._isPuppeteerCore = settings.isPuppeteerCore;
    this.connect = this.connect.bind(this);
  }
  /**
   * This method attaches Puppeteer to an existing browser instance.
   *
   * @remarks
   *
   * @param options - Set of configurable options to set on the browser.
   * @returns Promise which resolves to browser instance.
   */
  connect(options) {
    return _connectToBrowser(options);
  }
};
/**
 * Operations for {@link CustomQueryHandler | custom query handlers}. See
 * {@link CustomQueryHandlerRegistry}.
 *
 * @internal
 */
__publicField(Puppeteer, "customQueryHandlers", customQueryHandlers);

// node_modules/puppeteer-core/lib/esm/puppeteer/common/common.js
init_QueryHandler();
init_ScriptInjector();
init_SecurityDetails();
init_TextQueryHandler();
init_TimeoutSettings();
init_util();
init_WaitTask();
init_XPathQueryHandler();

// node_modules/puppeteer-core/lib/esm/puppeteer/revisions.js
var PUPPETEER_REVISIONS = Object.freeze({
  chrome: "134.0.6998.35",
  "chrome-headless-shell": "134.0.6998.35",
  firefox: "stable_136.0"
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/util.js
init_assert();
init_Deferred();
init_Mutex();
init_ErrorLike();
init_AsyncIterableUtil();
init_disposable();

// node_modules/puppeteer-core/lib/esm/puppeteer/puppeteer-core-browser.js
var puppeteer = new Puppeteer({
  isPuppeteerCore: true
});
var {
  /**
   * @public
   */
  connect
} = puppeteer;
var puppeteer_core_browser_default = puppeteer;

// scratch/client.ts
var p = puppeteer_core_browser_default.connect({
  browserURL: "http://localhost:3234/json/version"
}).then(async (b) => {
  console.log(await b.pages());
});
/*! Bundled license information:

puppeteer-core/lib/esm/puppeteer/util/disposable.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/environment.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/assert.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/encoding.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Debug.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Errors.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/util.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Deferred.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Mutex.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Function.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/LazyArg.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CSSQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PSelectorParser.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/decorators.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/JSHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Frame.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/incremental-id-generator.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Page.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/WaitTask.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Realm.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Target.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/WebWorker.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Connection.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/util.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Frame.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Page.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Target.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Browser.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/bidi.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/node/NodeWebSocketTransport.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/api.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Binding.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/FileChooser.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/NetworkManagerEvents.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/CdpSession.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Connection.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/CdpPreloadScript.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/utils.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameManagerEvents.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorld.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorlds.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Frame.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameTree.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/NetworkEventManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Page.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/BrowserContext.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Target.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/TargetManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/PredefinedNetworkConditions.js:
  (**
   * @license
   * Copyright 2021 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/cdp.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Device.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/BrowserConnector.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TaskQueue.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/common.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/revisions.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/util.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/index-browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/puppeteer-core-browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
