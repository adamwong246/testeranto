import { ChildProcess } from "node:child_process";
import { Page } from "puppeteer-core/lib/esm/puppeteer";
import fs from "fs";
import { WebSocketServer } from "ws";
import http from "http";
import { IRunnables, ITTestResourceConfiguration } from "../lib/index.js";
import { IBuiltConfig, IRunTime, ITestTypes } from "../Types.js";
import { Sidecar } from "../lib/Sidecar.js";
import { PM_WithEslintAndTsc } from "./PM_WithEslintAndTsc.js";
type LogStreams = {
    closeAll: () => void;
    writeExitCode: (code: number, error?: Error) => void;
    stdout?: fs.WriteStream;
    stderr?: fs.WriteStream;
    info?: fs.WriteStream;
    warn?: fs.WriteStream;
    error?: fs.WriteStream;
    debug?: fs.WriteStream;
    exit: fs.WriteStream;
};
declare function createLogStreams(reportDest: string, runtime: IRunTime): LogStreams;
export declare class PM_Main extends PM_WithEslintAndTsc {
    ports: Record<number, string>;
    queue: string[];
    logStreams: Record<string, ReturnType<typeof createLogStreams>>;
    webMetafileWatcher: fs.FSWatcher;
    nodeMetafileWatcher: fs.FSWatcher;
    importMetafileWatcher: fs.FSWatcher;
    pureSidecars: Record<number, Sidecar>;
    nodeSidecars: Record<number, ChildProcess>;
    webSidecars: Record<number, Page>;
    sidecars: Record<number, any>;
    launchers: Record<string, () => void>;
    wss: WebSocketServer;
    clients: Set<any>;
    httpServer: http.Server;
    runningProcesses: Map<string, ChildProcess>;
    allProcesses: Map<string, {
        child?: ChildProcess;
        status: "running" | "exited" | "error";
        exitCode?: number;
        error?: string;
        command: string;
        pid?: number;
        timestamp: string;
    }>;
    processLogs: Map<string, string[]>;
    constructor(configs: IBuiltConfig, name: string, mode: "once" | "dev");
    stopSideCar(uid: number): Promise<any>;
    launchSideCar(n: number, name: string): Promise<[number, ITTestResourceConfiguration]>;
    mapping(): [string, (...a: any[]) => any][];
    start(): Promise<void>;
    stop(): Promise<void>;
    getRunnables: (tests: ITestTypes[], testName: string, payload?: {
        nodeEntryPoints: {};
        nodeEntryPointSidecars: {};
        webEntryPoints: {};
        webEntryPointSidecars: {};
        pureEntryPoints: {};
        pureEntryPointSidecars: {};
    }) => IRunnables;
    metafileOutputs(platform: IRunTime): Promise<void>;
    launchPure: (src: string, dest: string) => Promise<(string | number)[] | undefined>;
    launchNode: (src: string, dest: string) => Promise<any[] | undefined>;
    launchWebSideCar: (testConfig: ITestTypes) => Promise<[number, Page]>;
    launchNodeSideCar: (sidecar: ITestTypes) => Promise<[number, ITTestResourceConfiguration]>;
    stopPureSideCar: (uid: number) => Promise<void>;
    launchPureSideCar: (sidecar: ITestTypes) => Promise<[number, ITTestResourceConfiguration]>;
    launchWeb: (src: string, dest: string) => Promise<void>;
    receiveFeaturesV2: (reportDest: string, srcTest: string, platform: IRunTime) => void;
    requestHandler(req: http.IncomingMessage, res: http.ServerResponse): void;
    findIndexHtml(): string | null;
    broadcast(message: any): void;
    checkQueue(): void;
    checkForShutdown: () => void;
}
export {};
