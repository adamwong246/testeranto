import { ChildProcess } from "node:child_process";
import { Page } from "puppeteer-core/lib/esm/puppeteer";
import fs from "fs";
import { WebSocketServer } from "ws";
import http from "http";
import { IBuiltConfig, IRunTime } from "../Types.js";
import { Sidecar } from "../lib/Sidecar.js";
import { PM_WithWebSocket } from "./PM_WithWebSocket.js";
import { createLogStreams } from "./utils.js";
export declare class PM_Main extends PM_WithWebSocket {
    ports: Record<number, string>;
    queue: string[];
    logStreams: Record<string, ReturnType<typeof createLogStreams>>;
    webMetafileWatcher: fs.FSWatcher;
    nodeMetafileWatcher: fs.FSWatcher;
    importMetafileWatcher: fs.FSWatcher;
    pitonoMetafileWatcher: fs.FSWatcher;
    pureSidecars: Record<number, Sidecar>;
    nodeSidecars: Record<number, ChildProcess>;
    webSidecars: Record<number, Page>;
    sidecars: Record<number, any>;
    launchers: Record<string, () => void>;
    wss: WebSocketServer;
    clients: Set<any>;
    httpServer: http.Server;
    runningProcesses: Map<string, ChildProcess>;
    allProcesses: Map<string, {
        child?: ChildProcess;
        status: "running" | "exited" | "error";
        exitCode?: number;
        error?: string;
        command: string;
        pid?: number;
        timestamp: string;
    }>;
    processLogs: Map<string, string[]>;
    constructor(configs: IBuiltConfig, name: string, mode: "once" | "dev");
    mapping(): [string, (...a: any[]) => any][];
    start(): Promise<void>;
    stop(): Promise<void>;
    metafileOutputs(platform: IRunTime): Promise<void>;
    launchPure: (src: string, dest: string) => Promise<(string | number)[] | undefined>;
    launchNode: (src: string, dest: string) => Promise<any[] | undefined>;
    launchWeb: (src: string, dest: string) => Promise<void>;
    launchPitono: (src: string, dest: string) => Promise<void>;
    launchGolingvu: (src: string, dest: string) => Promise<never>;
    receiveFeaturesV2: (reportDest: string, srcTest: string, platform: IRunTime) => void;
    requestHandler(req: http.IncomingMessage, res: http.ServerResponse): void;
    findIndexHtml(): string | null;
    broadcast(message: any): void;
    checkQueue(): void;
    checkForShutdown: () => void;
}
